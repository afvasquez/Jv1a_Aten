
RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000a0  00800100  000034a0  00003534  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000034a0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000710  008001a0  008001a0  000035d4  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000035d4  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000003f0  00000000  00000000  00003604  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00002a32  00000000  00000000  000039f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000b4c  00000000  00000000  00006426  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00001850  00000000  00000000  00006f72  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000df4  00000000  00000000  000087c4  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00001280  00000000  00000000  000095b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00001cb1  00000000  00000000  0000a838  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000340  00000000  00000000  0000c4e9  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 c5 02 	jmp	0x58a	; 0x58a <__vector_3>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 18 08 	jmp	0x1030	; 0x1030 <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 f3 03 	jmp	0x7e6	; 0x7e6 <__vector_18>
      4c:	0c 94 38 04 	jmp	0x870	; 0x870 <__vector_19>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e0 ea       	ldi	r30, 0xA0	; 160
      7c:	f4 e3       	ldi	r31, 0x34	; 52
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	a0 3a       	cpi	r26, 0xA0	; 160
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	28 e0       	ldi	r18, 0x08	; 8
      8c:	a0 ea       	ldi	r26, 0xA0	; 160
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a0 3b       	cpi	r26, 0xB0	; 176
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 89 04 	call	0x912	; 0x912 <main>
      9e:	0c 94 4e 1a 	jmp	0x349c	; 0x349c <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <motor_setup>:
TickType_t clkElapsed;
float rate = ((MOTOR_POWER_BASE-MOTOR_MIN_POWER)/MOTOR_TIME_DELTA);
SemaphoreHandle_t motor_semaphore;
	
// Initialization function
void motor_setup(void) {
      a6:	cf 93       	push	r28
      a8:	df 93       	push	r29
      aa:	cd b7       	in	r28, 0x3d	; 61
      ac:	de b7       	in	r29, 0x3e	; 62
	PORTC = mtrCW_Rotate[7];
      ae:	88 e2       	ldi	r24, 0x28	; 40
      b0:	90 e0       	ldi	r25, 0x00	; 0
      b2:	20 91 07 01 	lds	r18, 0x0107
      b6:	fc 01       	movw	r30, r24
      b8:	20 83       	st	Z, r18
	// Check for the First HALL effect sensor state
	getPhaseCode();
      ba:	0e 94 b7 02 	call	0x56e	; 0x56e <getPhaseCode>
	
	// Create the Binary semaphore
	motor_semaphore = xSemaphoreCreateBinary();
      be:	43 e0       	ldi	r20, 0x03	; 3
      c0:	60 e0       	ldi	r22, 0x00	; 0
      c2:	81 e0       	ldi	r24, 0x01	; 1
      c4:	0e 94 11 0a 	call	0x1422	; 0x1422 <xQueueGenericCreate>
      c8:	90 93 7c 08 	sts	0x087C, r25
      cc:	80 93 7b 08 	sts	0x087B, r24
	vQueueAddToRegistry(motor_semaphore, "Motor Semaphore");
      d0:	80 91 7b 08 	lds	r24, 0x087B
      d4:	90 91 7c 08 	lds	r25, 0x087C
      d8:	62 e6       	ldi	r22, 0x62	; 98
      da:	71 e0       	ldi	r23, 0x01	; 1
      dc:	0e 94 73 0e 	call	0x1ce6	; 0x1ce6 <vQueueAddToRegistry>
	
	// Reset the elapsed time (in thousands of a second)
	clkElapsed = 0x0000;	
      e0:	10 92 7a 08 	sts	0x087A, r1
      e4:	10 92 79 08 	sts	0x0879, r1
	
	// Set the necessary features to make the motor run
	// Set the corresponding Fast PWM Pin
	// Enable the Port as an output
	DDRD |= (1 << PORTD3);
      e8:	8a e2       	ldi	r24, 0x2A	; 42
      ea:	90 e0       	ldi	r25, 0x00	; 0
      ec:	2a e2       	ldi	r18, 0x2A	; 42
      ee:	30 e0       	ldi	r19, 0x00	; 0
      f0:	f9 01       	movw	r30, r18
      f2:	20 81       	ld	r18, Z
      f4:	28 60       	ori	r18, 0x08	; 8
      f6:	fc 01       	movw	r30, r24
      f8:	20 83       	st	Z, r18
	
	// TIMER STUFF
	// Set the FAST PWM as non-inverting
	TCCR2A = (1 << COM2B1) | (1 << WGM21) | (1 << WGM20);
      fa:	80 eb       	ldi	r24, 0xB0	; 176
      fc:	90 e0       	ldi	r25, 0x00	; 0
      fe:	23 e2       	ldi	r18, 0x23	; 35
     100:	fc 01       	movw	r30, r24
     102:	20 83       	st	Z, r18
	// Set the Pre-Scaler
	TCCR2B = (1 << CS21);
     104:	81 eb       	ldi	r24, 0xB1	; 177
     106:	90 e0       	ldi	r25, 0x00	; 0
     108:	22 e0       	ldi	r18, 0x02	; 2
     10a:	fc 01       	movw	r30, r24
     10c:	20 83       	st	Z, r18
	
	OCR2B = MOTOR_POWER_BASE; // Duty Cycle - Initialize to the very lowest base speed
     10e:	84 eb       	ldi	r24, 0xB4	; 180
     110:	90 e0       	ldi	r25, 0x00	; 0
     112:	2f ef       	ldi	r18, 0xFF	; 255
     114:	fc 01       	movw	r30, r24
     116:	20 83       	st	Z, r18
	
	// Set the necessary PCINT settings for PB0-2
	PCICR |= (1 << PCIE0);    // set PCIE0 to enable PCMSK0 scan
     118:	88 e6       	ldi	r24, 0x68	; 104
     11a:	90 e0       	ldi	r25, 0x00	; 0
     11c:	28 e6       	ldi	r18, 0x68	; 104
     11e:	30 e0       	ldi	r19, 0x00	; 0
     120:	f9 01       	movw	r30, r18
     122:	20 81       	ld	r18, Z
     124:	21 60       	ori	r18, 0x01	; 1
     126:	fc 01       	movw	r30, r24
     128:	20 83       	st	Z, r18
	PCMSK0 |= 0b00000111;  // set PCINT0 to trigger an interrupt on state change
     12a:	8b e6       	ldi	r24, 0x6B	; 107
     12c:	90 e0       	ldi	r25, 0x00	; 0
     12e:	2b e6       	ldi	r18, 0x6B	; 107
     130:	30 e0       	ldi	r19, 0x00	; 0
     132:	f9 01       	movw	r30, r18
     134:	20 81       	ld	r18, Z
     136:	27 60       	ori	r18, 0x07	; 7
     138:	fc 01       	movw	r30, r24
     13a:	20 83       	st	Z, r18
}
     13c:	df 91       	pop	r29
     13e:	cf 91       	pop	r28
     140:	08 95       	ret

00000142 <vStartMotorTask>:

//////////////////////////////////////////////////////////////////////////
// MOTOR Drive Functions
// 
//////////////////////////////////////////////////////////////////////////
void vStartMotorTask( UBaseType_t uxPriority) {	
     142:	af 92       	push	r10
     144:	bf 92       	push	r11
     146:	cf 92       	push	r12
     148:	df 92       	push	r13
     14a:	ef 92       	push	r14
     14c:	ff 92       	push	r15
     14e:	0f 93       	push	r16
     150:	cf 93       	push	r28
     152:	df 93       	push	r29
     154:	1f 92       	push	r1
     156:	cd b7       	in	r28, 0x3d	; 61
     158:	de b7       	in	r29, 0x3e	; 62
     15a:	89 83       	std	Y+1, r24	; 0x01
	// Start the Motor Function
	xTaskCreate( vMotorDriveTask, "M", configMINIMAL_STACK_SIZE*2, NULL, uxPriority+1, NULL );
     15c:	89 81       	ldd	r24, Y+1	; 0x01
     15e:	8f 5f       	subi	r24, 0xFF	; 255
     160:	a1 2c       	mov	r10, r1
     162:	b1 2c       	mov	r11, r1
     164:	c1 2c       	mov	r12, r1
     166:	d1 2c       	mov	r13, r1
     168:	e1 2c       	mov	r14, r1
     16a:	f1 2c       	mov	r15, r1
     16c:	08 2f       	mov	r16, r24
     16e:	20 e0       	ldi	r18, 0x00	; 0
     170:	30 e0       	ldi	r19, 0x00	; 0
     172:	4a ea       	ldi	r20, 0xAA	; 170
     174:	50 e0       	ldi	r21, 0x00	; 0
     176:	62 e7       	ldi	r22, 0x72	; 114
     178:	71 e0       	ldi	r23, 0x01	; 1
     17a:	81 ee       	ldi	r24, 0xE1	; 225
     17c:	90 e0       	ldi	r25, 0x00	; 0
     17e:	0e 94 b9 0e 	call	0x1d72	; 0x1d72 <xTaskGenericCreate>
	xTaskCreate( vMotorRampTask, "R", configMINIMAL_STACK_SIZE*2, NULL, uxPriority, &VMOtorRamp_Handle );
     182:	a1 2c       	mov	r10, r1
     184:	b1 2c       	mov	r11, r1
     186:	c1 2c       	mov	r12, r1
     188:	d1 2c       	mov	r13, r1
     18a:	0f 2e       	mov	r0, r31
     18c:	f7 e7       	ldi	r31, 0x77	; 119
     18e:	ef 2e       	mov	r14, r31
     190:	f8 e0       	ldi	r31, 0x08	; 8
     192:	ff 2e       	mov	r15, r31
     194:	f0 2d       	mov	r31, r0
     196:	09 81       	ldd	r16, Y+1	; 0x01
     198:	20 e0       	ldi	r18, 0x00	; 0
     19a:	30 e0       	ldi	r19, 0x00	; 0
     19c:	4a ea       	ldi	r20, 0xAA	; 170
     19e:	50 e0       	ldi	r21, 0x00	; 0
     1a0:	64 e7       	ldi	r22, 0x74	; 116
     1a2:	71 e0       	ldi	r23, 0x01	; 1
     1a4:	87 e4       	ldi	r24, 0x47	; 71
     1a6:	91 e0       	ldi	r25, 0x01	; 1
     1a8:	0e 94 b9 0e 	call	0x1d72	; 0x1d72 <xTaskGenericCreate>
}
     1ac:	0f 90       	pop	r0
     1ae:	df 91       	pop	r29
     1b0:	cf 91       	pop	r28
     1b2:	0f 91       	pop	r16
     1b4:	ff 90       	pop	r15
     1b6:	ef 90       	pop	r14
     1b8:	df 90       	pop	r13
     1ba:	cf 90       	pop	r12
     1bc:	bf 90       	pop	r11
     1be:	af 90       	pop	r10
     1c0:	08 95       	ret

000001c2 <vMotorDriveTask>:

static portTASK_FUNCTION( vMotorDriveTask, pvParameters )
{
     1c2:	cf 93       	push	r28
     1c4:	df 93       	push	r29
     1c6:	00 d0       	rcall	.+0      	; 0x1c8 <vMotorDriveTask+0x6>
     1c8:	1f 92       	push	r1
     1ca:	cd b7       	in	r28, 0x3d	; 61
     1cc:	de b7       	in	r29, 0x3e	; 62
     1ce:	9b 83       	std	Y+3, r25	; 0x03
     1d0:	8a 83       	std	Y+2, r24	; 0x02
	
	// Start into the infinite loop right away
	for (;;)
	{
		// Yield through its dedicated semaphore
		if (xSemaphoreTake(motor_semaphore, portMAX_DELAY))
     1d2:	80 91 7b 08 	lds	r24, 0x087B
     1d6:	90 91 7c 08 	lds	r25, 0x087C
     1da:	20 e0       	ldi	r18, 0x00	; 0
     1dc:	4f ef       	ldi	r20, 0xFF	; 255
     1de:	5f ef       	ldi	r21, 0xFF	; 255
     1e0:	60 e0       	ldi	r22, 0x00	; 0
     1e2:	70 e0       	ldi	r23, 0x00	; 0
     1e4:	0e 94 8f 0b 	call	0x171e	; 0x171e <xQueueGenericReceive>
     1e8:	88 23       	and	r24, r24
     1ea:	09 f4       	brne	.+2      	; 0x1ee <vMotorDriveTask+0x2c>
     1ec:	4f c0       	rjmp	.+158    	; 0x28c <vMotorDriveTask+0xca>
		{
			cInputs = PIND & 0b10100000; // Get the Over-Current Flag
     1ee:	89 e2       	ldi	r24, 0x29	; 41
     1f0:	90 e0       	ldi	r25, 0x00	; 0
     1f2:	fc 01       	movw	r30, r24
     1f4:	80 81       	ld	r24, Z
     1f6:	80 7a       	andi	r24, 0xA0	; 160
     1f8:	89 83       	std	Y+1, r24	; 0x01
			if ((txMode == 'R' || txMode == 'r' || txMode == 's') && (cInputs & 0b00100000))
     1fa:	80 91 0f 01 	lds	r24, 0x010F
     1fe:	82 35       	cpi	r24, 0x52	; 82
     200:	41 f0       	breq	.+16     	; 0x212 <vMotorDriveTask+0x50>
     202:	80 91 0f 01 	lds	r24, 0x010F
     206:	82 37       	cpi	r24, 0x72	; 114
     208:	21 f0       	breq	.+8      	; 0x212 <vMotorDriveTask+0x50>
     20a:	80 91 0f 01 	lds	r24, 0x010F
     20e:	83 37       	cpi	r24, 0x73	; 115
     210:	c1 f4       	brne	.+48     	; 0x242 <vMotorDriveTask+0x80>
     212:	89 81       	ldd	r24, Y+1	; 0x01
     214:	88 2f       	mov	r24, r24
     216:	90 e0       	ldi	r25, 0x00	; 0
     218:	80 72       	andi	r24, 0x20	; 32
     21a:	99 27       	eor	r25, r25
     21c:	00 97       	sbiw	r24, 0x00	; 0
     21e:	89 f0       	breq	.+34     	; 0x242 <vMotorDriveTask+0x80>
			{	// And Check for Overpowering!! -------------------------^
				// The motor is about to run in this routine ( CW Direction Only )
				PORTC = mtrCW_Rotate[( PINB & 0b00000111 )];
     220:	88 e2       	ldi	r24, 0x28	; 40
     222:	90 e0       	ldi	r25, 0x00	; 0
     224:	23 e2       	ldi	r18, 0x23	; 35
     226:	30 e0       	ldi	r19, 0x00	; 0
     228:	f9 01       	movw	r30, r18
     22a:	20 81       	ld	r18, Z
     22c:	22 2f       	mov	r18, r18
     22e:	30 e0       	ldi	r19, 0x00	; 0
     230:	27 70       	andi	r18, 0x07	; 7
     232:	33 27       	eor	r19, r19
     234:	20 50       	subi	r18, 0x00	; 0
     236:	3f 4f       	sbci	r19, 0xFF	; 255
     238:	f9 01       	movw	r30, r18
     23a:	20 81       	ld	r18, Z
     23c:	fc 01       	movw	r30, r24
     23e:	20 83       	st	Z, r18
     240:	25 c0       	rjmp	.+74     	; 0x28c <vMotorDriveTask+0xca>
				} else if ( txMode == 'N' ) {	// If (In any case) the Motor State is N, Clamp down and set base PWM
     242:	80 91 0f 01 	lds	r24, 0x010F
     246:	8e 34       	cpi	r24, 0x4E	; 78
     248:	61 f4       	brne	.+24     	; 0x262 <vMotorDriveTask+0xa0>
				PORTC = mtrCW_Rotate[7];
     24a:	88 e2       	ldi	r24, 0x28	; 40
     24c:	90 e0       	ldi	r25, 0x00	; 0
     24e:	20 91 07 01 	lds	r18, 0x0107
     252:	fc 01       	movw	r30, r24
     254:	20 83       	st	Z, r18
				OCR2B = MOTOR_POWER_BASE;
     256:	84 eb       	ldi	r24, 0xB4	; 180
     258:	90 e0       	ldi	r25, 0x00	; 0
     25a:	2f ef       	ldi	r18, 0xFF	; 255
     25c:	fc 01       	movw	r30, r24
     25e:	20 83       	st	Z, r18
     260:	15 c0       	rjmp	.+42     	; 0x28c <vMotorDriveTask+0xca>
				} else {	// OVERPOWERING SCENARIO
				PORTC = mtrCW_Rotate[7];	// CLAMP ASAP!!
     262:	88 e2       	ldi	r24, 0x28	; 40
     264:	90 e0       	ldi	r25, 0x00	; 0
     266:	20 91 07 01 	lds	r18, 0x0107
     26a:	fc 01       	movw	r30, r24
     26c:	20 83       	st	Z, r18
				OCR2B = MOTOR_POWER_BASE;	// Reset to Base Power
     26e:	84 eb       	ldi	r24, 0xB4	; 180
     270:	90 e0       	ldi	r25, 0x00	; 0
     272:	2f ef       	ldi	r18, 0xFF	; 255
     274:	fc 01       	movw	r30, r24
     276:	20 83       	st	Z, r18
				ledTaskRate = LED_TASK_RATE_ERROR;	// Clamp and throw error light
     278:	83 e3       	ldi	r24, 0x33	; 51
     27a:	91 e0       	ldi	r25, 0x01	; 1
     27c:	90 93 a8 08 	sts	0x08A8, r25
     280:	80 93 a7 08 	sts	0x08A7, r24
				txMode = 'N'; // Clamped state
     284:	8e e4       	ldi	r24, 0x4E	; 78
     286:	80 93 0f 01 	sts	0x010F, r24
			}
		}	
	}
     28a:	a3 cf       	rjmp	.-186    	; 0x1d2 <vMotorDriveTask+0x10>
     28c:	a2 cf       	rjmp	.-188    	; 0x1d2 <vMotorDriveTask+0x10>

0000028e <vMotorRampTask>:
}

//////////////////////////////////////////////////////////////////////////
// Motor Ramping Task
static portTASK_FUNCTION( vMotorRampTask, pvParameters ) {
     28e:	0f 93       	push	r16
     290:	1f 93       	push	r17
     292:	cf 93       	push	r28
     294:	df 93       	push	r29
     296:	00 d0       	rcall	.+0      	; 0x298 <vMotorRampTask+0xa>
     298:	00 d0       	rcall	.+0      	; 0x29a <vMotorRampTask+0xc>
     29a:	00 d0       	rcall	.+0      	; 0x29c <vMotorRampTask+0xe>
     29c:	cd b7       	in	r28, 0x3d	; 61
     29e:	de b7       	in	r29, 0x3e	; 62
     2a0:	9e 83       	std	Y+6, r25	; 0x06
     2a2:	8d 83       	std	Y+5, r24	; 0x05
	// Initialize the last time this task was woken
	TickType_t rampLastTick;
	const TickType_t xFrequency = 1;	// Ramp Algorithm Frequency when Ramping
     2a4:	81 e0       	ldi	r24, 0x01	; 1
     2a6:	90 e0       	ldi	r25, 0x00	; 0
     2a8:	9a 83       	std	Y+2, r25	; 0x02
     2aa:	89 83       	std	Y+1, r24	; 0x01
	
	// ########## Suspend SELF
	vTaskSuspend( NULL );
     2ac:	80 e0       	ldi	r24, 0x00	; 0
     2ae:	90 e0       	ldi	r25, 0x00	; 0
     2b0:	0e 94 4d 10 	call	0x209a	; 0x209a <vTaskSuspend>
	
	rampLastTick = xTaskGetTickCount();	// Record the last wake time
     2b4:	0e 94 1e 12 	call	0x243c	; 0x243c <xTaskGetTickCount>
     2b8:	9c 83       	std	Y+4, r25	; 0x04
     2ba:	8b 83       	std	Y+3, r24	; 0x03
	
	for (;;)	// Loop this task FOREVER
	{
		if ( txMode == 'r' ) // This code does the ramp up
     2bc:	80 91 0f 01 	lds	r24, 0x010F
     2c0:	82 37       	cpi	r24, 0x72	; 114
     2c2:	09 f0       	breq	.+2      	; 0x2c6 <vMotorRampTask+0x38>
     2c4:	f6 c0       	rjmp	.+492    	; 0x4b2 <vMotorRampTask+0x224>
		{
			// Limit the giving of the semaphore to the first entry
			if (((OCR2B > motPower) && (OCR2B > MOTOR_MAX_POWER)) && OCR2B == MOTOR_POWER_BASE ) { 
     2c6:	84 eb       	ldi	r24, 0xB4	; 180
     2c8:	90 e0       	ldi	r25, 0x00	; 0
     2ca:	fc 01       	movw	r30, r24
     2cc:	90 81       	ld	r25, Z
     2ce:	80 91 a0 01 	lds	r24, 0x01A0
     2d2:	89 17       	cp	r24, r25
     2d4:	08 f0       	brcs	.+2      	; 0x2d8 <vMotorRampTask+0x4a>
     2d6:	77 c0       	rjmp	.+238    	; 0x3c6 <vMotorRampTask+0x138>
     2d8:	84 eb       	ldi	r24, 0xB4	; 180
     2da:	90 e0       	ldi	r25, 0x00	; 0
     2dc:	fc 01       	movw	r30, r24
     2de:	80 81       	ld	r24, Z
     2e0:	88 2f       	mov	r24, r24
     2e2:	90 e0       	ldi	r25, 0x00	; 0
     2e4:	aa 27       	eor	r26, r26
     2e6:	97 fd       	sbrc	r25, 7
     2e8:	a0 95       	com	r26
     2ea:	ba 2f       	mov	r27, r26
     2ec:	bc 01       	movw	r22, r24
     2ee:	cd 01       	movw	r24, r26
     2f0:	0e 94 05 19 	call	0x320a	; 0x320a <__floatsisf>
     2f4:	dc 01       	movw	r26, r24
     2f6:	cb 01       	movw	r24, r22
     2f8:	20 e0       	ldi	r18, 0x00	; 0
     2fa:	30 e0       	ldi	r19, 0x00	; 0
     2fc:	a9 01       	movw	r20, r18
     2fe:	bc 01       	movw	r22, r24
     300:	cd 01       	movw	r24, r26
     302:	0e 94 b5 19 	call	0x336a	; 0x336a <__gesf2>
     306:	18 16       	cp	r1, r24
     308:	0c f0       	brlt	.+2      	; 0x30c <vMotorRampTask+0x7e>
     30a:	5d c0       	rjmp	.+186    	; 0x3c6 <vMotorRampTask+0x138>
     30c:	84 eb       	ldi	r24, 0xB4	; 180
     30e:	90 e0       	ldi	r25, 0x00	; 0
     310:	fc 01       	movw	r30, r24
     312:	80 81       	ld	r24, Z
     314:	88 2f       	mov	r24, r24
     316:	90 e0       	ldi	r25, 0x00	; 0
     318:	aa 27       	eor	r26, r26
     31a:	97 fd       	sbrc	r25, 7
     31c:	a0 95       	com	r26
     31e:	ba 2f       	mov	r27, r26
     320:	bc 01       	movw	r22, r24
     322:	cd 01       	movw	r24, r26
     324:	0e 94 05 19 	call	0x320a	; 0x320a <__floatsisf>
     328:	dc 01       	movw	r26, r24
     32a:	cb 01       	movw	r24, r22
     32c:	20 e0       	ldi	r18, 0x00	; 0
     32e:	30 e0       	ldi	r19, 0x00	; 0
     330:	4f e7       	ldi	r20, 0x7F	; 127
     332:	53 e4       	ldi	r21, 0x43	; 67
     334:	bc 01       	movw	r22, r24
     336:	cd 01       	movw	r24, r26
     338:	0e 94 d3 18 	call	0x31a6	; 0x31a6 <__cmpsf2>
     33c:	88 23       	and	r24, r24
     33e:	09 f0       	breq	.+2      	; 0x342 <vMotorRampTask+0xb4>
     340:	42 c0       	rjmp	.+132    	; 0x3c6 <vMotorRampTask+0x138>
				OCR2B = MOTOR_POWER_BASE - (clkElapsed * rate);
     342:	04 eb       	ldi	r16, 0xB4	; 180
     344:	10 e0       	ldi	r17, 0x00	; 0
     346:	80 91 79 08 	lds	r24, 0x0879
     34a:	90 91 7a 08 	lds	r25, 0x087A
     34e:	cc 01       	movw	r24, r24
     350:	a0 e0       	ldi	r26, 0x00	; 0
     352:	b0 e0       	ldi	r27, 0x00	; 0
     354:	bc 01       	movw	r22, r24
     356:	cd 01       	movw	r24, r26
     358:	0e 94 03 19 	call	0x3206	; 0x3206 <__floatunsisf>
     35c:	dc 01       	movw	r26, r24
     35e:	cb 01       	movw	r24, r22
     360:	20 91 09 01 	lds	r18, 0x0109
     364:	30 91 0a 01 	lds	r19, 0x010A
     368:	40 91 0b 01 	lds	r20, 0x010B
     36c:	50 91 0c 01 	lds	r21, 0x010C
     370:	bc 01       	movw	r22, r24
     372:	cd 01       	movw	r24, r26
     374:	0e 94 b9 19 	call	0x3372	; 0x3372 <__mulsf3>
     378:	dc 01       	movw	r26, r24
     37a:	cb 01       	movw	r24, r22
     37c:	9c 01       	movw	r18, r24
     37e:	ad 01       	movw	r20, r26
     380:	60 e0       	ldi	r22, 0x00	; 0
     382:	70 e0       	ldi	r23, 0x00	; 0
     384:	8f e7       	ldi	r24, 0x7F	; 127
     386:	93 e4       	ldi	r25, 0x43	; 67
     388:	0e 94 6e 18 	call	0x30dc	; 0x30dc <__subsf3>
     38c:	dc 01       	movw	r26, r24
     38e:	cb 01       	movw	r24, r22
     390:	bc 01       	movw	r22, r24
     392:	cd 01       	movw	r24, r26
     394:	0e 94 d7 18 	call	0x31ae	; 0x31ae <__fixunssfsi>
     398:	dc 01       	movw	r26, r24
     39a:	cb 01       	movw	r24, r22
     39c:	f8 01       	movw	r30, r16
     39e:	80 83       	st	Z, r24
				xSemaphoreGive(motor_semaphore);	// Give the Semaphore
     3a0:	80 91 7b 08 	lds	r24, 0x087B
     3a4:	90 91 7c 08 	lds	r25, 0x087C
     3a8:	20 e0       	ldi	r18, 0x00	; 0
     3aa:	40 e0       	ldi	r20, 0x00	; 0
     3ac:	50 e0       	ldi	r21, 0x00	; 0
     3ae:	60 e0       	ldi	r22, 0x00	; 0
     3b0:	70 e0       	ldi	r23, 0x00	; 0
     3b2:	0e 94 72 0a 	call	0x14e4	; 0x14e4 <xQueueGenericSend>
				vTaskDelayUntil(&rampLastTick, xFrequency);	// vTaskDelayUntil to the next millisecond
     3b6:	29 81       	ldd	r18, Y+1	; 0x01
     3b8:	3a 81       	ldd	r19, Y+2	; 0x02
     3ba:	ce 01       	movw	r24, r28
     3bc:	03 96       	adiw	r24, 0x03	; 3
     3be:	b9 01       	movw	r22, r18
     3c0:	0e 94 9f 0f 	call	0x1f3e	; 0x1f3e <vTaskDelayUntil>
     3c4:	75 c0       	rjmp	.+234    	; 0x4b0 <vMotorRampTask+0x222>
			} else if ((OCR2B > motPower) && (OCR2B > MOTOR_MAX_POWER)) { // (clkElapsed < MOTOR_TIME_DELTA) &&
     3c6:	84 eb       	ldi	r24, 0xB4	; 180
     3c8:	90 e0       	ldi	r25, 0x00	; 0
     3ca:	fc 01       	movw	r30, r24
     3cc:	90 81       	ld	r25, Z
     3ce:	80 91 a0 01 	lds	r24, 0x01A0
     3d2:	89 17       	cp	r24, r25
     3d4:	08 f0       	brcs	.+2      	; 0x3d8 <vMotorRampTask+0x14a>
     3d6:	50 c0       	rjmp	.+160    	; 0x478 <vMotorRampTask+0x1ea>
     3d8:	84 eb       	ldi	r24, 0xB4	; 180
     3da:	90 e0       	ldi	r25, 0x00	; 0
     3dc:	fc 01       	movw	r30, r24
     3de:	80 81       	ld	r24, Z
     3e0:	88 2f       	mov	r24, r24
     3e2:	90 e0       	ldi	r25, 0x00	; 0
     3e4:	aa 27       	eor	r26, r26
     3e6:	97 fd       	sbrc	r25, 7
     3e8:	a0 95       	com	r26
     3ea:	ba 2f       	mov	r27, r26
     3ec:	bc 01       	movw	r22, r24
     3ee:	cd 01       	movw	r24, r26
     3f0:	0e 94 05 19 	call	0x320a	; 0x320a <__floatsisf>
     3f4:	dc 01       	movw	r26, r24
     3f6:	cb 01       	movw	r24, r22
     3f8:	20 e0       	ldi	r18, 0x00	; 0
     3fa:	30 e0       	ldi	r19, 0x00	; 0
     3fc:	a9 01       	movw	r20, r18
     3fe:	bc 01       	movw	r22, r24
     400:	cd 01       	movw	r24, r26
     402:	0e 94 b5 19 	call	0x336a	; 0x336a <__gesf2>
     406:	18 16       	cp	r1, r24
     408:	bc f5       	brge	.+110    	; 0x478 <vMotorRampTask+0x1ea>
				OCR2B = MOTOR_POWER_BASE - (clkElapsed * rate);
     40a:	04 eb       	ldi	r16, 0xB4	; 180
     40c:	10 e0       	ldi	r17, 0x00	; 0
     40e:	80 91 79 08 	lds	r24, 0x0879
     412:	90 91 7a 08 	lds	r25, 0x087A
     416:	cc 01       	movw	r24, r24
     418:	a0 e0       	ldi	r26, 0x00	; 0
     41a:	b0 e0       	ldi	r27, 0x00	; 0
     41c:	bc 01       	movw	r22, r24
     41e:	cd 01       	movw	r24, r26
     420:	0e 94 03 19 	call	0x3206	; 0x3206 <__floatunsisf>
     424:	dc 01       	movw	r26, r24
     426:	cb 01       	movw	r24, r22
     428:	20 91 09 01 	lds	r18, 0x0109
     42c:	30 91 0a 01 	lds	r19, 0x010A
     430:	40 91 0b 01 	lds	r20, 0x010B
     434:	50 91 0c 01 	lds	r21, 0x010C
     438:	bc 01       	movw	r22, r24
     43a:	cd 01       	movw	r24, r26
     43c:	0e 94 b9 19 	call	0x3372	; 0x3372 <__mulsf3>
     440:	dc 01       	movw	r26, r24
     442:	cb 01       	movw	r24, r22
     444:	9c 01       	movw	r18, r24
     446:	ad 01       	movw	r20, r26
     448:	60 e0       	ldi	r22, 0x00	; 0
     44a:	70 e0       	ldi	r23, 0x00	; 0
     44c:	8f e7       	ldi	r24, 0x7F	; 127
     44e:	93 e4       	ldi	r25, 0x43	; 67
     450:	0e 94 6e 18 	call	0x30dc	; 0x30dc <__subsf3>
     454:	dc 01       	movw	r26, r24
     456:	cb 01       	movw	r24, r22
     458:	bc 01       	movw	r22, r24
     45a:	cd 01       	movw	r24, r26
     45c:	0e 94 d7 18 	call	0x31ae	; 0x31ae <__fixunssfsi>
     460:	dc 01       	movw	r26, r24
     462:	cb 01       	movw	r24, r22
     464:	f8 01       	movw	r30, r16
     466:	80 83       	st	Z, r24
				vTaskDelayUntil(&rampLastTick, xFrequency);	// vTaskDelayUntil to the next millisecond
     468:	29 81       	ldd	r18, Y+1	; 0x01
     46a:	3a 81       	ldd	r19, Y+2	; 0x02
     46c:	ce 01       	movw	r24, r28
     46e:	03 96       	adiw	r24, 0x03	; 3
     470:	b9 01       	movw	r22, r18
     472:	0e 94 9f 0f 	call	0x1f3e	; 0x1f3e <vTaskDelayUntil>
     476:	1c c0       	rjmp	.+56     	; 0x4b0 <vMotorRampTask+0x222>
			} else if ( OCR2B < motPower ) {
     478:	84 eb       	ldi	r24, 0xB4	; 180
     47a:	90 e0       	ldi	r25, 0x00	; 0
     47c:	fc 01       	movw	r30, r24
     47e:	90 81       	ld	r25, Z
     480:	80 91 a0 01 	lds	r24, 0x01A0
     484:	98 17       	cp	r25, r24
     486:	40 f4       	brcc	.+16     	; 0x498 <vMotorRampTask+0x20a>
				txMode = 'R';
     488:	82 e5       	ldi	r24, 0x52	; 82
     48a:	80 93 0f 01 	sts	0x010F, r24
					// If the motor is already at set speed, suspend the task
				vTaskSuspend( NULL );	// Suspend Self
     48e:	80 e0       	ldi	r24, 0x00	; 0
     490:	90 e0       	ldi	r25, 0x00	; 0
     492:	0e 94 4d 10 	call	0x209a	; 0x209a <vTaskSuspend>
     496:	6a c0       	rjmp	.+212    	; 0x56c <vMotorRampTask+0x2de>
			} else if ( OCR2B < MOTOR_MAX_POWER ) {
     498:	84 eb       	ldi	r24, 0xB4	; 180
     49a:	90 e0       	ldi	r25, 0x00	; 0
     49c:	fc 01       	movw	r30, r24
     49e:	80 81       	ld	r24, Z
				txMode = 'R';
				// If the motor is already at set speed, suspend the task
				vTaskSuspend( NULL );	// Suspend Self
			} else {		// If the Ramp just simply timed out
				txMode = 'R';
     4a0:	82 e5       	ldi	r24, 0x52	; 82
     4a2:	80 93 0f 01 	sts	0x010F, r24
				// If the motor is already at set speed, suspend the task
				vTaskSuspend( NULL );	// Suspend Self
     4a6:	80 e0       	ldi	r24, 0x00	; 0
     4a8:	90 e0       	ldi	r25, 0x00	; 0
     4aa:	0e 94 4d 10 	call	0x209a	; 0x209a <vTaskSuspend>
     4ae:	5e c0       	rjmp	.+188    	; 0x56c <vMotorRampTask+0x2de>
     4b0:	5d c0       	rjmp	.+186    	; 0x56c <vMotorRampTask+0x2de>
			}
		} else if (txMode == 's') {	// If the motor is being stopped
     4b2:	80 91 0f 01 	lds	r24, 0x010F
     4b6:	83 37       	cpi	r24, 0x73	; 115
     4b8:	09 f0       	breq	.+2      	; 0x4bc <vMotorRampTask+0x22e>
     4ba:	58 c0       	rjmp	.+176    	; 0x56c <vMotorRampTask+0x2de>
			if (OCR2B >= MOTOR_POWER_BASE) {
     4bc:	84 eb       	ldi	r24, 0xB4	; 180
     4be:	90 e0       	ldi	r25, 0x00	; 0
     4c0:	fc 01       	movw	r30, r24
     4c2:	80 81       	ld	r24, Z
     4c4:	88 2f       	mov	r24, r24
     4c6:	90 e0       	ldi	r25, 0x00	; 0
     4c8:	aa 27       	eor	r26, r26
     4ca:	97 fd       	sbrc	r25, 7
     4cc:	a0 95       	com	r26
     4ce:	ba 2f       	mov	r27, r26
     4d0:	bc 01       	movw	r22, r24
     4d2:	cd 01       	movw	r24, r26
     4d4:	0e 94 05 19 	call	0x320a	; 0x320a <__floatsisf>
     4d8:	dc 01       	movw	r26, r24
     4da:	cb 01       	movw	r24, r22
     4dc:	20 e0       	ldi	r18, 0x00	; 0
     4de:	30 e0       	ldi	r19, 0x00	; 0
     4e0:	4f e7       	ldi	r20, 0x7F	; 127
     4e2:	53 e4       	ldi	r21, 0x43	; 67
     4e4:	bc 01       	movw	r22, r24
     4e6:	cd 01       	movw	r24, r26
     4e8:	0e 94 b5 19 	call	0x336a	; 0x336a <__gesf2>
     4ec:	88 23       	and	r24, r24
     4ee:	44 f0       	brlt	.+16     	; 0x500 <vMotorRampTask+0x272>
				txMode = 'N';
     4f0:	8e e4       	ldi	r24, 0x4E	; 78
     4f2:	80 93 0f 01 	sts	0x010F, r24
				vTaskSuspend( NULL );
     4f6:	80 e0       	ldi	r24, 0x00	; 0
     4f8:	90 e0       	ldi	r25, 0x00	; 0
     4fa:	0e 94 4d 10 	call	0x209a	; 0x209a <vTaskSuspend>
     4fe:	36 c0       	rjmp	.+108    	; 0x56c <vMotorRampTask+0x2de>
			} else {
				OCR2B = MOTOR_MIN_POWER + (clkElapsed * rate);
     500:	04 eb       	ldi	r16, 0xB4	; 180
     502:	10 e0       	ldi	r17, 0x00	; 0
     504:	80 91 79 08 	lds	r24, 0x0879
     508:	90 91 7a 08 	lds	r25, 0x087A
     50c:	cc 01       	movw	r24, r24
     50e:	a0 e0       	ldi	r26, 0x00	; 0
     510:	b0 e0       	ldi	r27, 0x00	; 0
     512:	bc 01       	movw	r22, r24
     514:	cd 01       	movw	r24, r26
     516:	0e 94 03 19 	call	0x3206	; 0x3206 <__floatunsisf>
     51a:	dc 01       	movw	r26, r24
     51c:	cb 01       	movw	r24, r22
     51e:	20 91 09 01 	lds	r18, 0x0109
     522:	30 91 0a 01 	lds	r19, 0x010A
     526:	40 91 0b 01 	lds	r20, 0x010B
     52a:	50 91 0c 01 	lds	r21, 0x010C
     52e:	bc 01       	movw	r22, r24
     530:	cd 01       	movw	r24, r26
     532:	0e 94 b9 19 	call	0x3372	; 0x3372 <__mulsf3>
     536:	dc 01       	movw	r26, r24
     538:	cb 01       	movw	r24, r22
     53a:	20 e0       	ldi	r18, 0x00	; 0
     53c:	30 e0       	ldi	r19, 0x00	; 0
     53e:	a9 01       	movw	r20, r18
     540:	bc 01       	movw	r22, r24
     542:	cd 01       	movw	r24, r26
     544:	0e 94 6f 18 	call	0x30de	; 0x30de <__addsf3>
     548:	dc 01       	movw	r26, r24
     54a:	cb 01       	movw	r24, r22
     54c:	bc 01       	movw	r22, r24
     54e:	cd 01       	movw	r24, r26
     550:	0e 94 d7 18 	call	0x31ae	; 0x31ae <__fixunssfsi>
     554:	dc 01       	movw	r26, r24
     556:	cb 01       	movw	r24, r22
     558:	f8 01       	movw	r30, r16
     55a:	80 83       	st	Z, r24
				vTaskDelayUntil(&rampLastTick, xFrequency);	// vTaskDelayUntil to the next millisecond
     55c:	29 81       	ldd	r18, Y+1	; 0x01
     55e:	3a 81       	ldd	r19, Y+2	; 0x02
     560:	ce 01       	movw	r24, r28
     562:	03 96       	adiw	r24, 0x03	; 3
     564:	b9 01       	movw	r22, r18
     566:	0e 94 9f 0f 	call	0x1f3e	; 0x1f3e <vTaskDelayUntil>
		//fnPrintWaterMark(OCR2B, exitMode);
		
		// %%%%%%%%%%% Debugging Purposes
		//ubtWM = uxTaskGetStackHighWaterMark(NULL);
		//fnPrintWaterMark(ubtWM,3);
	}
     56a:	a8 ce       	rjmp	.-688    	; 0x2bc <vMotorRampTask+0x2e>
     56c:	a7 ce       	rjmp	.-690    	; 0x2bc <vMotorRampTask+0x2e>

0000056e <getPhaseCode>:
}

// This function builds the code sent by the motor on the different pins
void getPhaseCode(void) {
     56e:	cf 93       	push	r28
     570:	df 93       	push	r29
     572:	cd b7       	in	r28, 0x3d	; 61
     574:	de b7       	in	r29, 0x3e	; 62
	intPhase = PINB & 0b00000111; // Clear the previous status
     576:	83 e2       	ldi	r24, 0x23	; 35
     578:	90 e0       	ldi	r25, 0x00	; 0
     57a:	fc 01       	movw	r30, r24
     57c:	80 81       	ld	r24, Z
     57e:	87 70       	andi	r24, 0x07	; 7
     580:	80 93 08 01 	sts	0x0108, r24
}
     584:	df 91       	pop	r29
     586:	cf 91       	pop	r28
     588:	08 95       	ret

0000058a <__vector_3>:

//////////////////////////////////////////////////////////////////////////
// ISR Functions
ISR (HALL_0_Vect) {
     58a:	1f 92       	push	r1
     58c:	0f 92       	push	r0
     58e:	00 90 5f 00 	lds	r0, 0x005F
     592:	0f 92       	push	r0
     594:	11 24       	eor	r1, r1
     596:	2f 93       	push	r18
     598:	3f 93       	push	r19
     59a:	4f 93       	push	r20
     59c:	5f 93       	push	r21
     59e:	6f 93       	push	r22
     5a0:	7f 93       	push	r23
     5a2:	8f 93       	push	r24
     5a4:	9f 93       	push	r25
     5a6:	af 93       	push	r26
     5a8:	bf 93       	push	r27
     5aa:	ef 93       	push	r30
     5ac:	ff 93       	push	r31
     5ae:	cf 93       	push	r28
     5b0:	df 93       	push	r29
     5b2:	00 d0       	rcall	.+0      	; 0x5b4 <__vector_3+0x2a>
     5b4:	cd b7       	in	r28, 0x3d	; 61
     5b6:	de b7       	in	r29, 0x3e	; 62
	// Define the woken task variable
	int motor_task_woken = 0;
     5b8:	1a 82       	std	Y+2, r1	; 0x02
     5ba:	19 82       	std	Y+1, r1	; 0x01
	
	// Skip if in the "N" State
	if ( txMode != "N" ) {
     5bc:	80 91 0f 01 	lds	r24, 0x010F
     5c0:	88 2f       	mov	r24, r24
     5c2:	90 e0       	ldi	r25, 0x00	; 0
     5c4:	21 e0       	ldi	r18, 0x01	; 1
     5c6:	86 37       	cpi	r24, 0x76	; 118
     5c8:	92 07       	cpc	r25, r18
     5ca:	91 f0       	breq	.+36     	; 0x5f0 <__vector_3+0x66>
		// Give the semaphore
		xSemaphoreGiveFromISR(motor_semaphore, &motor_task_woken);
     5cc:	80 91 7b 08 	lds	r24, 0x087B
     5d0:	90 91 7c 08 	lds	r25, 0x087C
     5d4:	20 e0       	ldi	r18, 0x00	; 0
     5d6:	ae 01       	movw	r20, r28
     5d8:	4f 5f       	subi	r20, 0xFF	; 255
     5da:	5f 4f       	sbci	r21, 0xFF	; 255
     5dc:	60 e0       	ldi	r22, 0x00	; 0
     5de:	70 e0       	ldi	r23, 0x00	; 0
     5e0:	0e 94 24 0b 	call	0x1648	; 0x1648 <xQueueGenericSendFromISR>
		
		// If the task was woken
		if (motor_task_woken) {
     5e4:	89 81       	ldd	r24, Y+1	; 0x01
     5e6:	9a 81       	ldd	r25, Y+2	; 0x02
     5e8:	00 97       	sbiw	r24, 0x00	; 0
     5ea:	11 f0       	breq	.+4      	; 0x5f0 <__vector_3+0x66>
			taskYIELD();
     5ec:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vPortYield>
		}
	}
}
     5f0:	0f 90       	pop	r0
     5f2:	0f 90       	pop	r0
     5f4:	df 91       	pop	r29
     5f6:	cf 91       	pop	r28
     5f8:	ff 91       	pop	r31
     5fa:	ef 91       	pop	r30
     5fc:	bf 91       	pop	r27
     5fe:	af 91       	pop	r26
     600:	9f 91       	pop	r25
     602:	8f 91       	pop	r24
     604:	7f 91       	pop	r23
     606:	6f 91       	pop	r22
     608:	5f 91       	pop	r21
     60a:	4f 91       	pop	r20
     60c:	3f 91       	pop	r19
     60e:	2f 91       	pop	r18
     610:	0f 90       	pop	r0
     612:	00 92 5f 00 	sts	0x005F, r0
     616:	0f 90       	pop	r0
     618:	1f 90       	pop	r1
     61a:	18 95       	reti

0000061c <xSerialPortInitMinimal>:
	UCSR0B = ucInByte;										\
}
/*-----------------------------------------------------------*/

xComPortHandle xSerialPortInitMinimal( unsigned long ulWantedBaud, unsigned portBASE_TYPE uxQueueLength )
{
     61c:	cf 93       	push	r28
     61e:	df 93       	push	r29
     620:	cd b7       	in	r28, 0x3d	; 61
     622:	de b7       	in	r29, 0x3e	; 62
     624:	2e 97       	sbiw	r28, 0x0e	; 14
     626:	0f b6       	in	r0, 0x3f	; 63
     628:	f8 94       	cli
     62a:	de bf       	out	0x3e, r29	; 62
     62c:	0f be       	out	0x3f, r0	; 63
     62e:	cd bf       	out	0x3d, r28	; 61
     630:	6e 83       	std	Y+6, r22	; 0x06
     632:	7f 83       	std	Y+7, r23	; 0x07
     634:	88 87       	std	Y+8, r24	; 0x08
     636:	99 87       	std	Y+9, r25	; 0x09
     638:	4a 87       	std	Y+10, r20	; 0x0a
unsigned long ulBaudRateCounter;
unsigned char ucByte;

	portENTER_CRITICAL();
     63a:	0f b6       	in	r0, 0x3f	; 63
     63c:	f8 94       	cli
     63e:	0f 92       	push	r0
	{
		/* Create the queues used by the com test task. */
		xRxedChars = xQueueCreate( uxQueueLength, sizeof( char ) );
     640:	40 e0       	ldi	r20, 0x00	; 0
     642:	61 e0       	ldi	r22, 0x01	; 1
     644:	8a 85       	ldd	r24, Y+10	; 0x0a
     646:	0e 94 11 0a 	call	0x1422	; 0x1422 <xQueueGenericCreate>
     64a:	90 93 a2 01 	sts	0x01A2, r25
     64e:	80 93 a1 01 	sts	0x01A1, r24
		xCharsForTx = xQueueCreate( uxQueueLength, sizeof( char ) );
     652:	40 e0       	ldi	r20, 0x00	; 0
     654:	61 e0       	ldi	r22, 0x01	; 1
     656:	8a 85       	ldd	r24, Y+10	; 0x0a
     658:	0e 94 11 0a 	call	0x1422	; 0x1422 <xQueueGenericCreate>
     65c:	90 93 a4 01 	sts	0x01A4, r25
     660:	80 93 a3 01 	sts	0x01A3, r24
		
		vQueueAddToRegistry(xRxedChars, "Rx Char Queue");
     664:	80 91 a1 01 	lds	r24, 0x01A1
     668:	90 91 a2 01 	lds	r25, 0x01A2
     66c:	68 e7       	ldi	r22, 0x78	; 120
     66e:	71 e0       	ldi	r23, 0x01	; 1
     670:	0e 94 73 0e 	call	0x1ce6	; 0x1ce6 <vQueueAddToRegistry>
		vQueueAddToRegistry(xCharsForTx, "Tx Char Queue");
     674:	80 91 a3 01 	lds	r24, 0x01A3
     678:	90 91 a4 01 	lds	r25, 0x01A4
     67c:	66 e8       	ldi	r22, 0x86	; 134
     67e:	71 e0       	ldi	r23, 0x01	; 1
     680:	0e 94 73 0e 	call	0x1ce6	; 0x1ce6 <vQueueAddToRegistry>

		/* Calculate the baud rate register value from the equation in the
		data sheet. */
		ulBaudRateCounter = ( configCPU_CLOCK_HZ / ( serBAUD_DIV_CONSTANT * ulWantedBaud ) ) - ( unsigned long ) 1;
     684:	8e 81       	ldd	r24, Y+6	; 0x06
     686:	9f 81       	ldd	r25, Y+7	; 0x07
     688:	a8 85       	ldd	r26, Y+8	; 0x08
     68a:	b9 85       	ldd	r27, Y+9	; 0x09
     68c:	88 0f       	add	r24, r24
     68e:	99 1f       	adc	r25, r25
     690:	aa 1f       	adc	r26, r26
     692:	bb 1f       	adc	r27, r27
     694:	88 0f       	add	r24, r24
     696:	99 1f       	adc	r25, r25
     698:	aa 1f       	adc	r26, r26
     69a:	bb 1f       	adc	r27, r27
     69c:	88 0f       	add	r24, r24
     69e:	99 1f       	adc	r25, r25
     6a0:	aa 1f       	adc	r26, r26
     6a2:	bb 1f       	adc	r27, r27
     6a4:	88 0f       	add	r24, r24
     6a6:	99 1f       	adc	r25, r25
     6a8:	aa 1f       	adc	r26, r26
     6aa:	bb 1f       	adc	r27, r27
     6ac:	9c 01       	movw	r18, r24
     6ae:	ad 01       	movw	r20, r26
     6b0:	80 e0       	ldi	r24, 0x00	; 0
     6b2:	94 e2       	ldi	r25, 0x24	; 36
     6b4:	a4 ef       	ldi	r26, 0xF4	; 244
     6b6:	b0 e0       	ldi	r27, 0x00	; 0
     6b8:	bc 01       	movw	r22, r24
     6ba:	cd 01       	movw	r24, r26
     6bc:	0e 94 1c 1a 	call	0x3438	; 0x3438 <__udivmodsi4>
     6c0:	da 01       	movw	r26, r20
     6c2:	c9 01       	movw	r24, r18
     6c4:	01 97       	sbiw	r24, 0x01	; 1
     6c6:	a1 09       	sbc	r26, r1
     6c8:	b1 09       	sbc	r27, r1
     6ca:	89 83       	std	Y+1, r24	; 0x01
     6cc:	9a 83       	std	Y+2, r25	; 0x02
     6ce:	ab 83       	std	Y+3, r26	; 0x03
     6d0:	bc 83       	std	Y+4, r27	; 0x04

		/* Set the baud rate. */	
		ucByte = ( unsigned char ) ( ulBaudRateCounter & ( unsigned long ) 0xff );	
     6d2:	89 81       	ldd	r24, Y+1	; 0x01
     6d4:	8d 83       	std	Y+5, r24	; 0x05
		UBRR0L = ucByte;
     6d6:	84 ec       	ldi	r24, 0xC4	; 196
     6d8:	90 e0       	ldi	r25, 0x00	; 0
     6da:	2d 81       	ldd	r18, Y+5	; 0x05
     6dc:	fc 01       	movw	r30, r24
     6de:	20 83       	st	Z, r18

		ulBaudRateCounter >>= ( unsigned long ) 8;
     6e0:	89 81       	ldd	r24, Y+1	; 0x01
     6e2:	9a 81       	ldd	r25, Y+2	; 0x02
     6e4:	ab 81       	ldd	r26, Y+3	; 0x03
     6e6:	bc 81       	ldd	r27, Y+4	; 0x04
     6e8:	89 2f       	mov	r24, r25
     6ea:	9a 2f       	mov	r25, r26
     6ec:	ab 2f       	mov	r26, r27
     6ee:	bb 27       	eor	r27, r27
     6f0:	89 83       	std	Y+1, r24	; 0x01
     6f2:	9a 83       	std	Y+2, r25	; 0x02
     6f4:	ab 83       	std	Y+3, r26	; 0x03
     6f6:	bc 83       	std	Y+4, r27	; 0x04
		ucByte = ( unsigned char ) ( ulBaudRateCounter & ( unsigned long ) 0xff );	
     6f8:	89 81       	ldd	r24, Y+1	; 0x01
     6fa:	8d 83       	std	Y+5, r24	; 0x05
		UBRR0H = ucByte;
     6fc:	85 ec       	ldi	r24, 0xC5	; 197
     6fe:	90 e0       	ldi	r25, 0x00	; 0
     700:	2d 81       	ldd	r18, Y+5	; 0x05
     702:	fc 01       	movw	r30, r24
     704:	20 83       	st	Z, r18
		later. Also enable the Rx and Tx. */
		//UCSR0B = ( serRX_INT_ENABLE | serRX_ENABLE | serTX_ENABLE );

		/* Set the data bits to 8. */
		//UCSR0C = ( serUCSRC_SELECT | serEIGHT_DATA_BITS );
		UCSR0C = _BV(UCSZ01) | _BV(UCSZ00);	// 8-bit data -- 1-Stop Bit automatically set
     706:	82 ec       	ldi	r24, 0xC2	; 194
     708:	90 e0       	ldi	r25, 0x00	; 0
     70a:	26 e0       	ldi	r18, 0x06	; 6
     70c:	fc 01       	movw	r30, r24
     70e:	20 83       	st	Z, r18
		UCSR0B = _BV(TXEN0) | _BV(RXCIE0) | _BV(RXEN0);	// Enable TX
     710:	81 ec       	ldi	r24, 0xC1	; 193
     712:	90 e0       	ldi	r25, 0x00	; 0
     714:	28 e9       	ldi	r18, 0x98	; 152
     716:	fc 01       	movw	r30, r24
     718:	20 83       	st	Z, r18
	}
	portEXIT_CRITICAL();
     71a:	0f 90       	pop	r0
     71c:	0f be       	out	0x3f, r0	; 63
	
	/* Unlike other ports, this serial code does not allow for more than one
	com port.  We therefore don't return a pointer to a port structure and can
	instead just return NULL. */
	return NULL;
     71e:	80 e0       	ldi	r24, 0x00	; 0
     720:	90 e0       	ldi	r25, 0x00	; 0
}
     722:	2e 96       	adiw	r28, 0x0e	; 14
     724:	0f b6       	in	r0, 0x3f	; 63
     726:	f8 94       	cli
     728:	de bf       	out	0x3e, r29	; 62
     72a:	0f be       	out	0x3f, r0	; 63
     72c:	cd bf       	out	0x3d, r28	; 61
     72e:	df 91       	pop	r29
     730:	cf 91       	pop	r28
     732:	08 95       	ret

00000734 <xSerialGetChar>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xSerialGetChar( xComPortHandle pxPort, signed char *pcRxedChar, TickType_t xBlockTime )
{
     734:	cf 93       	push	r28
     736:	df 93       	push	r29
     738:	00 d0       	rcall	.+0      	; 0x73a <xSerialGetChar+0x6>
     73a:	00 d0       	rcall	.+0      	; 0x73c <xSerialGetChar+0x8>
     73c:	00 d0       	rcall	.+0      	; 0x73e <xSerialGetChar+0xa>
     73e:	cd b7       	in	r28, 0x3d	; 61
     740:	de b7       	in	r29, 0x3e	; 62
     742:	9a 83       	std	Y+2, r25	; 0x02
     744:	89 83       	std	Y+1, r24	; 0x01
     746:	7c 83       	std	Y+4, r23	; 0x04
     748:	6b 83       	std	Y+3, r22	; 0x03
     74a:	5e 83       	std	Y+6, r21	; 0x06
     74c:	4d 83       	std	Y+5, r20	; 0x05
	/* Only one port is supported. */
	( void ) pxPort;

	/* Get the next character from the buffer.  Return false if no characters
	are available, or arrive before xBlockTime expires. */
	if( xQueueReceive( xRxedChars, pcRxedChar, xBlockTime ) )
     74e:	80 91 a1 01 	lds	r24, 0x01A1
     752:	90 91 a2 01 	lds	r25, 0x01A2
     756:	4d 81       	ldd	r20, Y+5	; 0x05
     758:	5e 81       	ldd	r21, Y+6	; 0x06
     75a:	6b 81       	ldd	r22, Y+3	; 0x03
     75c:	7c 81       	ldd	r23, Y+4	; 0x04
     75e:	20 e0       	ldi	r18, 0x00	; 0
     760:	0e 94 8f 0b 	call	0x171e	; 0x171e <xQueueGenericReceive>
     764:	88 23       	and	r24, r24
     766:	11 f0       	breq	.+4      	; 0x76c <xSerialGetChar+0x38>
	{
		return pdTRUE;
     768:	81 e0       	ldi	r24, 0x01	; 1
     76a:	01 c0       	rjmp	.+2      	; 0x76e <xSerialGetChar+0x3a>
	}
	else
	{
		return pdFALSE;
     76c:	80 e0       	ldi	r24, 0x00	; 0
	}
}
     76e:	26 96       	adiw	r28, 0x06	; 6
     770:	0f b6       	in	r0, 0x3f	; 63
     772:	f8 94       	cli
     774:	de bf       	out	0x3e, r29	; 62
     776:	0f be       	out	0x3f, r0	; 63
     778:	cd bf       	out	0x3d, r28	; 61
     77a:	df 91       	pop	r29
     77c:	cf 91       	pop	r28
     77e:	08 95       	ret

00000780 <xSerialPutChar>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xSerialPutChar( xComPortHandle pxPort, signed char cOutChar, TickType_t xBlockTime )
{
     780:	cf 93       	push	r28
     782:	df 93       	push	r29
     784:	00 d0       	rcall	.+0      	; 0x786 <xSerialPutChar+0x6>
     786:	00 d0       	rcall	.+0      	; 0x788 <xSerialPutChar+0x8>
     788:	00 d0       	rcall	.+0      	; 0x78a <xSerialPutChar+0xa>
     78a:	cd b7       	in	r28, 0x3d	; 61
     78c:	de b7       	in	r29, 0x3e	; 62
     78e:	9b 83       	std	Y+3, r25	; 0x03
     790:	8a 83       	std	Y+2, r24	; 0x02
     792:	6c 83       	std	Y+4, r22	; 0x04
     794:	5e 83       	std	Y+6, r21	; 0x06
     796:	4d 83       	std	Y+5, r20	; 0x05
	/* Only one port is supported. */
	( void ) pxPort;

	//vParTestSetLED((portBASE_TYPE) 7, pdTRUE);
	/* Return false if after the block time there is no room on the Tx queue. */
	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) != pdPASS )
     798:	80 91 a3 01 	lds	r24, 0x01A3
     79c:	90 91 a4 01 	lds	r25, 0x01A4
     7a0:	4d 81       	ldd	r20, Y+5	; 0x05
     7a2:	5e 81       	ldd	r21, Y+6	; 0x06
     7a4:	be 01       	movw	r22, r28
     7a6:	6c 5f       	subi	r22, 0xFC	; 252
     7a8:	7f 4f       	sbci	r23, 0xFF	; 255
     7aa:	20 e0       	ldi	r18, 0x00	; 0
     7ac:	0e 94 72 0a 	call	0x14e4	; 0x14e4 <xQueueGenericSend>
     7b0:	81 30       	cpi	r24, 0x01	; 1
     7b2:	11 f0       	breq	.+4      	; 0x7b8 <xSerialPutChar+0x38>
	{
		//vParTestSetLED((portBASE_TYPE) 7, pdTRUE);
		return pdFAIL;
     7b4:	80 e0       	ldi	r24, 0x00	; 0
     7b6:	0e c0       	rjmp	.+28     	; 0x7d4 <xSerialPutChar+0x54>
	}
	
	//vParTestSetLED((portBASE_TYPE) 7, pdTRUE);
	vInterruptOn();
     7b8:	81 ec       	ldi	r24, 0xC1	; 193
     7ba:	90 e0       	ldi	r25, 0x00	; 0
     7bc:	fc 01       	movw	r30, r24
     7be:	80 81       	ld	r24, Z
     7c0:	89 83       	std	Y+1, r24	; 0x01
     7c2:	89 81       	ldd	r24, Y+1	; 0x01
     7c4:	80 62       	ori	r24, 0x20	; 32
     7c6:	89 83       	std	Y+1, r24	; 0x01
     7c8:	81 ec       	ldi	r24, 0xC1	; 193
     7ca:	90 e0       	ldi	r25, 0x00	; 0
     7cc:	29 81       	ldd	r18, Y+1	; 0x01
     7ce:	fc 01       	movw	r30, r24
     7d0:	20 83       	st	Z, r18
	

	return pdPASS;
     7d2:	81 e0       	ldi	r24, 0x01	; 1
}
     7d4:	26 96       	adiw	r28, 0x06	; 6
     7d6:	0f b6       	in	r0, 0x3f	; 63
     7d8:	f8 94       	cli
     7da:	de bf       	out	0x3e, r29	; 62
     7dc:	0f be       	out	0x3f, r0	; 63
     7de:	cd bf       	out	0x3d, r28	; 61
     7e0:	df 91       	pop	r29
     7e2:	cf 91       	pop	r28
     7e4:	08 95       	ret

000007e6 <__vector_18>:
	portEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

SIGNAL( USART_RX_vect )
{
     7e6:	1f 92       	push	r1
     7e8:	0f 92       	push	r0
     7ea:	00 90 5f 00 	lds	r0, 0x005F
     7ee:	0f 92       	push	r0
     7f0:	11 24       	eor	r1, r1
     7f2:	2f 93       	push	r18
     7f4:	3f 93       	push	r19
     7f6:	4f 93       	push	r20
     7f8:	5f 93       	push	r21
     7fa:	6f 93       	push	r22
     7fc:	7f 93       	push	r23
     7fe:	8f 93       	push	r24
     800:	9f 93       	push	r25
     802:	af 93       	push	r26
     804:	bf 93       	push	r27
     806:	ef 93       	push	r30
     808:	ff 93       	push	r31
     80a:	cf 93       	push	r28
     80c:	df 93       	push	r29
     80e:	00 d0       	rcall	.+0      	; 0x810 <__vector_18+0x2a>
     810:	cd b7       	in	r28, 0x3d	; 61
     812:	de b7       	in	r29, 0x3e	; 62
signed char cChar;
signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
     814:	1a 82       	std	Y+2, r1	; 0x02
	
	/* Get the character and post it on the queue of Rxed characters.
	If the post causes a task to wake force a context switch as the woken task
	may have a higher priority than the task we have interrupted. */
	cChar = UDR0;
     816:	86 ec       	ldi	r24, 0xC6	; 198
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	fc 01       	movw	r30, r24
     81c:	80 81       	ld	r24, Z
     81e:	89 83       	std	Y+1, r24	; 0x01

	xQueueSendFromISR( xRxedChars, &cChar, &xHigherPriorityTaskWoken );
     820:	80 91 a1 01 	lds	r24, 0x01A1
     824:	90 91 a2 01 	lds	r25, 0x01A2
     828:	ae 01       	movw	r20, r28
     82a:	4e 5f       	subi	r20, 0xFE	; 254
     82c:	5f 4f       	sbci	r21, 0xFF	; 255
     82e:	20 e0       	ldi	r18, 0x00	; 0
     830:	be 01       	movw	r22, r28
     832:	6f 5f       	subi	r22, 0xFF	; 255
     834:	7f 4f       	sbci	r23, 0xFF	; 255
     836:	0e 94 24 0b 	call	0x1648	; 0x1648 <xQueueGenericSendFromISR>

	if( xHigherPriorityTaskWoken != pdFALSE )
     83a:	8a 81       	ldd	r24, Y+2	; 0x02
     83c:	88 23       	and	r24, r24
     83e:	11 f0       	breq	.+4      	; 0x844 <__vector_18+0x5e>
	{
		taskYIELD();
     840:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vPortYield>
	}
}
     844:	0f 90       	pop	r0
     846:	0f 90       	pop	r0
     848:	df 91       	pop	r29
     84a:	cf 91       	pop	r28
     84c:	ff 91       	pop	r31
     84e:	ef 91       	pop	r30
     850:	bf 91       	pop	r27
     852:	af 91       	pop	r26
     854:	9f 91       	pop	r25
     856:	8f 91       	pop	r24
     858:	7f 91       	pop	r23
     85a:	6f 91       	pop	r22
     85c:	5f 91       	pop	r21
     85e:	4f 91       	pop	r20
     860:	3f 91       	pop	r19
     862:	2f 91       	pop	r18
     864:	0f 90       	pop	r0
     866:	00 92 5f 00 	sts	0x005F, r0
     86a:	0f 90       	pop	r0
     86c:	1f 90       	pop	r1
     86e:	18 95       	reti

00000870 <__vector_19>:
/*-----------------------------------------------------------*/

SIGNAL( USART_UDRE_vect )
{
     870:	1f 92       	push	r1
     872:	0f 92       	push	r0
     874:	00 90 5f 00 	lds	r0, 0x005F
     878:	0f 92       	push	r0
     87a:	11 24       	eor	r1, r1
     87c:	2f 93       	push	r18
     87e:	3f 93       	push	r19
     880:	4f 93       	push	r20
     882:	5f 93       	push	r21
     884:	6f 93       	push	r22
     886:	7f 93       	push	r23
     888:	8f 93       	push	r24
     88a:	9f 93       	push	r25
     88c:	af 93       	push	r26
     88e:	bf 93       	push	r27
     890:	ef 93       	push	r30
     892:	ff 93       	push	r31
     894:	cf 93       	push	r28
     896:	df 93       	push	r29
     898:	00 d0       	rcall	.+0      	; 0x89a <__vector_19+0x2a>
     89a:	1f 92       	push	r1
     89c:	cd b7       	in	r28, 0x3d	; 61
     89e:	de b7       	in	r29, 0x3e	; 62
signed char cChar, cTaskWoken;

	if( xQueueReceiveFromISR( xCharsForTx, &cChar, &cTaskWoken ) == pdTRUE )
     8a0:	80 91 a3 01 	lds	r24, 0x01A3
     8a4:	90 91 a4 01 	lds	r25, 0x01A4
     8a8:	ae 01       	movw	r20, r28
     8aa:	4d 5f       	subi	r20, 0xFD	; 253
     8ac:	5f 4f       	sbci	r21, 0xFF	; 255
     8ae:	9e 01       	movw	r18, r28
     8b0:	2e 5f       	subi	r18, 0xFE	; 254
     8b2:	3f 4f       	sbci	r19, 0xFF	; 255
     8b4:	b9 01       	movw	r22, r18
     8b6:	0e 94 5e 0c 	call	0x18bc	; 0x18bc <xQueueReceiveFromISR>
     8ba:	81 30       	cpi	r24, 0x01	; 1
     8bc:	31 f4       	brne	.+12     	; 0x8ca <__vector_19+0x5a>
	{
			UDR0 = cChar;
     8be:	86 ec       	ldi	r24, 0xC6	; 198
     8c0:	90 e0       	ldi	r25, 0x00	; 0
     8c2:	2a 81       	ldd	r18, Y+2	; 0x02
     8c4:	fc 01       	movw	r30, r24
     8c6:	20 83       	st	Z, r18
     8c8:	0d c0       	rjmp	.+26     	; 0x8e4 <__vector_19+0x74>
	}
	else
	{
		/* Queue empty, nothing to send. */
		vInterruptOff();
     8ca:	81 ec       	ldi	r24, 0xC1	; 193
     8cc:	90 e0       	ldi	r25, 0x00	; 0
     8ce:	fc 01       	movw	r30, r24
     8d0:	80 81       	ld	r24, Z
     8d2:	89 83       	std	Y+1, r24	; 0x01
     8d4:	89 81       	ldd	r24, Y+1	; 0x01
     8d6:	8f 7d       	andi	r24, 0xDF	; 223
     8d8:	89 83       	std	Y+1, r24	; 0x01
     8da:	81 ec       	ldi	r24, 0xC1	; 193
     8dc:	90 e0       	ldi	r25, 0x00	; 0
     8de:	29 81       	ldd	r18, Y+1	; 0x01
     8e0:	fc 01       	movw	r30, r24
     8e2:	20 83       	st	Z, r18
	}
}
     8e4:	0f 90       	pop	r0
     8e6:	0f 90       	pop	r0
     8e8:	0f 90       	pop	r0
     8ea:	df 91       	pop	r29
     8ec:	cf 91       	pop	r28
     8ee:	ff 91       	pop	r31
     8f0:	ef 91       	pop	r30
     8f2:	bf 91       	pop	r27
     8f4:	af 91       	pop	r26
     8f6:	9f 91       	pop	r25
     8f8:	8f 91       	pop	r24
     8fa:	7f 91       	pop	r23
     8fc:	6f 91       	pop	r22
     8fe:	5f 91       	pop	r21
     900:	4f 91       	pop	r20
     902:	3f 91       	pop	r19
     904:	2f 91       	pop	r18
     906:	0f 90       	pop	r0
     908:	00 92 5f 00 	sts	0x005F, r0
     90c:	0f 90       	pop	r0
     90e:	1f 90       	pop	r1
     910:	18 95       	reti

00000912 <main>:
 
 //////////////////////////////////////////////////////////////////////////
 // MAIN
 //////////////////////////////////////////////////////////////////////////
 int main (void)
 {
     912:	cf 93       	push	r28
     914:	df 93       	push	r29
     916:	cd b7       	in	r28, 0x3d	; 61
     918:	de b7       	in	r29, 0x3e	; 62
	// prvIncrementResetCount();
	 
	vParTestInitialise();
     91a:	0e 94 e3 16 	call	0x2dc6	; 0x2dc6 <vParTestInitialise>
	motor_setup();
     91e:	0e 94 53 00 	call	0xa6	; 0xa6 <motor_setup>
	//vParTestSetLED((portBASE_TYPE) 6, pdFALSE);
	
	// Initialize the LED tasks
	// Initialize LED task rate
	//ledTaskRate = LED_TASK_RATE_BASE;
	ledTaskRate = 0x16;
     922:	86 e1       	ldi	r24, 0x16	; 22
     924:	90 e0       	ldi	r25, 0x00	; 0
     926:	90 93 a8 08 	sts	0x08A8, r25
     92a:	80 93 a7 08 	sts	0x08A7, r24
	vStartLEDFlashTasks( mainLED_TASK_PRIORITY );
     92e:	81 e0       	ldi	r24, 0x01	; 1
     930:	0e 94 74 16 	call	0x2ce8	; 0x2ce8 <vStartLEDFlashTasks>
	vStartMotorTask( mainMOTOR_TASK_PRIORITY );
     934:	82 e0       	ldi	r24, 0x02	; 2
     936:	0e 94 a1 00 	call	0x142	; 0x142 <vStartMotorTask>
	vStartSerialTask( mainLED_TASK_PRIORITY, mainCOM_TEST_BAUD_RATE, 20 );
     93a:	24 e1       	ldi	r18, 0x14	; 20
     93c:	40 e8       	ldi	r20, 0x80	; 128
     93e:	55 e2       	ldi	r21, 0x25	; 37
     940:	60 e0       	ldi	r22, 0x00	; 0
     942:	70 e0       	ldi	r23, 0x00	; 0
     944:	81 e0       	ldi	r24, 0x01	; 1
     946:	0e 94 77 17 	call	0x2eee	; 0x2eee <vStartSerialTask>
	
	/* Start the RTOS scheduler, this function should not return as it causes the execution
        context to change from main() to one of the created tasks. */
	vTaskStartScheduler();
     94a:	0e 94 49 11 	call	0x2292	; 0x2292 <vTaskStartScheduler>
	return 0;
     94e:	80 e0       	ldi	r24, 0x00	; 0
     950:	90 e0       	ldi	r25, 0x00	; 0
 }
     952:	df 91       	pop	r29
     954:	cf 91       	pop	r28
     956:	08 95       	ret

00000958 <vApplicationTickHook>:

 void vApplicationTickHook( void )
 {
     958:	cf 93       	push	r28
     95a:	df 93       	push	r29
     95c:	cd b7       	in	r28, 0x3d	; 61
     95e:	de b7       	in	r29, 0x3e	; 62
	clkElapsed++; // Increment the timer
     960:	80 91 79 08 	lds	r24, 0x0879
     964:	90 91 7a 08 	lds	r25, 0x087A
     968:	01 96       	adiw	r24, 0x01	; 1
     96a:	90 93 7a 08 	sts	0x087A, r25
     96e:	80 93 79 08 	sts	0x0879, r24
 }
     972:	df 91       	pop	r29
     974:	cf 91       	pop	r28
     976:	08 95       	ret

00000978 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     978:	cf 93       	push	r28
     97a:	df 93       	push	r29
     97c:	00 d0       	rcall	.+0      	; 0x97e <pvPortMalloc+0x6>
     97e:	00 d0       	rcall	.+0      	; 0x980 <pvPortMalloc+0x8>
     980:	cd b7       	in	r28, 0x3d	; 61
     982:	de b7       	in	r29, 0x3e	; 62
     984:	9c 83       	std	Y+4, r25	; 0x04
     986:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
     988:	1a 82       	std	Y+2, r1	; 0x02
     98a:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     98c:	0e 94 84 11 	call	0x2308	; 0x2308 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     990:	80 91 1a 08 	lds	r24, 0x081A
     994:	90 91 1b 08 	lds	r25, 0x081B
     998:	00 97       	sbiw	r24, 0x00	; 0
     99a:	31 f4       	brne	.+12     	; 0x9a8 <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     99c:	86 ea       	ldi	r24, 0xA6	; 166
     99e:	91 e0       	ldi	r25, 0x01	; 1
     9a0:	90 93 1b 08 	sts	0x081B, r25
     9a4:	80 93 1a 08 	sts	0x081A, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     9a8:	20 91 18 08 	lds	r18, 0x0818
     9ac:	30 91 19 08 	lds	r19, 0x0819
     9b0:	8b 81       	ldd	r24, Y+3	; 0x03
     9b2:	9c 81       	ldd	r25, Y+4	; 0x04
     9b4:	82 0f       	add	r24, r18
     9b6:	93 1f       	adc	r25, r19
     9b8:	82 37       	cpi	r24, 0x72	; 114
     9ba:	26 e0       	ldi	r18, 0x06	; 6
     9bc:	92 07       	cpc	r25, r18
     9be:	38 f5       	brcc	.+78     	; 0xa0e <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
     9c0:	20 91 18 08 	lds	r18, 0x0818
     9c4:	30 91 19 08 	lds	r19, 0x0819
     9c8:	8b 81       	ldd	r24, Y+3	; 0x03
     9ca:	9c 81       	ldd	r25, Y+4	; 0x04
     9cc:	28 0f       	add	r18, r24
     9ce:	39 1f       	adc	r19, r25
     9d0:	80 91 18 08 	lds	r24, 0x0818
     9d4:	90 91 19 08 	lds	r25, 0x0819
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     9d8:	82 17       	cp	r24, r18
     9da:	93 07       	cpc	r25, r19
     9dc:	c0 f4       	brcc	.+48     	; 0xa0e <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     9de:	20 91 1a 08 	lds	r18, 0x081A
     9e2:	30 91 1b 08 	lds	r19, 0x081B
     9e6:	80 91 18 08 	lds	r24, 0x0818
     9ea:	90 91 19 08 	lds	r25, 0x0819
     9ee:	82 0f       	add	r24, r18
     9f0:	93 1f       	adc	r25, r19
     9f2:	9a 83       	std	Y+2, r25	; 0x02
     9f4:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
     9f6:	20 91 18 08 	lds	r18, 0x0818
     9fa:	30 91 19 08 	lds	r19, 0x0819
     9fe:	8b 81       	ldd	r24, Y+3	; 0x03
     a00:	9c 81       	ldd	r25, Y+4	; 0x04
     a02:	82 0f       	add	r24, r18
     a04:	93 1f       	adc	r25, r19
     a06:	90 93 19 08 	sts	0x0819, r25
     a0a:	80 93 18 08 	sts	0x0818, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     a0e:	0e 94 90 11 	call	0x2320	; 0x2320 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
     a12:	89 81       	ldd	r24, Y+1	; 0x01
     a14:	9a 81       	ldd	r25, Y+2	; 0x02
}
     a16:	0f 90       	pop	r0
     a18:	0f 90       	pop	r0
     a1a:	0f 90       	pop	r0
     a1c:	0f 90       	pop	r0
     a1e:	df 91       	pop	r29
     a20:	cf 91       	pop	r28
     a22:	08 95       	ret

00000a24 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     a24:	cf 93       	push	r28
     a26:	df 93       	push	r29
     a28:	00 d0       	rcall	.+0      	; 0xa2a <vPortFree+0x6>
     a2a:	cd b7       	in	r28, 0x3d	; 61
     a2c:	de b7       	in	r29, 0x3e	; 62
     a2e:	9a 83       	std	Y+2, r25	; 0x02
     a30:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
     a32:	0f 90       	pop	r0
     a34:	0f 90       	pop	r0
     a36:	df 91       	pop	r29
     a38:	cf 91       	pop	r28
     a3a:	08 95       	ret

00000a3c <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
     a3c:	cf 93       	push	r28
     a3e:	df 93       	push	r29
     a40:	cd b7       	in	r28, 0x3d	; 61
     a42:	de b7       	in	r29, 0x3e	; 62
     a44:	28 97       	sbiw	r28, 0x08	; 8
     a46:	0f b6       	in	r0, 0x3f	; 63
     a48:	f8 94       	cli
     a4a:	de bf       	out	0x3e, r29	; 62
     a4c:	0f be       	out	0x3f, r0	; 63
     a4e:	cd bf       	out	0x3d, r28	; 61
     a50:	9c 83       	std	Y+4, r25	; 0x04
     a52:	8b 83       	std	Y+3, r24	; 0x03
     a54:	7e 83       	std	Y+6, r23	; 0x06
     a56:	6d 83       	std	Y+5, r22	; 0x05
     a58:	58 87       	std	Y+8, r21	; 0x08
     a5a:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     a5c:	8b 81       	ldd	r24, Y+3	; 0x03
     a5e:	9c 81       	ldd	r25, Y+4	; 0x04
     a60:	21 e1       	ldi	r18, 0x11	; 17
     a62:	fc 01       	movw	r30, r24
     a64:	20 83       	st	Z, r18
	pxTopOfStack--;
     a66:	8b 81       	ldd	r24, Y+3	; 0x03
     a68:	9c 81       	ldd	r25, Y+4	; 0x04
     a6a:	01 97       	sbiw	r24, 0x01	; 1
     a6c:	9c 83       	std	Y+4, r25	; 0x04
     a6e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     a70:	8b 81       	ldd	r24, Y+3	; 0x03
     a72:	9c 81       	ldd	r25, Y+4	; 0x04
     a74:	22 e2       	ldi	r18, 0x22	; 34
     a76:	fc 01       	movw	r30, r24
     a78:	20 83       	st	Z, r18
	pxTopOfStack--;
     a7a:	8b 81       	ldd	r24, Y+3	; 0x03
     a7c:	9c 81       	ldd	r25, Y+4	; 0x04
     a7e:	01 97       	sbiw	r24, 0x01	; 1
     a80:	9c 83       	std	Y+4, r25	; 0x04
     a82:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     a84:	8b 81       	ldd	r24, Y+3	; 0x03
     a86:	9c 81       	ldd	r25, Y+4	; 0x04
     a88:	23 e3       	ldi	r18, 0x33	; 51
     a8a:	fc 01       	movw	r30, r24
     a8c:	20 83       	st	Z, r18
	pxTopOfStack--;
     a8e:	8b 81       	ldd	r24, Y+3	; 0x03
     a90:	9c 81       	ldd	r25, Y+4	; 0x04
     a92:	01 97       	sbiw	r24, 0x01	; 1
     a94:	9c 83       	std	Y+4, r25	; 0x04
     a96:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
     a98:	8d 81       	ldd	r24, Y+5	; 0x05
     a9a:	9e 81       	ldd	r25, Y+6	; 0x06
     a9c:	9a 83       	std	Y+2, r25	; 0x02
     a9e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     aa0:	29 81       	ldd	r18, Y+1	; 0x01
     aa2:	8b 81       	ldd	r24, Y+3	; 0x03
     aa4:	9c 81       	ldd	r25, Y+4	; 0x04
     aa6:	fc 01       	movw	r30, r24
     aa8:	20 83       	st	Z, r18
	pxTopOfStack--;
     aaa:	8b 81       	ldd	r24, Y+3	; 0x03
     aac:	9c 81       	ldd	r25, Y+4	; 0x04
     aae:	01 97       	sbiw	r24, 0x01	; 1
     ab0:	9c 83       	std	Y+4, r25	; 0x04
     ab2:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     ab4:	89 81       	ldd	r24, Y+1	; 0x01
     ab6:	9a 81       	ldd	r25, Y+2	; 0x02
     ab8:	89 2f       	mov	r24, r25
     aba:	99 27       	eor	r25, r25
     abc:	9a 83       	std	Y+2, r25	; 0x02
     abe:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     ac0:	29 81       	ldd	r18, Y+1	; 0x01
     ac2:	8b 81       	ldd	r24, Y+3	; 0x03
     ac4:	9c 81       	ldd	r25, Y+4	; 0x04
     ac6:	fc 01       	movw	r30, r24
     ac8:	20 83       	st	Z, r18
	pxTopOfStack--;
     aca:	8b 81       	ldd	r24, Y+3	; 0x03
     acc:	9c 81       	ldd	r25, Y+4	; 0x04
     ace:	01 97       	sbiw	r24, 0x01	; 1
     ad0:	9c 83       	std	Y+4, r25	; 0x04
     ad2:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     ad4:	8b 81       	ldd	r24, Y+3	; 0x03
     ad6:	9c 81       	ldd	r25, Y+4	; 0x04
     ad8:	fc 01       	movw	r30, r24
     ada:	10 82       	st	Z, r1
	pxTopOfStack--;
     adc:	8b 81       	ldd	r24, Y+3	; 0x03
     ade:	9c 81       	ldd	r25, Y+4	; 0x04
     ae0:	01 97       	sbiw	r24, 0x01	; 1
     ae2:	9c 83       	std	Y+4, r25	; 0x04
     ae4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     ae6:	8b 81       	ldd	r24, Y+3	; 0x03
     ae8:	9c 81       	ldd	r25, Y+4	; 0x04
     aea:	20 e8       	ldi	r18, 0x80	; 128
     aec:	fc 01       	movw	r30, r24
     aee:	20 83       	st	Z, r18
	pxTopOfStack--;
     af0:	8b 81       	ldd	r24, Y+3	; 0x03
     af2:	9c 81       	ldd	r25, Y+4	; 0x04
     af4:	01 97       	sbiw	r24, 0x01	; 1
     af6:	9c 83       	std	Y+4, r25	; 0x04
     af8:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     afa:	8b 81       	ldd	r24, Y+3	; 0x03
     afc:	9c 81       	ldd	r25, Y+4	; 0x04
     afe:	fc 01       	movw	r30, r24
     b00:	10 82       	st	Z, r1
	pxTopOfStack--;
     b02:	8b 81       	ldd	r24, Y+3	; 0x03
     b04:	9c 81       	ldd	r25, Y+4	; 0x04
     b06:	01 97       	sbiw	r24, 0x01	; 1
     b08:	9c 83       	std	Y+4, r25	; 0x04
     b0a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     b0c:	8b 81       	ldd	r24, Y+3	; 0x03
     b0e:	9c 81       	ldd	r25, Y+4	; 0x04
     b10:	22 e0       	ldi	r18, 0x02	; 2
     b12:	fc 01       	movw	r30, r24
     b14:	20 83       	st	Z, r18
	pxTopOfStack--;
     b16:	8b 81       	ldd	r24, Y+3	; 0x03
     b18:	9c 81       	ldd	r25, Y+4	; 0x04
     b1a:	01 97       	sbiw	r24, 0x01	; 1
     b1c:	9c 83       	std	Y+4, r25	; 0x04
     b1e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     b20:	8b 81       	ldd	r24, Y+3	; 0x03
     b22:	9c 81       	ldd	r25, Y+4	; 0x04
     b24:	23 e0       	ldi	r18, 0x03	; 3
     b26:	fc 01       	movw	r30, r24
     b28:	20 83       	st	Z, r18
	pxTopOfStack--;
     b2a:	8b 81       	ldd	r24, Y+3	; 0x03
     b2c:	9c 81       	ldd	r25, Y+4	; 0x04
     b2e:	01 97       	sbiw	r24, 0x01	; 1
     b30:	9c 83       	std	Y+4, r25	; 0x04
     b32:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     b34:	8b 81       	ldd	r24, Y+3	; 0x03
     b36:	9c 81       	ldd	r25, Y+4	; 0x04
     b38:	24 e0       	ldi	r18, 0x04	; 4
     b3a:	fc 01       	movw	r30, r24
     b3c:	20 83       	st	Z, r18
	pxTopOfStack--;
     b3e:	8b 81       	ldd	r24, Y+3	; 0x03
     b40:	9c 81       	ldd	r25, Y+4	; 0x04
     b42:	01 97       	sbiw	r24, 0x01	; 1
     b44:	9c 83       	std	Y+4, r25	; 0x04
     b46:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     b48:	8b 81       	ldd	r24, Y+3	; 0x03
     b4a:	9c 81       	ldd	r25, Y+4	; 0x04
     b4c:	25 e0       	ldi	r18, 0x05	; 5
     b4e:	fc 01       	movw	r30, r24
     b50:	20 83       	st	Z, r18
	pxTopOfStack--;
     b52:	8b 81       	ldd	r24, Y+3	; 0x03
     b54:	9c 81       	ldd	r25, Y+4	; 0x04
     b56:	01 97       	sbiw	r24, 0x01	; 1
     b58:	9c 83       	std	Y+4, r25	; 0x04
     b5a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     b5c:	8b 81       	ldd	r24, Y+3	; 0x03
     b5e:	9c 81       	ldd	r25, Y+4	; 0x04
     b60:	26 e0       	ldi	r18, 0x06	; 6
     b62:	fc 01       	movw	r30, r24
     b64:	20 83       	st	Z, r18
	pxTopOfStack--;
     b66:	8b 81       	ldd	r24, Y+3	; 0x03
     b68:	9c 81       	ldd	r25, Y+4	; 0x04
     b6a:	01 97       	sbiw	r24, 0x01	; 1
     b6c:	9c 83       	std	Y+4, r25	; 0x04
     b6e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     b70:	8b 81       	ldd	r24, Y+3	; 0x03
     b72:	9c 81       	ldd	r25, Y+4	; 0x04
     b74:	27 e0       	ldi	r18, 0x07	; 7
     b76:	fc 01       	movw	r30, r24
     b78:	20 83       	st	Z, r18
	pxTopOfStack--;
     b7a:	8b 81       	ldd	r24, Y+3	; 0x03
     b7c:	9c 81       	ldd	r25, Y+4	; 0x04
     b7e:	01 97       	sbiw	r24, 0x01	; 1
     b80:	9c 83       	std	Y+4, r25	; 0x04
     b82:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     b84:	8b 81       	ldd	r24, Y+3	; 0x03
     b86:	9c 81       	ldd	r25, Y+4	; 0x04
     b88:	28 e0       	ldi	r18, 0x08	; 8
     b8a:	fc 01       	movw	r30, r24
     b8c:	20 83       	st	Z, r18
	pxTopOfStack--;
     b8e:	8b 81       	ldd	r24, Y+3	; 0x03
     b90:	9c 81       	ldd	r25, Y+4	; 0x04
     b92:	01 97       	sbiw	r24, 0x01	; 1
     b94:	9c 83       	std	Y+4, r25	; 0x04
     b96:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     b98:	8b 81       	ldd	r24, Y+3	; 0x03
     b9a:	9c 81       	ldd	r25, Y+4	; 0x04
     b9c:	29 e0       	ldi	r18, 0x09	; 9
     b9e:	fc 01       	movw	r30, r24
     ba0:	20 83       	st	Z, r18
	pxTopOfStack--;
     ba2:	8b 81       	ldd	r24, Y+3	; 0x03
     ba4:	9c 81       	ldd	r25, Y+4	; 0x04
     ba6:	01 97       	sbiw	r24, 0x01	; 1
     ba8:	9c 83       	std	Y+4, r25	; 0x04
     baa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     bac:	8b 81       	ldd	r24, Y+3	; 0x03
     bae:	9c 81       	ldd	r25, Y+4	; 0x04
     bb0:	20 e1       	ldi	r18, 0x10	; 16
     bb2:	fc 01       	movw	r30, r24
     bb4:	20 83       	st	Z, r18
	pxTopOfStack--;
     bb6:	8b 81       	ldd	r24, Y+3	; 0x03
     bb8:	9c 81       	ldd	r25, Y+4	; 0x04
     bba:	01 97       	sbiw	r24, 0x01	; 1
     bbc:	9c 83       	std	Y+4, r25	; 0x04
     bbe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     bc0:	8b 81       	ldd	r24, Y+3	; 0x03
     bc2:	9c 81       	ldd	r25, Y+4	; 0x04
     bc4:	21 e1       	ldi	r18, 0x11	; 17
     bc6:	fc 01       	movw	r30, r24
     bc8:	20 83       	st	Z, r18
	pxTopOfStack--;
     bca:	8b 81       	ldd	r24, Y+3	; 0x03
     bcc:	9c 81       	ldd	r25, Y+4	; 0x04
     bce:	01 97       	sbiw	r24, 0x01	; 1
     bd0:	9c 83       	std	Y+4, r25	; 0x04
     bd2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     bd4:	8b 81       	ldd	r24, Y+3	; 0x03
     bd6:	9c 81       	ldd	r25, Y+4	; 0x04
     bd8:	22 e1       	ldi	r18, 0x12	; 18
     bda:	fc 01       	movw	r30, r24
     bdc:	20 83       	st	Z, r18
	pxTopOfStack--;
     bde:	8b 81       	ldd	r24, Y+3	; 0x03
     be0:	9c 81       	ldd	r25, Y+4	; 0x04
     be2:	01 97       	sbiw	r24, 0x01	; 1
     be4:	9c 83       	std	Y+4, r25	; 0x04
     be6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     be8:	8b 81       	ldd	r24, Y+3	; 0x03
     bea:	9c 81       	ldd	r25, Y+4	; 0x04
     bec:	23 e1       	ldi	r18, 0x13	; 19
     bee:	fc 01       	movw	r30, r24
     bf0:	20 83       	st	Z, r18
	pxTopOfStack--;
     bf2:	8b 81       	ldd	r24, Y+3	; 0x03
     bf4:	9c 81       	ldd	r25, Y+4	; 0x04
     bf6:	01 97       	sbiw	r24, 0x01	; 1
     bf8:	9c 83       	std	Y+4, r25	; 0x04
     bfa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     bfc:	8b 81       	ldd	r24, Y+3	; 0x03
     bfe:	9c 81       	ldd	r25, Y+4	; 0x04
     c00:	24 e1       	ldi	r18, 0x14	; 20
     c02:	fc 01       	movw	r30, r24
     c04:	20 83       	st	Z, r18
	pxTopOfStack--;
     c06:	8b 81       	ldd	r24, Y+3	; 0x03
     c08:	9c 81       	ldd	r25, Y+4	; 0x04
     c0a:	01 97       	sbiw	r24, 0x01	; 1
     c0c:	9c 83       	std	Y+4, r25	; 0x04
     c0e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     c10:	8b 81       	ldd	r24, Y+3	; 0x03
     c12:	9c 81       	ldd	r25, Y+4	; 0x04
     c14:	25 e1       	ldi	r18, 0x15	; 21
     c16:	fc 01       	movw	r30, r24
     c18:	20 83       	st	Z, r18
	pxTopOfStack--;
     c1a:	8b 81       	ldd	r24, Y+3	; 0x03
     c1c:	9c 81       	ldd	r25, Y+4	; 0x04
     c1e:	01 97       	sbiw	r24, 0x01	; 1
     c20:	9c 83       	std	Y+4, r25	; 0x04
     c22:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     c24:	8b 81       	ldd	r24, Y+3	; 0x03
     c26:	9c 81       	ldd	r25, Y+4	; 0x04
     c28:	26 e1       	ldi	r18, 0x16	; 22
     c2a:	fc 01       	movw	r30, r24
     c2c:	20 83       	st	Z, r18
	pxTopOfStack--;
     c2e:	8b 81       	ldd	r24, Y+3	; 0x03
     c30:	9c 81       	ldd	r25, Y+4	; 0x04
     c32:	01 97       	sbiw	r24, 0x01	; 1
     c34:	9c 83       	std	Y+4, r25	; 0x04
     c36:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     c38:	8b 81       	ldd	r24, Y+3	; 0x03
     c3a:	9c 81       	ldd	r25, Y+4	; 0x04
     c3c:	27 e1       	ldi	r18, 0x17	; 23
     c3e:	fc 01       	movw	r30, r24
     c40:	20 83       	st	Z, r18
	pxTopOfStack--;
     c42:	8b 81       	ldd	r24, Y+3	; 0x03
     c44:	9c 81       	ldd	r25, Y+4	; 0x04
     c46:	01 97       	sbiw	r24, 0x01	; 1
     c48:	9c 83       	std	Y+4, r25	; 0x04
     c4a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     c4c:	8b 81       	ldd	r24, Y+3	; 0x03
     c4e:	9c 81       	ldd	r25, Y+4	; 0x04
     c50:	28 e1       	ldi	r18, 0x18	; 24
     c52:	fc 01       	movw	r30, r24
     c54:	20 83       	st	Z, r18
	pxTopOfStack--;
     c56:	8b 81       	ldd	r24, Y+3	; 0x03
     c58:	9c 81       	ldd	r25, Y+4	; 0x04
     c5a:	01 97       	sbiw	r24, 0x01	; 1
     c5c:	9c 83       	std	Y+4, r25	; 0x04
     c5e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     c60:	8b 81       	ldd	r24, Y+3	; 0x03
     c62:	9c 81       	ldd	r25, Y+4	; 0x04
     c64:	29 e1       	ldi	r18, 0x19	; 25
     c66:	fc 01       	movw	r30, r24
     c68:	20 83       	st	Z, r18
	pxTopOfStack--;
     c6a:	8b 81       	ldd	r24, Y+3	; 0x03
     c6c:	9c 81       	ldd	r25, Y+4	; 0x04
     c6e:	01 97       	sbiw	r24, 0x01	; 1
     c70:	9c 83       	std	Y+4, r25	; 0x04
     c72:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     c74:	8b 81       	ldd	r24, Y+3	; 0x03
     c76:	9c 81       	ldd	r25, Y+4	; 0x04
     c78:	20 e2       	ldi	r18, 0x20	; 32
     c7a:	fc 01       	movw	r30, r24
     c7c:	20 83       	st	Z, r18
	pxTopOfStack--;
     c7e:	8b 81       	ldd	r24, Y+3	; 0x03
     c80:	9c 81       	ldd	r25, Y+4	; 0x04
     c82:	01 97       	sbiw	r24, 0x01	; 1
     c84:	9c 83       	std	Y+4, r25	; 0x04
     c86:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     c88:	8b 81       	ldd	r24, Y+3	; 0x03
     c8a:	9c 81       	ldd	r25, Y+4	; 0x04
     c8c:	21 e2       	ldi	r18, 0x21	; 33
     c8e:	fc 01       	movw	r30, r24
     c90:	20 83       	st	Z, r18
	pxTopOfStack--;
     c92:	8b 81       	ldd	r24, Y+3	; 0x03
     c94:	9c 81       	ldd	r25, Y+4	; 0x04
     c96:	01 97       	sbiw	r24, 0x01	; 1
     c98:	9c 83       	std	Y+4, r25	; 0x04
     c9a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     c9c:	8b 81       	ldd	r24, Y+3	; 0x03
     c9e:	9c 81       	ldd	r25, Y+4	; 0x04
     ca0:	22 e2       	ldi	r18, 0x22	; 34
     ca2:	fc 01       	movw	r30, r24
     ca4:	20 83       	st	Z, r18
	pxTopOfStack--;
     ca6:	8b 81       	ldd	r24, Y+3	; 0x03
     ca8:	9c 81       	ldd	r25, Y+4	; 0x04
     caa:	01 97       	sbiw	r24, 0x01	; 1
     cac:	9c 83       	std	Y+4, r25	; 0x04
     cae:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     cb0:	8b 81       	ldd	r24, Y+3	; 0x03
     cb2:	9c 81       	ldd	r25, Y+4	; 0x04
     cb4:	23 e2       	ldi	r18, 0x23	; 35
     cb6:	fc 01       	movw	r30, r24
     cb8:	20 83       	st	Z, r18
	pxTopOfStack--;
     cba:	8b 81       	ldd	r24, Y+3	; 0x03
     cbc:	9c 81       	ldd	r25, Y+4	; 0x04
     cbe:	01 97       	sbiw	r24, 0x01	; 1
     cc0:	9c 83       	std	Y+4, r25	; 0x04
     cc2:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
     cc4:	8f 81       	ldd	r24, Y+7	; 0x07
     cc6:	98 85       	ldd	r25, Y+8	; 0x08
     cc8:	9a 83       	std	Y+2, r25	; 0x02
     cca:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     ccc:	29 81       	ldd	r18, Y+1	; 0x01
     cce:	8b 81       	ldd	r24, Y+3	; 0x03
     cd0:	9c 81       	ldd	r25, Y+4	; 0x04
     cd2:	fc 01       	movw	r30, r24
     cd4:	20 83       	st	Z, r18
	pxTopOfStack--;
     cd6:	8b 81       	ldd	r24, Y+3	; 0x03
     cd8:	9c 81       	ldd	r25, Y+4	; 0x04
     cda:	01 97       	sbiw	r24, 0x01	; 1
     cdc:	9c 83       	std	Y+4, r25	; 0x04
     cde:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     ce0:	89 81       	ldd	r24, Y+1	; 0x01
     ce2:	9a 81       	ldd	r25, Y+2	; 0x02
     ce4:	89 2f       	mov	r24, r25
     ce6:	99 27       	eor	r25, r25
     ce8:	9a 83       	std	Y+2, r25	; 0x02
     cea:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     cec:	29 81       	ldd	r18, Y+1	; 0x01
     cee:	8b 81       	ldd	r24, Y+3	; 0x03
     cf0:	9c 81       	ldd	r25, Y+4	; 0x04
     cf2:	fc 01       	movw	r30, r24
     cf4:	20 83       	st	Z, r18
	pxTopOfStack--;
     cf6:	8b 81       	ldd	r24, Y+3	; 0x03
     cf8:	9c 81       	ldd	r25, Y+4	; 0x04
     cfa:	01 97       	sbiw	r24, 0x01	; 1
     cfc:	9c 83       	std	Y+4, r25	; 0x04
     cfe:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     d00:	8b 81       	ldd	r24, Y+3	; 0x03
     d02:	9c 81       	ldd	r25, Y+4	; 0x04
     d04:	26 e2       	ldi	r18, 0x26	; 38
     d06:	fc 01       	movw	r30, r24
     d08:	20 83       	st	Z, r18
	pxTopOfStack--;
     d0a:	8b 81       	ldd	r24, Y+3	; 0x03
     d0c:	9c 81       	ldd	r25, Y+4	; 0x04
     d0e:	01 97       	sbiw	r24, 0x01	; 1
     d10:	9c 83       	std	Y+4, r25	; 0x04
     d12:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     d14:	8b 81       	ldd	r24, Y+3	; 0x03
     d16:	9c 81       	ldd	r25, Y+4	; 0x04
     d18:	27 e2       	ldi	r18, 0x27	; 39
     d1a:	fc 01       	movw	r30, r24
     d1c:	20 83       	st	Z, r18
	pxTopOfStack--;
     d1e:	8b 81       	ldd	r24, Y+3	; 0x03
     d20:	9c 81       	ldd	r25, Y+4	; 0x04
     d22:	01 97       	sbiw	r24, 0x01	; 1
     d24:	9c 83       	std	Y+4, r25	; 0x04
     d26:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     d28:	8b 81       	ldd	r24, Y+3	; 0x03
     d2a:	9c 81       	ldd	r25, Y+4	; 0x04
     d2c:	28 e2       	ldi	r18, 0x28	; 40
     d2e:	fc 01       	movw	r30, r24
     d30:	20 83       	st	Z, r18
	pxTopOfStack--;
     d32:	8b 81       	ldd	r24, Y+3	; 0x03
     d34:	9c 81       	ldd	r25, Y+4	; 0x04
     d36:	01 97       	sbiw	r24, 0x01	; 1
     d38:	9c 83       	std	Y+4, r25	; 0x04
     d3a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     d3c:	8b 81       	ldd	r24, Y+3	; 0x03
     d3e:	9c 81       	ldd	r25, Y+4	; 0x04
     d40:	29 e2       	ldi	r18, 0x29	; 41
     d42:	fc 01       	movw	r30, r24
     d44:	20 83       	st	Z, r18
	pxTopOfStack--;
     d46:	8b 81       	ldd	r24, Y+3	; 0x03
     d48:	9c 81       	ldd	r25, Y+4	; 0x04
     d4a:	01 97       	sbiw	r24, 0x01	; 1
     d4c:	9c 83       	std	Y+4, r25	; 0x04
     d4e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     d50:	8b 81       	ldd	r24, Y+3	; 0x03
     d52:	9c 81       	ldd	r25, Y+4	; 0x04
     d54:	20 e3       	ldi	r18, 0x30	; 48
     d56:	fc 01       	movw	r30, r24
     d58:	20 83       	st	Z, r18
	pxTopOfStack--;
     d5a:	8b 81       	ldd	r24, Y+3	; 0x03
     d5c:	9c 81       	ldd	r25, Y+4	; 0x04
     d5e:	01 97       	sbiw	r24, 0x01	; 1
     d60:	9c 83       	std	Y+4, r25	; 0x04
     d62:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     d64:	8b 81       	ldd	r24, Y+3	; 0x03
     d66:	9c 81       	ldd	r25, Y+4	; 0x04
     d68:	21 e3       	ldi	r18, 0x31	; 49
     d6a:	fc 01       	movw	r30, r24
     d6c:	20 83       	st	Z, r18
	pxTopOfStack--;
     d6e:	8b 81       	ldd	r24, Y+3	; 0x03
     d70:	9c 81       	ldd	r25, Y+4	; 0x04
     d72:	01 97       	sbiw	r24, 0x01	; 1
     d74:	9c 83       	std	Y+4, r25	; 0x04
     d76:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     d78:	8b 81       	ldd	r24, Y+3	; 0x03
     d7a:	9c 81       	ldd	r25, Y+4	; 0x04
}
     d7c:	28 96       	adiw	r28, 0x08	; 8
     d7e:	0f b6       	in	r0, 0x3f	; 63
     d80:	f8 94       	cli
     d82:	de bf       	out	0x3e, r29	; 62
     d84:	0f be       	out	0x3f, r0	; 63
     d86:	cd bf       	out	0x3d, r28	; 61
     d88:	df 91       	pop	r29
     d8a:	cf 91       	pop	r28
     d8c:	08 95       	ret

00000d8e <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
     d8e:	cf 93       	push	r28
     d90:	df 93       	push	r29
     d92:	cd b7       	in	r28, 0x3d	; 61
     d94:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     d96:	0e 94 b2 07 	call	0xf64	; 0xf64 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     d9a:	a0 91 1c 08 	lds	r26, 0x081C
     d9e:	b0 91 1d 08 	lds	r27, 0x081D
     da2:	cd 91       	ld	r28, X+
     da4:	cd bf       	out	0x3d, r28	; 61
     da6:	dd 91       	ld	r29, X+
     da8:	de bf       	out	0x3e, r29	; 62
     daa:	ff 91       	pop	r31
     dac:	ef 91       	pop	r30
     dae:	df 91       	pop	r29
     db0:	cf 91       	pop	r28
     db2:	bf 91       	pop	r27
     db4:	af 91       	pop	r26
     db6:	9f 91       	pop	r25
     db8:	8f 91       	pop	r24
     dba:	7f 91       	pop	r23
     dbc:	6f 91       	pop	r22
     dbe:	5f 91       	pop	r21
     dc0:	4f 91       	pop	r20
     dc2:	3f 91       	pop	r19
     dc4:	2f 91       	pop	r18
     dc6:	1f 91       	pop	r17
     dc8:	0f 91       	pop	r16
     dca:	ff 90       	pop	r15
     dcc:	ef 90       	pop	r14
     dce:	df 90       	pop	r13
     dd0:	cf 90       	pop	r12
     dd2:	bf 90       	pop	r11
     dd4:	af 90       	pop	r10
     dd6:	9f 90       	pop	r9
     dd8:	8f 90       	pop	r8
     dda:	7f 90       	pop	r7
     ddc:	6f 90       	pop	r6
     dde:	5f 90       	pop	r5
     de0:	4f 90       	pop	r4
     de2:	3f 90       	pop	r3
     de4:	2f 90       	pop	r2
     de6:	1f 90       	pop	r1
     de8:	0f 90       	pop	r0
     dea:	0f be       	out	0x3f, r0	; 63
     dec:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     dee:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     df0:	81 e0       	ldi	r24, 0x01	; 1
}
     df2:	df 91       	pop	r29
     df4:	cf 91       	pop	r28
     df6:	08 95       	ret

00000df8 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     df8:	0f 92       	push	r0
     dfa:	0f b6       	in	r0, 0x3f	; 63
     dfc:	f8 94       	cli
     dfe:	0f 92       	push	r0
     e00:	1f 92       	push	r1
     e02:	11 24       	eor	r1, r1
     e04:	2f 92       	push	r2
     e06:	3f 92       	push	r3
     e08:	4f 92       	push	r4
     e0a:	5f 92       	push	r5
     e0c:	6f 92       	push	r6
     e0e:	7f 92       	push	r7
     e10:	8f 92       	push	r8
     e12:	9f 92       	push	r9
     e14:	af 92       	push	r10
     e16:	bf 92       	push	r11
     e18:	cf 92       	push	r12
     e1a:	df 92       	push	r13
     e1c:	ef 92       	push	r14
     e1e:	ff 92       	push	r15
     e20:	0f 93       	push	r16
     e22:	1f 93       	push	r17
     e24:	2f 93       	push	r18
     e26:	3f 93       	push	r19
     e28:	4f 93       	push	r20
     e2a:	5f 93       	push	r21
     e2c:	6f 93       	push	r22
     e2e:	7f 93       	push	r23
     e30:	8f 93       	push	r24
     e32:	9f 93       	push	r25
     e34:	af 93       	push	r26
     e36:	bf 93       	push	r27
     e38:	cf 93       	push	r28
     e3a:	df 93       	push	r29
     e3c:	ef 93       	push	r30
     e3e:	ff 93       	push	r31
     e40:	a0 91 1c 08 	lds	r26, 0x081C
     e44:	b0 91 1d 08 	lds	r27, 0x081D
     e48:	0d b6       	in	r0, 0x3d	; 61
     e4a:	0d 92       	st	X+, r0
     e4c:	0e b6       	in	r0, 0x3e	; 62
     e4e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     e50:	0e 94 2b 13 	call	0x2656	; 0x2656 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     e54:	a0 91 1c 08 	lds	r26, 0x081C
     e58:	b0 91 1d 08 	lds	r27, 0x081D
     e5c:	cd 91       	ld	r28, X+
     e5e:	cd bf       	out	0x3d, r28	; 61
     e60:	dd 91       	ld	r29, X+
     e62:	de bf       	out	0x3e, r29	; 62
     e64:	ff 91       	pop	r31
     e66:	ef 91       	pop	r30
     e68:	df 91       	pop	r29
     e6a:	cf 91       	pop	r28
     e6c:	bf 91       	pop	r27
     e6e:	af 91       	pop	r26
     e70:	9f 91       	pop	r25
     e72:	8f 91       	pop	r24
     e74:	7f 91       	pop	r23
     e76:	6f 91       	pop	r22
     e78:	5f 91       	pop	r21
     e7a:	4f 91       	pop	r20
     e7c:	3f 91       	pop	r19
     e7e:	2f 91       	pop	r18
     e80:	1f 91       	pop	r17
     e82:	0f 91       	pop	r16
     e84:	ff 90       	pop	r15
     e86:	ef 90       	pop	r14
     e88:	df 90       	pop	r13
     e8a:	cf 90       	pop	r12
     e8c:	bf 90       	pop	r11
     e8e:	af 90       	pop	r10
     e90:	9f 90       	pop	r9
     e92:	8f 90       	pop	r8
     e94:	7f 90       	pop	r7
     e96:	6f 90       	pop	r6
     e98:	5f 90       	pop	r5
     e9a:	4f 90       	pop	r4
     e9c:	3f 90       	pop	r3
     e9e:	2f 90       	pop	r2
     ea0:	1f 90       	pop	r1
     ea2:	0f 90       	pop	r0
     ea4:	0f be       	out	0x3f, r0	; 63
     ea6:	0f 90       	pop	r0

	asm volatile ( "ret" );
     ea8:	08 95       	ret

00000eaa <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     eaa:	0f 92       	push	r0
     eac:	0f b6       	in	r0, 0x3f	; 63
     eae:	f8 94       	cli
     eb0:	0f 92       	push	r0
     eb2:	1f 92       	push	r1
     eb4:	11 24       	eor	r1, r1
     eb6:	2f 92       	push	r2
     eb8:	3f 92       	push	r3
     eba:	4f 92       	push	r4
     ebc:	5f 92       	push	r5
     ebe:	6f 92       	push	r6
     ec0:	7f 92       	push	r7
     ec2:	8f 92       	push	r8
     ec4:	9f 92       	push	r9
     ec6:	af 92       	push	r10
     ec8:	bf 92       	push	r11
     eca:	cf 92       	push	r12
     ecc:	df 92       	push	r13
     ece:	ef 92       	push	r14
     ed0:	ff 92       	push	r15
     ed2:	0f 93       	push	r16
     ed4:	1f 93       	push	r17
     ed6:	2f 93       	push	r18
     ed8:	3f 93       	push	r19
     eda:	4f 93       	push	r20
     edc:	5f 93       	push	r21
     ede:	6f 93       	push	r22
     ee0:	7f 93       	push	r23
     ee2:	8f 93       	push	r24
     ee4:	9f 93       	push	r25
     ee6:	af 93       	push	r26
     ee8:	bf 93       	push	r27
     eea:	cf 93       	push	r28
     eec:	df 93       	push	r29
     eee:	ef 93       	push	r30
     ef0:	ff 93       	push	r31
     ef2:	a0 91 1c 08 	lds	r26, 0x081C
     ef6:	b0 91 1d 08 	lds	r27, 0x081D
     efa:	0d b6       	in	r0, 0x3d	; 61
     efc:	0d 92       	st	X+, r0
     efe:	0e b6       	in	r0, 0x3e	; 62
     f00:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     f02:	0e 94 35 12 	call	0x246a	; 0x246a <xTaskIncrementTick>
     f06:	88 23       	and	r24, r24
     f08:	11 f0       	breq	.+4      	; 0xf0e <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
     f0a:	0e 94 2b 13 	call	0x2656	; 0x2656 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     f0e:	a0 91 1c 08 	lds	r26, 0x081C
     f12:	b0 91 1d 08 	lds	r27, 0x081D
     f16:	cd 91       	ld	r28, X+
     f18:	cd bf       	out	0x3d, r28	; 61
     f1a:	dd 91       	ld	r29, X+
     f1c:	de bf       	out	0x3e, r29	; 62
     f1e:	ff 91       	pop	r31
     f20:	ef 91       	pop	r30
     f22:	df 91       	pop	r29
     f24:	cf 91       	pop	r28
     f26:	bf 91       	pop	r27
     f28:	af 91       	pop	r26
     f2a:	9f 91       	pop	r25
     f2c:	8f 91       	pop	r24
     f2e:	7f 91       	pop	r23
     f30:	6f 91       	pop	r22
     f32:	5f 91       	pop	r21
     f34:	4f 91       	pop	r20
     f36:	3f 91       	pop	r19
     f38:	2f 91       	pop	r18
     f3a:	1f 91       	pop	r17
     f3c:	0f 91       	pop	r16
     f3e:	ff 90       	pop	r15
     f40:	ef 90       	pop	r14
     f42:	df 90       	pop	r13
     f44:	cf 90       	pop	r12
     f46:	bf 90       	pop	r11
     f48:	af 90       	pop	r10
     f4a:	9f 90       	pop	r9
     f4c:	8f 90       	pop	r8
     f4e:	7f 90       	pop	r7
     f50:	6f 90       	pop	r6
     f52:	5f 90       	pop	r5
     f54:	4f 90       	pop	r4
     f56:	3f 90       	pop	r3
     f58:	2f 90       	pop	r2
     f5a:	1f 90       	pop	r1
     f5c:	0f 90       	pop	r0
     f5e:	0f be       	out	0x3f, r0	; 63
     f60:	0f 90       	pop	r0

	asm volatile ( "ret" );
     f62:	08 95       	ret

00000f64 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
     f64:	cf 93       	push	r28
     f66:	df 93       	push	r29
     f68:	cd b7       	in	r28, 0x3d	; 61
     f6a:	de b7       	in	r29, 0x3e	; 62
     f6c:	2a 97       	sbiw	r28, 0x0a	; 10
     f6e:	0f b6       	in	r0, 0x3f	; 63
     f70:	f8 94       	cli
     f72:	de bf       	out	0x3e, r29	; 62
     f74:	0f be       	out	0x3f, r0	; 63
     f76:	cd bf       	out	0x3d, r28	; 61
unsigned portLONG ulCompareMatch;
unsigned portCHAR ucHighByte, ucLowByte;
    /* Using 16bit timer 1 to generate the tick.  Correct fuses must be
    selected for the configCPU_CLOCK_HZ clock. */
    ulCompareMatch = configCPU_CLOCK_HZ / portCLOCK_PRESCALER;
     f78:	80 e9       	ldi	r24, 0x90	; 144
     f7a:	90 ed       	ldi	r25, 0xD0	; 208
     f7c:	a3 e0       	ldi	r26, 0x03	; 3
     f7e:	b0 e0       	ldi	r27, 0x00	; 0
     f80:	89 83       	std	Y+1, r24	; 0x01
     f82:	9a 83       	std	Y+2, r25	; 0x02
     f84:	ab 83       	std	Y+3, r26	; 0x03
     f86:	bc 83       	std	Y+4, r27	; 0x04
    /* calculates the RTOS tick rate based on the timer's tick rate. */
    ulCompareMatch /= configTICK_RATE_HZ;
     f88:	89 81       	ldd	r24, Y+1	; 0x01
     f8a:	9a 81       	ldd	r25, Y+2	; 0x02
     f8c:	ab 81       	ldd	r26, Y+3	; 0x03
     f8e:	bc 81       	ldd	r27, Y+4	; 0x04
     f90:	28 ee       	ldi	r18, 0xE8	; 232
     f92:	33 e0       	ldi	r19, 0x03	; 3
     f94:	40 e0       	ldi	r20, 0x00	; 0
     f96:	50 e0       	ldi	r21, 0x00	; 0
     f98:	bc 01       	movw	r22, r24
     f9a:	cd 01       	movw	r24, r26
     f9c:	0e 94 1c 1a 	call	0x3438	; 0x3438 <__udivmodsi4>
     fa0:	da 01       	movw	r26, r20
     fa2:	c9 01       	movw	r24, r18
     fa4:	89 83       	std	Y+1, r24	; 0x01
     fa6:	9a 83       	std	Y+2, r25	; 0x02
     fa8:	ab 83       	std	Y+3, r26	; 0x03
     faa:	bc 83       	std	Y+4, r27	; 0x04
    /* Adjust for correct value. */
    ulCompareMatch -= ( unsigned portLONG ) 1;
     fac:	89 81       	ldd	r24, Y+1	; 0x01
     fae:	9a 81       	ldd	r25, Y+2	; 0x02
     fb0:	ab 81       	ldd	r26, Y+3	; 0x03
     fb2:	bc 81       	ldd	r27, Y+4	; 0x04
     fb4:	01 97       	sbiw	r24, 0x01	; 1
     fb6:	a1 09       	sbc	r26, r1
     fb8:	b1 09       	sbc	r27, r1
     fba:	89 83       	std	Y+1, r24	; 0x01
     fbc:	9a 83       	std	Y+2, r25	; 0x02
     fbe:	ab 83       	std	Y+3, r26	; 0x03
     fc0:	bc 83       	std	Y+4, r27	; 0x04
    //ulCompareMatch = (unsigned portLONG) 8639;
    /* Setup compare match value for compare match A.  Interrupts are disabled 
    before this is called so we need not worry here. */
    ucLowByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
     fc2:	89 81       	ldd	r24, Y+1	; 0x01
     fc4:	8d 83       	std	Y+5, r24	; 0x05
    ulCompareMatch >>= 8;
     fc6:	89 81       	ldd	r24, Y+1	; 0x01
     fc8:	9a 81       	ldd	r25, Y+2	; 0x02
     fca:	ab 81       	ldd	r26, Y+3	; 0x03
     fcc:	bc 81       	ldd	r27, Y+4	; 0x04
     fce:	89 2f       	mov	r24, r25
     fd0:	9a 2f       	mov	r25, r26
     fd2:	ab 2f       	mov	r26, r27
     fd4:	bb 27       	eor	r27, r27
     fd6:	89 83       	std	Y+1, r24	; 0x01
     fd8:	9a 83       	std	Y+2, r25	; 0x02
     fda:	ab 83       	std	Y+3, r26	; 0x03
     fdc:	bc 83       	std	Y+4, r27	; 0x04
    ucHighByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
     fde:	89 81       	ldd	r24, Y+1	; 0x01
     fe0:	8e 83       	std	Y+6, r24	; 0x06
    OCR1AH = ucHighByte;
     fe2:	89 e8       	ldi	r24, 0x89	; 137
     fe4:	90 e0       	ldi	r25, 0x00	; 0
     fe6:	2e 81       	ldd	r18, Y+6	; 0x06
     fe8:	fc 01       	movw	r30, r24
     fea:	20 83       	st	Z, r18
    OCR1AL = ucLowByte;
     fec:	88 e8       	ldi	r24, 0x88	; 136
     fee:	90 e0       	ldi	r25, 0x00	; 0
     ff0:	2d 81       	ldd	r18, Y+5	; 0x05
     ff2:	fc 01       	movw	r30, r24
     ff4:	20 83       	st	Z, r18
    /* Setup clock source and compare match behaviour. */
    ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
     ff6:	8b e0       	ldi	r24, 0x0B	; 11
     ff8:	8d 83       	std	Y+5, r24	; 0x05
    TCCR1B = ucLowByte;
     ffa:	81 e8       	ldi	r24, 0x81	; 129
     ffc:	90 e0       	ldi	r25, 0x00	; 0
     ffe:	2d 81       	ldd	r18, Y+5	; 0x05
    1000:	fc 01       	movw	r30, r24
    1002:	20 83       	st	Z, r18
    /* Enable the interrupt - this is okay as interrupt are currently globally
    disabled. */
    ucLowByte = TIMSK1;
    1004:	8f e6       	ldi	r24, 0x6F	; 111
    1006:	90 e0       	ldi	r25, 0x00	; 0
    1008:	fc 01       	movw	r30, r24
    100a:	80 81       	ld	r24, Z
    100c:	8d 83       	std	Y+5, r24	; 0x05
    ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    100e:	8d 81       	ldd	r24, Y+5	; 0x05
    1010:	82 60       	ori	r24, 0x02	; 2
    1012:	8d 83       	std	Y+5, r24	; 0x05
    TIMSK1 = ucLowByte;
    1014:	8f e6       	ldi	r24, 0x6F	; 111
    1016:	90 e0       	ldi	r25, 0x00	; 0
    1018:	2d 81       	ldd	r18, Y+5	; 0x05
    101a:	fc 01       	movw	r30, r24
    101c:	20 83       	st	Z, r18
}
    101e:	2a 96       	adiw	r28, 0x0a	; 10
    1020:	0f b6       	in	r0, 0x3f	; 63
    1022:	f8 94       	cli
    1024:	de bf       	out	0x3e, r29	; 62
    1026:	0f be       	out	0x3f, r0	; 63
    1028:	cd bf       	out	0x3d, r28	; 61
    102a:	df 91       	pop	r29
    102c:	cf 91       	pop	r28
    102e:	08 95       	ret

00001030 <__vector_11>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    1030:	0e 94 55 07 	call	0xeaa	; 0xeaa <vPortYieldFromTick>
		asm volatile ( "reti" );
    1034:	18 95       	reti

00001036 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1036:	cf 93       	push	r28
    1038:	df 93       	push	r29
    103a:	00 d0       	rcall	.+0      	; 0x103c <vListInitialise+0x6>
    103c:	cd b7       	in	r28, 0x3d	; 61
    103e:	de b7       	in	r29, 0x3e	; 62
    1040:	9a 83       	std	Y+2, r25	; 0x02
    1042:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1044:	89 81       	ldd	r24, Y+1	; 0x01
    1046:	9a 81       	ldd	r25, Y+2	; 0x02
    1048:	9c 01       	movw	r18, r24
    104a:	2d 5f       	subi	r18, 0xFD	; 253
    104c:	3f 4f       	sbci	r19, 0xFF	; 255
    104e:	89 81       	ldd	r24, Y+1	; 0x01
    1050:	9a 81       	ldd	r25, Y+2	; 0x02
    1052:	fc 01       	movw	r30, r24
    1054:	32 83       	std	Z+2, r19	; 0x02
    1056:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1058:	89 81       	ldd	r24, Y+1	; 0x01
    105a:	9a 81       	ldd	r25, Y+2	; 0x02
    105c:	2f ef       	ldi	r18, 0xFF	; 255
    105e:	3f ef       	ldi	r19, 0xFF	; 255
    1060:	fc 01       	movw	r30, r24
    1062:	34 83       	std	Z+4, r19	; 0x04
    1064:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1066:	89 81       	ldd	r24, Y+1	; 0x01
    1068:	9a 81       	ldd	r25, Y+2	; 0x02
    106a:	9c 01       	movw	r18, r24
    106c:	2d 5f       	subi	r18, 0xFD	; 253
    106e:	3f 4f       	sbci	r19, 0xFF	; 255
    1070:	89 81       	ldd	r24, Y+1	; 0x01
    1072:	9a 81       	ldd	r25, Y+2	; 0x02
    1074:	fc 01       	movw	r30, r24
    1076:	36 83       	std	Z+6, r19	; 0x06
    1078:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    107a:	89 81       	ldd	r24, Y+1	; 0x01
    107c:	9a 81       	ldd	r25, Y+2	; 0x02
    107e:	9c 01       	movw	r18, r24
    1080:	2d 5f       	subi	r18, 0xFD	; 253
    1082:	3f 4f       	sbci	r19, 0xFF	; 255
    1084:	89 81       	ldd	r24, Y+1	; 0x01
    1086:	9a 81       	ldd	r25, Y+2	; 0x02
    1088:	fc 01       	movw	r30, r24
    108a:	30 87       	std	Z+8, r19	; 0x08
    108c:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    108e:	89 81       	ldd	r24, Y+1	; 0x01
    1090:	9a 81       	ldd	r25, Y+2	; 0x02
    1092:	fc 01       	movw	r30, r24
    1094:	10 82       	st	Z, r1
}
    1096:	0f 90       	pop	r0
    1098:	0f 90       	pop	r0
    109a:	df 91       	pop	r29
    109c:	cf 91       	pop	r28
    109e:	08 95       	ret

000010a0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    10a0:	cf 93       	push	r28
    10a2:	df 93       	push	r29
    10a4:	00 d0       	rcall	.+0      	; 0x10a6 <vListInitialiseItem+0x6>
    10a6:	cd b7       	in	r28, 0x3d	; 61
    10a8:	de b7       	in	r29, 0x3e	; 62
    10aa:	9a 83       	std	Y+2, r25	; 0x02
    10ac:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    10ae:	89 81       	ldd	r24, Y+1	; 0x01
    10b0:	9a 81       	ldd	r25, Y+2	; 0x02
    10b2:	fc 01       	movw	r30, r24
    10b4:	11 86       	std	Z+9, r1	; 0x09
    10b6:	10 86       	std	Z+8, r1	; 0x08
}
    10b8:	0f 90       	pop	r0
    10ba:	0f 90       	pop	r0
    10bc:	df 91       	pop	r29
    10be:	cf 91       	pop	r28
    10c0:	08 95       	ret

000010c2 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    10c2:	cf 93       	push	r28
    10c4:	df 93       	push	r29
    10c6:	00 d0       	rcall	.+0      	; 0x10c8 <vListInsertEnd+0x6>
    10c8:	00 d0       	rcall	.+0      	; 0x10ca <vListInsertEnd+0x8>
    10ca:	00 d0       	rcall	.+0      	; 0x10cc <vListInsertEnd+0xa>
    10cc:	cd b7       	in	r28, 0x3d	; 61
    10ce:	de b7       	in	r29, 0x3e	; 62
    10d0:	9c 83       	std	Y+4, r25	; 0x04
    10d2:	8b 83       	std	Y+3, r24	; 0x03
    10d4:	7e 83       	std	Y+6, r23	; 0x06
    10d6:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    10d8:	8b 81       	ldd	r24, Y+3	; 0x03
    10da:	9c 81       	ldd	r25, Y+4	; 0x04
    10dc:	fc 01       	movw	r30, r24
    10de:	81 81       	ldd	r24, Z+1	; 0x01
    10e0:	92 81       	ldd	r25, Z+2	; 0x02
    10e2:	9a 83       	std	Y+2, r25	; 0x02
    10e4:	89 83       	std	Y+1, r24	; 0x01

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    10e6:	8d 81       	ldd	r24, Y+5	; 0x05
    10e8:	9e 81       	ldd	r25, Y+6	; 0x06
    10ea:	29 81       	ldd	r18, Y+1	; 0x01
    10ec:	3a 81       	ldd	r19, Y+2	; 0x02
    10ee:	fc 01       	movw	r30, r24
    10f0:	33 83       	std	Z+3, r19	; 0x03
    10f2:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    10f4:	89 81       	ldd	r24, Y+1	; 0x01
    10f6:	9a 81       	ldd	r25, Y+2	; 0x02
    10f8:	fc 01       	movw	r30, r24
    10fa:	24 81       	ldd	r18, Z+4	; 0x04
    10fc:	35 81       	ldd	r19, Z+5	; 0x05
    10fe:	8d 81       	ldd	r24, Y+5	; 0x05
    1100:	9e 81       	ldd	r25, Y+6	; 0x06
    1102:	fc 01       	movw	r30, r24
    1104:	35 83       	std	Z+5, r19	; 0x05
    1106:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1108:	89 81       	ldd	r24, Y+1	; 0x01
    110a:	9a 81       	ldd	r25, Y+2	; 0x02
    110c:	fc 01       	movw	r30, r24
    110e:	84 81       	ldd	r24, Z+4	; 0x04
    1110:	95 81       	ldd	r25, Z+5	; 0x05
    1112:	2d 81       	ldd	r18, Y+5	; 0x05
    1114:	3e 81       	ldd	r19, Y+6	; 0x06
    1116:	fc 01       	movw	r30, r24
    1118:	33 83       	std	Z+3, r19	; 0x03
    111a:	22 83       	std	Z+2, r18	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    111c:	89 81       	ldd	r24, Y+1	; 0x01
    111e:	9a 81       	ldd	r25, Y+2	; 0x02
    1120:	2d 81       	ldd	r18, Y+5	; 0x05
    1122:	3e 81       	ldd	r19, Y+6	; 0x06
    1124:	fc 01       	movw	r30, r24
    1126:	35 83       	std	Z+5, r19	; 0x05
    1128:	24 83       	std	Z+4, r18	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    112a:	8d 81       	ldd	r24, Y+5	; 0x05
    112c:	9e 81       	ldd	r25, Y+6	; 0x06
    112e:	2b 81       	ldd	r18, Y+3	; 0x03
    1130:	3c 81       	ldd	r19, Y+4	; 0x04
    1132:	fc 01       	movw	r30, r24
    1134:	31 87       	std	Z+9, r19	; 0x09
    1136:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1138:	8b 81       	ldd	r24, Y+3	; 0x03
    113a:	9c 81       	ldd	r25, Y+4	; 0x04
    113c:	fc 01       	movw	r30, r24
    113e:	80 81       	ld	r24, Z
    1140:	21 e0       	ldi	r18, 0x01	; 1
    1142:	28 0f       	add	r18, r24
    1144:	8b 81       	ldd	r24, Y+3	; 0x03
    1146:	9c 81       	ldd	r25, Y+4	; 0x04
    1148:	fc 01       	movw	r30, r24
    114a:	20 83       	st	Z, r18
}
    114c:	26 96       	adiw	r28, 0x06	; 6
    114e:	0f b6       	in	r0, 0x3f	; 63
    1150:	f8 94       	cli
    1152:	de bf       	out	0x3e, r29	; 62
    1154:	0f be       	out	0x3f, r0	; 63
    1156:	cd bf       	out	0x3d, r28	; 61
    1158:	df 91       	pop	r29
    115a:	cf 91       	pop	r28
    115c:	08 95       	ret

0000115e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    115e:	cf 93       	push	r28
    1160:	df 93       	push	r29
    1162:	cd b7       	in	r28, 0x3d	; 61
    1164:	de b7       	in	r29, 0x3e	; 62
    1166:	28 97       	sbiw	r28, 0x08	; 8
    1168:	0f b6       	in	r0, 0x3f	; 63
    116a:	f8 94       	cli
    116c:	de bf       	out	0x3e, r29	; 62
    116e:	0f be       	out	0x3f, r0	; 63
    1170:	cd bf       	out	0x3d, r28	; 61
    1172:	9e 83       	std	Y+6, r25	; 0x06
    1174:	8d 83       	std	Y+5, r24	; 0x05
    1176:	78 87       	std	Y+8, r23	; 0x08
    1178:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    117a:	8f 81       	ldd	r24, Y+7	; 0x07
    117c:	98 85       	ldd	r25, Y+8	; 0x08
    117e:	fc 01       	movw	r30, r24
    1180:	80 81       	ld	r24, Z
    1182:	91 81       	ldd	r25, Z+1	; 0x01
    1184:	9c 83       	std	Y+4, r25	; 0x04
    1186:	8b 83       	std	Y+3, r24	; 0x03
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1188:	8b 81       	ldd	r24, Y+3	; 0x03
    118a:	9c 81       	ldd	r25, Y+4	; 0x04
    118c:	8f 3f       	cpi	r24, 0xFF	; 255
    118e:	ff ef       	ldi	r31, 0xFF	; 255
    1190:	9f 07       	cpc	r25, r31
    1192:	41 f4       	brne	.+16     	; 0x11a4 <vListInsert+0x46>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1194:	8d 81       	ldd	r24, Y+5	; 0x05
    1196:	9e 81       	ldd	r25, Y+6	; 0x06
    1198:	fc 01       	movw	r30, r24
    119a:	87 81       	ldd	r24, Z+7	; 0x07
    119c:	90 85       	ldd	r25, Z+8	; 0x08
    119e:	9a 83       	std	Y+2, r25	; 0x02
    11a0:	89 83       	std	Y+1, r24	; 0x01
    11a2:	1a c0       	rjmp	.+52     	; 0x11d8 <vListInsert+0x7a>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    11a4:	8d 81       	ldd	r24, Y+5	; 0x05
    11a6:	9e 81       	ldd	r25, Y+6	; 0x06
    11a8:	03 96       	adiw	r24, 0x03	; 3
    11aa:	9a 83       	std	Y+2, r25	; 0x02
    11ac:	89 83       	std	Y+1, r24	; 0x01
    11ae:	07 c0       	rjmp	.+14     	; 0x11be <vListInsert+0x60>
    11b0:	89 81       	ldd	r24, Y+1	; 0x01
    11b2:	9a 81       	ldd	r25, Y+2	; 0x02
    11b4:	fc 01       	movw	r30, r24
    11b6:	82 81       	ldd	r24, Z+2	; 0x02
    11b8:	93 81       	ldd	r25, Z+3	; 0x03
    11ba:	9a 83       	std	Y+2, r25	; 0x02
    11bc:	89 83       	std	Y+1, r24	; 0x01
    11be:	89 81       	ldd	r24, Y+1	; 0x01
    11c0:	9a 81       	ldd	r25, Y+2	; 0x02
    11c2:	fc 01       	movw	r30, r24
    11c4:	82 81       	ldd	r24, Z+2	; 0x02
    11c6:	93 81       	ldd	r25, Z+3	; 0x03
    11c8:	fc 01       	movw	r30, r24
    11ca:	20 81       	ld	r18, Z
    11cc:	31 81       	ldd	r19, Z+1	; 0x01
    11ce:	8b 81       	ldd	r24, Y+3	; 0x03
    11d0:	9c 81       	ldd	r25, Y+4	; 0x04
    11d2:	82 17       	cp	r24, r18
    11d4:	93 07       	cpc	r25, r19
    11d6:	60 f7       	brcc	.-40     	; 0x11b0 <vListInsert+0x52>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    11d8:	89 81       	ldd	r24, Y+1	; 0x01
    11da:	9a 81       	ldd	r25, Y+2	; 0x02
    11dc:	fc 01       	movw	r30, r24
    11de:	22 81       	ldd	r18, Z+2	; 0x02
    11e0:	33 81       	ldd	r19, Z+3	; 0x03
    11e2:	8f 81       	ldd	r24, Y+7	; 0x07
    11e4:	98 85       	ldd	r25, Y+8	; 0x08
    11e6:	fc 01       	movw	r30, r24
    11e8:	33 83       	std	Z+3, r19	; 0x03
    11ea:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    11ec:	8f 81       	ldd	r24, Y+7	; 0x07
    11ee:	98 85       	ldd	r25, Y+8	; 0x08
    11f0:	fc 01       	movw	r30, r24
    11f2:	82 81       	ldd	r24, Z+2	; 0x02
    11f4:	93 81       	ldd	r25, Z+3	; 0x03
    11f6:	2f 81       	ldd	r18, Y+7	; 0x07
    11f8:	38 85       	ldd	r19, Y+8	; 0x08
    11fa:	fc 01       	movw	r30, r24
    11fc:	35 83       	std	Z+5, r19	; 0x05
    11fe:	24 83       	std	Z+4, r18	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1200:	8f 81       	ldd	r24, Y+7	; 0x07
    1202:	98 85       	ldd	r25, Y+8	; 0x08
    1204:	29 81       	ldd	r18, Y+1	; 0x01
    1206:	3a 81       	ldd	r19, Y+2	; 0x02
    1208:	fc 01       	movw	r30, r24
    120a:	35 83       	std	Z+5, r19	; 0x05
    120c:	24 83       	std	Z+4, r18	; 0x04
	pxIterator->pxNext = pxNewListItem;
    120e:	89 81       	ldd	r24, Y+1	; 0x01
    1210:	9a 81       	ldd	r25, Y+2	; 0x02
    1212:	2f 81       	ldd	r18, Y+7	; 0x07
    1214:	38 85       	ldd	r19, Y+8	; 0x08
    1216:	fc 01       	movw	r30, r24
    1218:	33 83       	std	Z+3, r19	; 0x03
    121a:	22 83       	std	Z+2, r18	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    121c:	8f 81       	ldd	r24, Y+7	; 0x07
    121e:	98 85       	ldd	r25, Y+8	; 0x08
    1220:	2d 81       	ldd	r18, Y+5	; 0x05
    1222:	3e 81       	ldd	r19, Y+6	; 0x06
    1224:	fc 01       	movw	r30, r24
    1226:	31 87       	std	Z+9, r19	; 0x09
    1228:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    122a:	8d 81       	ldd	r24, Y+5	; 0x05
    122c:	9e 81       	ldd	r25, Y+6	; 0x06
    122e:	fc 01       	movw	r30, r24
    1230:	80 81       	ld	r24, Z
    1232:	21 e0       	ldi	r18, 0x01	; 1
    1234:	28 0f       	add	r18, r24
    1236:	8d 81       	ldd	r24, Y+5	; 0x05
    1238:	9e 81       	ldd	r25, Y+6	; 0x06
    123a:	fc 01       	movw	r30, r24
    123c:	20 83       	st	Z, r18
}
    123e:	28 96       	adiw	r28, 0x08	; 8
    1240:	0f b6       	in	r0, 0x3f	; 63
    1242:	f8 94       	cli
    1244:	de bf       	out	0x3e, r29	; 62
    1246:	0f be       	out	0x3f, r0	; 63
    1248:	cd bf       	out	0x3d, r28	; 61
    124a:	df 91       	pop	r29
    124c:	cf 91       	pop	r28
    124e:	08 95       	ret

00001250 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1250:	cf 93       	push	r28
    1252:	df 93       	push	r29
    1254:	00 d0       	rcall	.+0      	; 0x1256 <uxListRemove+0x6>
    1256:	00 d0       	rcall	.+0      	; 0x1258 <uxListRemove+0x8>
    1258:	cd b7       	in	r28, 0x3d	; 61
    125a:	de b7       	in	r29, 0x3e	; 62
    125c:	9c 83       	std	Y+4, r25	; 0x04
    125e:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    1260:	8b 81       	ldd	r24, Y+3	; 0x03
    1262:	9c 81       	ldd	r25, Y+4	; 0x04
    1264:	fc 01       	movw	r30, r24
    1266:	80 85       	ldd	r24, Z+8	; 0x08
    1268:	91 85       	ldd	r25, Z+9	; 0x09
    126a:	9a 83       	std	Y+2, r25	; 0x02
    126c:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    126e:	8b 81       	ldd	r24, Y+3	; 0x03
    1270:	9c 81       	ldd	r25, Y+4	; 0x04
    1272:	fc 01       	movw	r30, r24
    1274:	82 81       	ldd	r24, Z+2	; 0x02
    1276:	93 81       	ldd	r25, Z+3	; 0x03
    1278:	2b 81       	ldd	r18, Y+3	; 0x03
    127a:	3c 81       	ldd	r19, Y+4	; 0x04
    127c:	f9 01       	movw	r30, r18
    127e:	24 81       	ldd	r18, Z+4	; 0x04
    1280:	35 81       	ldd	r19, Z+5	; 0x05
    1282:	fc 01       	movw	r30, r24
    1284:	35 83       	std	Z+5, r19	; 0x05
    1286:	24 83       	std	Z+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1288:	8b 81       	ldd	r24, Y+3	; 0x03
    128a:	9c 81       	ldd	r25, Y+4	; 0x04
    128c:	fc 01       	movw	r30, r24
    128e:	84 81       	ldd	r24, Z+4	; 0x04
    1290:	95 81       	ldd	r25, Z+5	; 0x05
    1292:	2b 81       	ldd	r18, Y+3	; 0x03
    1294:	3c 81       	ldd	r19, Y+4	; 0x04
    1296:	f9 01       	movw	r30, r18
    1298:	22 81       	ldd	r18, Z+2	; 0x02
    129a:	33 81       	ldd	r19, Z+3	; 0x03
    129c:	fc 01       	movw	r30, r24
    129e:	33 83       	std	Z+3, r19	; 0x03
    12a0:	22 83       	std	Z+2, r18	; 0x02

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    12a2:	89 81       	ldd	r24, Y+1	; 0x01
    12a4:	9a 81       	ldd	r25, Y+2	; 0x02
    12a6:	fc 01       	movw	r30, r24
    12a8:	21 81       	ldd	r18, Z+1	; 0x01
    12aa:	32 81       	ldd	r19, Z+2	; 0x02
    12ac:	8b 81       	ldd	r24, Y+3	; 0x03
    12ae:	9c 81       	ldd	r25, Y+4	; 0x04
    12b0:	28 17       	cp	r18, r24
    12b2:	39 07       	cpc	r19, r25
    12b4:	51 f4       	brne	.+20     	; 0x12ca <uxListRemove+0x7a>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    12b6:	8b 81       	ldd	r24, Y+3	; 0x03
    12b8:	9c 81       	ldd	r25, Y+4	; 0x04
    12ba:	fc 01       	movw	r30, r24
    12bc:	24 81       	ldd	r18, Z+4	; 0x04
    12be:	35 81       	ldd	r19, Z+5	; 0x05
    12c0:	89 81       	ldd	r24, Y+1	; 0x01
    12c2:	9a 81       	ldd	r25, Y+2	; 0x02
    12c4:	fc 01       	movw	r30, r24
    12c6:	32 83       	std	Z+2, r19	; 0x02
    12c8:	21 83       	std	Z+1, r18	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    12ca:	8b 81       	ldd	r24, Y+3	; 0x03
    12cc:	9c 81       	ldd	r25, Y+4	; 0x04
    12ce:	fc 01       	movw	r30, r24
    12d0:	11 86       	std	Z+9, r1	; 0x09
    12d2:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    12d4:	89 81       	ldd	r24, Y+1	; 0x01
    12d6:	9a 81       	ldd	r25, Y+2	; 0x02
    12d8:	fc 01       	movw	r30, r24
    12da:	80 81       	ld	r24, Z
    12dc:	2f ef       	ldi	r18, 0xFF	; 255
    12de:	28 0f       	add	r18, r24
    12e0:	89 81       	ldd	r24, Y+1	; 0x01
    12e2:	9a 81       	ldd	r25, Y+2	; 0x02
    12e4:	fc 01       	movw	r30, r24
    12e6:	20 83       	st	Z, r18

	return pxList->uxNumberOfItems;
    12e8:	89 81       	ldd	r24, Y+1	; 0x01
    12ea:	9a 81       	ldd	r25, Y+2	; 0x02
    12ec:	fc 01       	movw	r30, r24
    12ee:	80 81       	ld	r24, Z
}
    12f0:	0f 90       	pop	r0
    12f2:	0f 90       	pop	r0
    12f4:	0f 90       	pop	r0
    12f6:	0f 90       	pop	r0
    12f8:	df 91       	pop	r29
    12fa:	cf 91       	pop	r28
    12fc:	08 95       	ret

000012fe <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    12fe:	cf 93       	push	r28
    1300:	df 93       	push	r29
    1302:	00 d0       	rcall	.+0      	; 0x1304 <xQueueGenericReset+0x6>
    1304:	00 d0       	rcall	.+0      	; 0x1306 <xQueueGenericReset+0x8>
    1306:	1f 92       	push	r1
    1308:	cd b7       	in	r28, 0x3d	; 61
    130a:	de b7       	in	r29, 0x3e	; 62
    130c:	9c 83       	std	Y+4, r25	; 0x04
    130e:	8b 83       	std	Y+3, r24	; 0x03
    1310:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1312:	8b 81       	ldd	r24, Y+3	; 0x03
    1314:	9c 81       	ldd	r25, Y+4	; 0x04
    1316:	9a 83       	std	Y+2, r25	; 0x02
    1318:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    131a:	0f b6       	in	r0, 0x3f	; 63
    131c:	f8 94       	cli
    131e:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1320:	89 81       	ldd	r24, Y+1	; 0x01
    1322:	9a 81       	ldd	r25, Y+2	; 0x02
    1324:	fc 01       	movw	r30, r24
    1326:	20 81       	ld	r18, Z
    1328:	31 81       	ldd	r19, Z+1	; 0x01
    132a:	89 81       	ldd	r24, Y+1	; 0x01
    132c:	9a 81       	ldd	r25, Y+2	; 0x02
    132e:	fc 01       	movw	r30, r24
    1330:	83 8d       	ldd	r24, Z+27	; 0x1b
    1332:	68 2f       	mov	r22, r24
    1334:	70 e0       	ldi	r23, 0x00	; 0
    1336:	89 81       	ldd	r24, Y+1	; 0x01
    1338:	9a 81       	ldd	r25, Y+2	; 0x02
    133a:	fc 01       	movw	r30, r24
    133c:	84 8d       	ldd	r24, Z+28	; 0x1c
    133e:	48 2f       	mov	r20, r24
    1340:	50 e0       	ldi	r21, 0x00	; 0
    1342:	64 9f       	mul	r22, r20
    1344:	c0 01       	movw	r24, r0
    1346:	65 9f       	mul	r22, r21
    1348:	90 0d       	add	r25, r0
    134a:	74 9f       	mul	r23, r20
    134c:	90 0d       	add	r25, r0
    134e:	11 24       	eor	r1, r1
    1350:	28 0f       	add	r18, r24
    1352:	39 1f       	adc	r19, r25
    1354:	89 81       	ldd	r24, Y+1	; 0x01
    1356:	9a 81       	ldd	r25, Y+2	; 0x02
    1358:	fc 01       	movw	r30, r24
    135a:	33 83       	std	Z+3, r19	; 0x03
    135c:	22 83       	std	Z+2, r18	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    135e:	89 81       	ldd	r24, Y+1	; 0x01
    1360:	9a 81       	ldd	r25, Y+2	; 0x02
    1362:	fc 01       	movw	r30, r24
    1364:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1366:	89 81       	ldd	r24, Y+1	; 0x01
    1368:	9a 81       	ldd	r25, Y+2	; 0x02
    136a:	fc 01       	movw	r30, r24
    136c:	20 81       	ld	r18, Z
    136e:	31 81       	ldd	r19, Z+1	; 0x01
    1370:	89 81       	ldd	r24, Y+1	; 0x01
    1372:	9a 81       	ldd	r25, Y+2	; 0x02
    1374:	fc 01       	movw	r30, r24
    1376:	35 83       	std	Z+5, r19	; 0x05
    1378:	24 83       	std	Z+4, r18	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
    137a:	89 81       	ldd	r24, Y+1	; 0x01
    137c:	9a 81       	ldd	r25, Y+2	; 0x02
    137e:	fc 01       	movw	r30, r24
    1380:	20 81       	ld	r18, Z
    1382:	31 81       	ldd	r19, Z+1	; 0x01
    1384:	89 81       	ldd	r24, Y+1	; 0x01
    1386:	9a 81       	ldd	r25, Y+2	; 0x02
    1388:	fc 01       	movw	r30, r24
    138a:	83 8d       	ldd	r24, Z+27	; 0x1b
    138c:	88 2f       	mov	r24, r24
    138e:	90 e0       	ldi	r25, 0x00	; 0
    1390:	bc 01       	movw	r22, r24
    1392:	61 50       	subi	r22, 0x01	; 1
    1394:	71 09       	sbc	r23, r1
    1396:	89 81       	ldd	r24, Y+1	; 0x01
    1398:	9a 81       	ldd	r25, Y+2	; 0x02
    139a:	fc 01       	movw	r30, r24
    139c:	84 8d       	ldd	r24, Z+28	; 0x1c
    139e:	48 2f       	mov	r20, r24
    13a0:	50 e0       	ldi	r21, 0x00	; 0
    13a2:	64 9f       	mul	r22, r20
    13a4:	c0 01       	movw	r24, r0
    13a6:	65 9f       	mul	r22, r21
    13a8:	90 0d       	add	r25, r0
    13aa:	74 9f       	mul	r23, r20
    13ac:	90 0d       	add	r25, r0
    13ae:	11 24       	eor	r1, r1
    13b0:	28 0f       	add	r18, r24
    13b2:	39 1f       	adc	r19, r25
    13b4:	89 81       	ldd	r24, Y+1	; 0x01
    13b6:	9a 81       	ldd	r25, Y+2	; 0x02
    13b8:	fc 01       	movw	r30, r24
    13ba:	37 83       	std	Z+7, r19	; 0x07
    13bc:	26 83       	std	Z+6, r18	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    13be:	89 81       	ldd	r24, Y+1	; 0x01
    13c0:	9a 81       	ldd	r25, Y+2	; 0x02
    13c2:	2f ef       	ldi	r18, 0xFF	; 255
    13c4:	fc 01       	movw	r30, r24
    13c6:	25 8f       	std	Z+29, r18	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    13c8:	89 81       	ldd	r24, Y+1	; 0x01
    13ca:	9a 81       	ldd	r25, Y+2	; 0x02
    13cc:	2f ef       	ldi	r18, 0xFF	; 255
    13ce:	fc 01       	movw	r30, r24
    13d0:	26 8f       	std	Z+30, r18	; 0x1e

		if( xNewQueue == pdFALSE )
    13d2:	8d 81       	ldd	r24, Y+5	; 0x05
    13d4:	88 23       	and	r24, r24
    13d6:	81 f4       	brne	.+32     	; 0x13f8 <xQueueGenericReset+0xfa>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    13d8:	89 81       	ldd	r24, Y+1	; 0x01
    13da:	9a 81       	ldd	r25, Y+2	; 0x02
    13dc:	fc 01       	movw	r30, r24
    13de:	80 85       	ldd	r24, Z+8	; 0x08
    13e0:	88 23       	and	r24, r24
    13e2:	a1 f0       	breq	.+40     	; 0x140c <xQueueGenericReset+0x10e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    13e4:	89 81       	ldd	r24, Y+1	; 0x01
    13e6:	9a 81       	ldd	r25, Y+2	; 0x02
    13e8:	08 96       	adiw	r24, 0x08	; 8
    13ea:	0e 94 e0 13 	call	0x27c0	; 0x27c0 <xTaskRemoveFromEventList>
    13ee:	81 30       	cpi	r24, 0x01	; 1
    13f0:	69 f4       	brne	.+26     	; 0x140c <xQueueGenericReset+0x10e>
				{
					queueYIELD_IF_USING_PREEMPTION();
    13f2:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vPortYield>
    13f6:	0a c0       	rjmp	.+20     	; 0x140c <xQueueGenericReset+0x10e>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    13f8:	89 81       	ldd	r24, Y+1	; 0x01
    13fa:	9a 81       	ldd	r25, Y+2	; 0x02
    13fc:	08 96       	adiw	r24, 0x08	; 8
    13fe:	0e 94 1b 08 	call	0x1036	; 0x1036 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1402:	89 81       	ldd	r24, Y+1	; 0x01
    1404:	9a 81       	ldd	r25, Y+2	; 0x02
    1406:	41 96       	adiw	r24, 0x11	; 17
    1408:	0e 94 1b 08 	call	0x1036	; 0x1036 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    140c:	0f 90       	pop	r0
    140e:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    1410:	81 e0       	ldi	r24, 0x01	; 1
}
    1412:	0f 90       	pop	r0
    1414:	0f 90       	pop	r0
    1416:	0f 90       	pop	r0
    1418:	0f 90       	pop	r0
    141a:	0f 90       	pop	r0
    141c:	df 91       	pop	r29
    141e:	cf 91       	pop	r28
    1420:	08 95       	ret

00001422 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
    1422:	cf 93       	push	r28
    1424:	df 93       	push	r29
    1426:	cd b7       	in	r28, 0x3d	; 61
    1428:	de b7       	in	r29, 0x3e	; 62
    142a:	29 97       	sbiw	r28, 0x09	; 9
    142c:	0f b6       	in	r0, 0x3f	; 63
    142e:	f8 94       	cli
    1430:	de bf       	out	0x3e, r29	; 62
    1432:	0f be       	out	0x3f, r0	; 63
    1434:	cd bf       	out	0x3d, r28	; 61
    1436:	8f 83       	std	Y+7, r24	; 0x07
    1438:	68 87       	std	Y+8, r22	; 0x08
    143a:	49 87       	std	Y+9, r20	; 0x09
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
    143c:	1a 82       	std	Y+2, r1	; 0x02
    143e:	19 82       	std	Y+1, r1	; 0x01
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
    1440:	8f 81       	ldd	r24, Y+7	; 0x07
    1442:	88 23       	and	r24, r24
    1444:	09 f4       	brne	.+2      	; 0x1448 <xQueueGenericCreate+0x26>
    1446:	43 c0       	rjmp	.+134    	; 0x14ce <xQueueGenericCreate+0xac>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    1448:	8f e1       	ldi	r24, 0x1F	; 31
    144a:	90 e0       	ldi	r25, 0x00	; 0
    144c:	0e 94 bc 04 	call	0x978	; 0x978 <pvPortMalloc>
    1450:	9c 83       	std	Y+4, r25	; 0x04
    1452:	8b 83       	std	Y+3, r24	; 0x03
		if( pxNewQueue != NULL )
    1454:	8b 81       	ldd	r24, Y+3	; 0x03
    1456:	9c 81       	ldd	r25, Y+4	; 0x04
    1458:	00 97       	sbiw	r24, 0x00	; 0
    145a:	c9 f1       	breq	.+114    	; 0x14ce <xQueueGenericCreate+0xac>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    145c:	8f 81       	ldd	r24, Y+7	; 0x07
    145e:	48 2f       	mov	r20, r24
    1460:	50 e0       	ldi	r21, 0x00	; 0
    1462:	88 85       	ldd	r24, Y+8	; 0x08
    1464:	28 2f       	mov	r18, r24
    1466:	30 e0       	ldi	r19, 0x00	; 0
    1468:	42 9f       	mul	r20, r18
    146a:	c0 01       	movw	r24, r0
    146c:	43 9f       	mul	r20, r19
    146e:	90 0d       	add	r25, r0
    1470:	52 9f       	mul	r21, r18
    1472:	90 0d       	add	r25, r0
    1474:	11 24       	eor	r1, r1
    1476:	01 96       	adiw	r24, 0x01	; 1
    1478:	9e 83       	std	Y+6, r25	; 0x06
    147a:	8d 83       	std	Y+5, r24	; 0x05

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
    147c:	8d 81       	ldd	r24, Y+5	; 0x05
    147e:	9e 81       	ldd	r25, Y+6	; 0x06
    1480:	0e 94 bc 04 	call	0x978	; 0x978 <pvPortMalloc>
    1484:	9c 01       	movw	r18, r24
    1486:	8b 81       	ldd	r24, Y+3	; 0x03
    1488:	9c 81       	ldd	r25, Y+4	; 0x04
    148a:	fc 01       	movw	r30, r24
    148c:	31 83       	std	Z+1, r19	; 0x01
    148e:	20 83       	st	Z, r18
			if( pxNewQueue->pcHead != NULL )
    1490:	8b 81       	ldd	r24, Y+3	; 0x03
    1492:	9c 81       	ldd	r25, Y+4	; 0x04
    1494:	fc 01       	movw	r30, r24
    1496:	80 81       	ld	r24, Z
    1498:	91 81       	ldd	r25, Z+1	; 0x01
    149a:	00 97       	sbiw	r24, 0x00	; 0
    149c:	a1 f0       	breq	.+40     	; 0x14c6 <xQueueGenericCreate+0xa4>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    149e:	8b 81       	ldd	r24, Y+3	; 0x03
    14a0:	9c 81       	ldd	r25, Y+4	; 0x04
    14a2:	2f 81       	ldd	r18, Y+7	; 0x07
    14a4:	fc 01       	movw	r30, r24
    14a6:	23 8f       	std	Z+27, r18	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    14a8:	8b 81       	ldd	r24, Y+3	; 0x03
    14aa:	9c 81       	ldd	r25, Y+4	; 0x04
    14ac:	28 85       	ldd	r18, Y+8	; 0x08
    14ae:	fc 01       	movw	r30, r24
    14b0:	24 8f       	std	Z+28, r18	; 0x1c
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    14b2:	8b 81       	ldd	r24, Y+3	; 0x03
    14b4:	9c 81       	ldd	r25, Y+4	; 0x04
    14b6:	61 e0       	ldi	r22, 0x01	; 1
    14b8:	0e 94 7f 09 	call	0x12fe	; 0x12fe <xQueueGenericReset>
					pxNewQueue->pxQueueSetContainer = NULL;
				}
				#endif /* configUSE_QUEUE_SETS */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    14bc:	8b 81       	ldd	r24, Y+3	; 0x03
    14be:	9c 81       	ldd	r25, Y+4	; 0x04
    14c0:	9a 83       	std	Y+2, r25	; 0x02
    14c2:	89 83       	std	Y+1, r24	; 0x01
    14c4:	04 c0       	rjmp	.+8      	; 0x14ce <xQueueGenericCreate+0xac>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    14c6:	8b 81       	ldd	r24, Y+3	; 0x03
    14c8:	9c 81       	ldd	r25, Y+4	; 0x04
    14ca:	0e 94 12 05 	call	0xa24	; 0xa24 <vPortFree>
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );

	return xReturn;
    14ce:	89 81       	ldd	r24, Y+1	; 0x01
    14d0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    14d2:	29 96       	adiw	r28, 0x09	; 9
    14d4:	0f b6       	in	r0, 0x3f	; 63
    14d6:	f8 94       	cli
    14d8:	de bf       	out	0x3e, r29	; 62
    14da:	0f be       	out	0x3f, r0	; 63
    14dc:	cd bf       	out	0x3d, r28	; 61
    14de:	df 91       	pop	r29
    14e0:	cf 91       	pop	r28
    14e2:	08 95       	ret

000014e4 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    14e4:	cf 93       	push	r28
    14e6:	df 93       	push	r29
    14e8:	cd b7       	in	r28, 0x3d	; 61
    14ea:	de b7       	in	r29, 0x3e	; 62
    14ec:	2e 97       	sbiw	r28, 0x0e	; 14
    14ee:	0f b6       	in	r0, 0x3f	; 63
    14f0:	f8 94       	cli
    14f2:	de bf       	out	0x3e, r29	; 62
    14f4:	0f be       	out	0x3f, r0	; 63
    14f6:	cd bf       	out	0x3d, r28	; 61
    14f8:	99 87       	std	Y+9, r25	; 0x09
    14fa:	88 87       	std	Y+8, r24	; 0x08
    14fc:	7b 87       	std	Y+11, r23	; 0x0b
    14fe:	6a 87       	std	Y+10, r22	; 0x0a
    1500:	5d 87       	std	Y+13, r21	; 0x0d
    1502:	4c 87       	std	Y+12, r20	; 0x0c
    1504:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1506:	19 82       	std	Y+1, r1	; 0x01
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1508:	88 85       	ldd	r24, Y+8	; 0x08
    150a:	99 85       	ldd	r25, Y+9	; 0x09
    150c:	9b 83       	std	Y+3, r25	; 0x03
    150e:	8a 83       	std	Y+2, r24	; 0x02
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1510:	0f b6       	in	r0, 0x3f	; 63
    1512:	f8 94       	cli
    1514:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1516:	8a 81       	ldd	r24, Y+2	; 0x02
    1518:	9b 81       	ldd	r25, Y+3	; 0x03
    151a:	fc 01       	movw	r30, r24
    151c:	22 8d       	ldd	r18, Z+26	; 0x1a
    151e:	8a 81       	ldd	r24, Y+2	; 0x02
    1520:	9b 81       	ldd	r25, Y+3	; 0x03
    1522:	fc 01       	movw	r30, r24
    1524:	83 8d       	ldd	r24, Z+27	; 0x1b
    1526:	28 17       	cp	r18, r24
    1528:	18 f0       	brcs	.+6      	; 0x1530 <xQueueGenericSend+0x4c>
    152a:	8e 85       	ldd	r24, Y+14	; 0x0e
    152c:	82 30       	cpi	r24, 0x02	; 2
    152e:	11 f5       	brne	.+68     	; 0x1574 <xQueueGenericSend+0x90>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1530:	2a 85       	ldd	r18, Y+10	; 0x0a
    1532:	3b 85       	ldd	r19, Y+11	; 0x0b
    1534:	8a 81       	ldd	r24, Y+2	; 0x02
    1536:	9b 81       	ldd	r25, Y+3	; 0x03
    1538:	4e 85       	ldd	r20, Y+14	; 0x0e
    153a:	b9 01       	movw	r22, r18
    153c:	0e 94 bf 0c 	call	0x197e	; 0x197e <prvCopyDataToQueue>
    1540:	8c 83       	std	Y+4, r24	; 0x04
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1542:	8a 81       	ldd	r24, Y+2	; 0x02
    1544:	9b 81       	ldd	r25, Y+3	; 0x03
    1546:	fc 01       	movw	r30, r24
    1548:	81 89       	ldd	r24, Z+17	; 0x11
    154a:	88 23       	and	r24, r24
    154c:	51 f0       	breq	.+20     	; 0x1562 <xQueueGenericSend+0x7e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    154e:	8a 81       	ldd	r24, Y+2	; 0x02
    1550:	9b 81       	ldd	r25, Y+3	; 0x03
    1552:	41 96       	adiw	r24, 0x11	; 17
    1554:	0e 94 e0 13 	call	0x27c0	; 0x27c0 <xTaskRemoveFromEventList>
    1558:	81 30       	cpi	r24, 0x01	; 1
    155a:	41 f4       	brne	.+16     	; 0x156c <xQueueGenericSend+0x88>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    155c:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vPortYield>
    1560:	05 c0       	rjmp	.+10     	; 0x156c <xQueueGenericSend+0x88>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1562:	8c 81       	ldd	r24, Y+4	; 0x04
    1564:	88 23       	and	r24, r24
    1566:	11 f0       	breq	.+4      	; 0x156c <xQueueGenericSend+0x88>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1568:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    156c:	0f 90       	pop	r0
    156e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1570:	81 e0       	ldi	r24, 0x01	; 1
    1572:	61 c0       	rjmp	.+194    	; 0x1636 <xQueueGenericSend+0x152>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1574:	8c 85       	ldd	r24, Y+12	; 0x0c
    1576:	9d 85       	ldd	r25, Y+13	; 0x0d
    1578:	00 97       	sbiw	r24, 0x00	; 0
    157a:	21 f4       	brne	.+8      	; 0x1584 <xQueueGenericSend+0xa0>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    157c:	0f 90       	pop	r0
    157e:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1580:	80 e0       	ldi	r24, 0x00	; 0
    1582:	59 c0       	rjmp	.+178    	; 0x1636 <xQueueGenericSend+0x152>
				}
				else if( xEntryTimeSet == pdFALSE )
    1584:	89 81       	ldd	r24, Y+1	; 0x01
    1586:	88 23       	and	r24, r24
    1588:	31 f4       	brne	.+12     	; 0x1596 <xQueueGenericSend+0xb2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    158a:	ce 01       	movw	r24, r28
    158c:	05 96       	adiw	r24, 0x05	; 5
    158e:	0e 94 4d 14 	call	0x289a	; 0x289a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1592:	81 e0       	ldi	r24, 0x01	; 1
    1594:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1596:	0f 90       	pop	r0
    1598:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    159a:	0e 94 84 11 	call	0x2308	; 0x2308 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    159e:	0f b6       	in	r0, 0x3f	; 63
    15a0:	f8 94       	cli
    15a2:	0f 92       	push	r0
    15a4:	8a 81       	ldd	r24, Y+2	; 0x02
    15a6:	9b 81       	ldd	r25, Y+3	; 0x03
    15a8:	fc 01       	movw	r30, r24
    15aa:	85 8d       	ldd	r24, Z+29	; 0x1d
    15ac:	8f 3f       	cpi	r24, 0xFF	; 255
    15ae:	21 f4       	brne	.+8      	; 0x15b8 <xQueueGenericSend+0xd4>
    15b0:	8a 81       	ldd	r24, Y+2	; 0x02
    15b2:	9b 81       	ldd	r25, Y+3	; 0x03
    15b4:	fc 01       	movw	r30, r24
    15b6:	15 8e       	std	Z+29, r1	; 0x1d
    15b8:	8a 81       	ldd	r24, Y+2	; 0x02
    15ba:	9b 81       	ldd	r25, Y+3	; 0x03
    15bc:	fc 01       	movw	r30, r24
    15be:	86 8d       	ldd	r24, Z+30	; 0x1e
    15c0:	8f 3f       	cpi	r24, 0xFF	; 255
    15c2:	21 f4       	brne	.+8      	; 0x15cc <xQueueGenericSend+0xe8>
    15c4:	8a 81       	ldd	r24, Y+2	; 0x02
    15c6:	9b 81       	ldd	r25, Y+3	; 0x03
    15c8:	fc 01       	movw	r30, r24
    15ca:	16 8e       	std	Z+30, r1	; 0x1e
    15cc:	0f 90       	pop	r0
    15ce:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    15d0:	9e 01       	movw	r18, r28
    15d2:	24 5f       	subi	r18, 0xF4	; 244
    15d4:	3f 4f       	sbci	r19, 0xFF	; 255
    15d6:	ce 01       	movw	r24, r28
    15d8:	05 96       	adiw	r24, 0x05	; 5
    15da:	b9 01       	movw	r22, r18
    15dc:	0e 94 68 14 	call	0x28d0	; 0x28d0 <xTaskCheckForTimeOut>
    15e0:	88 23       	and	r24, r24
    15e2:	01 f5       	brne	.+64     	; 0x1624 <xQueueGenericSend+0x140>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    15e4:	8a 81       	ldd	r24, Y+2	; 0x02
    15e6:	9b 81       	ldd	r25, Y+3	; 0x03
    15e8:	0e 94 51 0e 	call	0x1ca2	; 0x1ca2 <prvIsQueueFull>
    15ec:	88 23       	and	r24, r24
    15ee:	99 f0       	breq	.+38     	; 0x1616 <xQueueGenericSend+0x132>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    15f0:	2c 85       	ldd	r18, Y+12	; 0x0c
    15f2:	3d 85       	ldd	r19, Y+13	; 0x0d
    15f4:	8a 81       	ldd	r24, Y+2	; 0x02
    15f6:	9b 81       	ldd	r25, Y+3	; 0x03
    15f8:	08 96       	adiw	r24, 0x08	; 8
    15fa:	b9 01       	movw	r22, r18
    15fc:	0e 94 9a 13 	call	0x2734	; 0x2734 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1600:	8a 81       	ldd	r24, Y+2	; 0x02
    1602:	9b 81       	ldd	r25, Y+3	; 0x03
    1604:	0e 94 cf 0d 	call	0x1b9e	; 0x1b9e <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1608:	0e 94 90 11 	call	0x2320	; 0x2320 <xTaskResumeAll>
    160c:	88 23       	and	r24, r24
    160e:	91 f4       	brne	.+36     	; 0x1634 <xQueueGenericSend+0x150>
				{
					portYIELD_WITHIN_API();
    1610:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vPortYield>
    1614:	0f c0       	rjmp	.+30     	; 0x1634 <xQueueGenericSend+0x150>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1616:	8a 81       	ldd	r24, Y+2	; 0x02
    1618:	9b 81       	ldd	r25, Y+3	; 0x03
    161a:	0e 94 cf 0d 	call	0x1b9e	; 0x1b9e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    161e:	0e 94 90 11 	call	0x2320	; 0x2320 <xTaskResumeAll>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
    1622:	76 cf       	rjmp	.-276    	; 0x1510 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1624:	8a 81       	ldd	r24, Y+2	; 0x02
    1626:	9b 81       	ldd	r25, Y+3	; 0x03
    1628:	0e 94 cf 0d 	call	0x1b9e	; 0x1b9e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    162c:	0e 94 90 11 	call	0x2320	; 0x2320 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1630:	80 e0       	ldi	r24, 0x00	; 0
    1632:	01 c0       	rjmp	.+2      	; 0x1636 <xQueueGenericSend+0x152>
		}
	}
    1634:	6d cf       	rjmp	.-294    	; 0x1510 <xQueueGenericSend+0x2c>
}
    1636:	2e 96       	adiw	r28, 0x0e	; 14
    1638:	0f b6       	in	r0, 0x3f	; 63
    163a:	f8 94       	cli
    163c:	de bf       	out	0x3e, r29	; 62
    163e:	0f be       	out	0x3f, r0	; 63
    1640:	cd bf       	out	0x3d, r28	; 61
    1642:	df 91       	pop	r29
    1644:	cf 91       	pop	r28
    1646:	08 95       	ret

00001648 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    1648:	cf 93       	push	r28
    164a:	df 93       	push	r29
    164c:	cd b7       	in	r28, 0x3d	; 61
    164e:	de b7       	in	r29, 0x3e	; 62
    1650:	2b 97       	sbiw	r28, 0x0b	; 11
    1652:	0f b6       	in	r0, 0x3f	; 63
    1654:	f8 94       	cli
    1656:	de bf       	out	0x3e, r29	; 62
    1658:	0f be       	out	0x3f, r0	; 63
    165a:	cd bf       	out	0x3d, r28	; 61
    165c:	9e 83       	std	Y+6, r25	; 0x06
    165e:	8d 83       	std	Y+5, r24	; 0x05
    1660:	78 87       	std	Y+8, r23	; 0x08
    1662:	6f 83       	std	Y+7, r22	; 0x07
    1664:	5a 87       	std	Y+10, r21	; 0x0a
    1666:	49 87       	std	Y+9, r20	; 0x09
    1668:	2b 87       	std	Y+11, r18	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    166a:	8d 81       	ldd	r24, Y+5	; 0x05
    166c:	9e 81       	ldd	r25, Y+6	; 0x06
    166e:	9b 83       	std	Y+3, r25	; 0x03
    1670:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1672:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1674:	8a 81       	ldd	r24, Y+2	; 0x02
    1676:	9b 81       	ldd	r25, Y+3	; 0x03
    1678:	fc 01       	movw	r30, r24
    167a:	22 8d       	ldd	r18, Z+26	; 0x1a
    167c:	8a 81       	ldd	r24, Y+2	; 0x02
    167e:	9b 81       	ldd	r25, Y+3	; 0x03
    1680:	fc 01       	movw	r30, r24
    1682:	83 8d       	ldd	r24, Z+27	; 0x1b
    1684:	28 17       	cp	r18, r24
    1686:	18 f0       	brcs	.+6      	; 0x168e <xQueueGenericSendFromISR+0x46>
    1688:	8b 85       	ldd	r24, Y+11	; 0x0b
    168a:	82 30       	cpi	r24, 0x02	; 2
    168c:	e9 f5       	brne	.+122    	; 0x1708 <xQueueGenericSendFromISR+0xc0>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
    168e:	2f 81       	ldd	r18, Y+7	; 0x07
    1690:	38 85       	ldd	r19, Y+8	; 0x08
    1692:	8a 81       	ldd	r24, Y+2	; 0x02
    1694:	9b 81       	ldd	r25, Y+3	; 0x03
    1696:	4b 85       	ldd	r20, Y+11	; 0x0b
    1698:	b9 01       	movw	r22, r18
    169a:	0e 94 bf 0c 	call	0x197e	; 0x197e <prvCopyDataToQueue>
    169e:	88 23       	and	r24, r24
    16a0:	49 f0       	breq	.+18     	; 0x16b4 <xQueueGenericSendFromISR+0x6c>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
    16a2:	89 85       	ldd	r24, Y+9	; 0x09
    16a4:	9a 85       	ldd	r25, Y+10	; 0x0a
    16a6:	00 97       	sbiw	r24, 0x00	; 0
    16a8:	29 f0       	breq	.+10     	; 0x16b4 <xQueueGenericSendFromISR+0x6c>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
    16aa:	89 85       	ldd	r24, Y+9	; 0x09
    16ac:	9a 85       	ldd	r25, Y+10	; 0x0a
    16ae:	21 e0       	ldi	r18, 0x01	; 1
    16b0:	fc 01       	movw	r30, r24
    16b2:	20 83       	st	Z, r18
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    16b4:	8a 81       	ldd	r24, Y+2	; 0x02
    16b6:	9b 81       	ldd	r25, Y+3	; 0x03
    16b8:	fc 01       	movw	r30, r24
    16ba:	86 8d       	ldd	r24, Z+30	; 0x1e
    16bc:	8f 3f       	cpi	r24, 0xFF	; 255
    16be:	b9 f4       	brne	.+46     	; 0x16ee <xQueueGenericSendFromISR+0xa6>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    16c0:	8a 81       	ldd	r24, Y+2	; 0x02
    16c2:	9b 81       	ldd	r25, Y+3	; 0x03
    16c4:	fc 01       	movw	r30, r24
    16c6:	81 89       	ldd	r24, Z+17	; 0x11
    16c8:	88 23       	and	r24, r24
    16ca:	d9 f0       	breq	.+54     	; 0x1702 <xQueueGenericSendFromISR+0xba>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    16cc:	8a 81       	ldd	r24, Y+2	; 0x02
    16ce:	9b 81       	ldd	r25, Y+3	; 0x03
    16d0:	41 96       	adiw	r24, 0x11	; 17
    16d2:	0e 94 e0 13 	call	0x27c0	; 0x27c0 <xTaskRemoveFromEventList>
    16d6:	88 23       	and	r24, r24
    16d8:	a1 f0       	breq	.+40     	; 0x1702 <xQueueGenericSendFromISR+0xba>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    16da:	89 85       	ldd	r24, Y+9	; 0x09
    16dc:	9a 85       	ldd	r25, Y+10	; 0x0a
    16de:	00 97       	sbiw	r24, 0x00	; 0
    16e0:	81 f0       	breq	.+32     	; 0x1702 <xQueueGenericSendFromISR+0xba>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    16e2:	89 85       	ldd	r24, Y+9	; 0x09
    16e4:	9a 85       	ldd	r25, Y+10	; 0x0a
    16e6:	21 e0       	ldi	r18, 0x01	; 1
    16e8:	fc 01       	movw	r30, r24
    16ea:	20 83       	st	Z, r18
    16ec:	0a c0       	rjmp	.+20     	; 0x1702 <xQueueGenericSendFromISR+0xba>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    16ee:	8a 81       	ldd	r24, Y+2	; 0x02
    16f0:	9b 81       	ldd	r25, Y+3	; 0x03
    16f2:	fc 01       	movw	r30, r24
    16f4:	86 8d       	ldd	r24, Z+30	; 0x1e
    16f6:	21 e0       	ldi	r18, 0x01	; 1
    16f8:	28 0f       	add	r18, r24
    16fa:	8a 81       	ldd	r24, Y+2	; 0x02
    16fc:	9b 81       	ldd	r25, Y+3	; 0x03
    16fe:	fc 01       	movw	r30, r24
    1700:	26 8f       	std	Z+30, r18	; 0x1e
			}

			xReturn = pdPASS;
    1702:	81 e0       	ldi	r24, 0x01	; 1
    1704:	89 83       	std	Y+1, r24	; 0x01
    1706:	01 c0       	rjmp	.+2      	; 0x170a <xQueueGenericSendFromISR+0xc2>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1708:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    170a:	89 81       	ldd	r24, Y+1	; 0x01
}
    170c:	2b 96       	adiw	r28, 0x0b	; 11
    170e:	0f b6       	in	r0, 0x3f	; 63
    1710:	f8 94       	cli
    1712:	de bf       	out	0x3e, r29	; 62
    1714:	0f be       	out	0x3f, r0	; 63
    1716:	cd bf       	out	0x3d, r28	; 61
    1718:	df 91       	pop	r29
    171a:	cf 91       	pop	r28
    171c:	08 95       	ret

0000171e <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    171e:	cf 93       	push	r28
    1720:	df 93       	push	r29
    1722:	cd b7       	in	r28, 0x3d	; 61
    1724:	de b7       	in	r29, 0x3e	; 62
    1726:	2f 97       	sbiw	r28, 0x0f	; 15
    1728:	0f b6       	in	r0, 0x3f	; 63
    172a:	f8 94       	cli
    172c:	de bf       	out	0x3e, r29	; 62
    172e:	0f be       	out	0x3f, r0	; 63
    1730:	cd bf       	out	0x3d, r28	; 61
    1732:	9a 87       	std	Y+10, r25	; 0x0a
    1734:	89 87       	std	Y+9, r24	; 0x09
    1736:	7c 87       	std	Y+12, r23	; 0x0c
    1738:	6b 87       	std	Y+11, r22	; 0x0b
    173a:	5e 87       	std	Y+14, r21	; 0x0e
    173c:	4d 87       	std	Y+13, r20	; 0x0d
    173e:	2f 87       	std	Y+15, r18	; 0x0f
BaseType_t xEntryTimeSet = pdFALSE;
    1740:	19 82       	std	Y+1, r1	; 0x01
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    1742:	89 85       	ldd	r24, Y+9	; 0x09
    1744:	9a 85       	ldd	r25, Y+10	; 0x0a
    1746:	9b 83       	std	Y+3, r25	; 0x03
    1748:	8a 83       	std	Y+2, r24	; 0x02
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    174a:	0f b6       	in	r0, 0x3f	; 63
    174c:	f8 94       	cli
    174e:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1750:	8a 81       	ldd	r24, Y+2	; 0x02
    1752:	9b 81       	ldd	r25, Y+3	; 0x03
    1754:	fc 01       	movw	r30, r24
    1756:	82 8d       	ldd	r24, Z+26	; 0x1a
    1758:	88 23       	and	r24, r24
    175a:	09 f4       	brne	.+2      	; 0x175e <xQueueGenericReceive+0x40>
    175c:	45 c0       	rjmp	.+138    	; 0x17e8 <xQueueGenericReceive+0xca>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    175e:	8a 81       	ldd	r24, Y+2	; 0x02
    1760:	9b 81       	ldd	r25, Y+3	; 0x03
    1762:	fc 01       	movw	r30, r24
    1764:	86 81       	ldd	r24, Z+6	; 0x06
    1766:	97 81       	ldd	r25, Z+7	; 0x07
    1768:	9d 83       	std	Y+5, r25	; 0x05
    176a:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    176c:	2b 85       	ldd	r18, Y+11	; 0x0b
    176e:	3c 85       	ldd	r19, Y+12	; 0x0c
    1770:	8a 81       	ldd	r24, Y+2	; 0x02
    1772:	9b 81       	ldd	r25, Y+3	; 0x03
    1774:	b9 01       	movw	r22, r18
    1776:	0e 94 7f 0d 	call	0x1afe	; 0x1afe <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    177a:	8f 85       	ldd	r24, Y+15	; 0x0f
    177c:	88 23       	and	r24, r24
    177e:	d1 f4       	brne	.+52     	; 0x17b4 <xQueueGenericReceive+0x96>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    1780:	8a 81       	ldd	r24, Y+2	; 0x02
    1782:	9b 81       	ldd	r25, Y+3	; 0x03
    1784:	fc 01       	movw	r30, r24
    1786:	82 8d       	ldd	r24, Z+26	; 0x1a
    1788:	2f ef       	ldi	r18, 0xFF	; 255
    178a:	28 0f       	add	r18, r24
    178c:	8a 81       	ldd	r24, Y+2	; 0x02
    178e:	9b 81       	ldd	r25, Y+3	; 0x03
    1790:	fc 01       	movw	r30, r24
    1792:	22 8f       	std	Z+26, r18	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1794:	8a 81       	ldd	r24, Y+2	; 0x02
    1796:	9b 81       	ldd	r25, Y+3	; 0x03
    1798:	fc 01       	movw	r30, r24
    179a:	80 85       	ldd	r24, Z+8	; 0x08
    179c:	88 23       	and	r24, r24
    179e:	01 f1       	breq	.+64     	; 0x17e0 <xQueueGenericReceive+0xc2>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    17a0:	8a 81       	ldd	r24, Y+2	; 0x02
    17a2:	9b 81       	ldd	r25, Y+3	; 0x03
    17a4:	08 96       	adiw	r24, 0x08	; 8
    17a6:	0e 94 e0 13 	call	0x27c0	; 0x27c0 <xTaskRemoveFromEventList>
    17aa:	81 30       	cpi	r24, 0x01	; 1
    17ac:	c9 f4       	brne	.+50     	; 0x17e0 <xQueueGenericReceive+0xc2>
						{
							queueYIELD_IF_USING_PREEMPTION();
    17ae:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vPortYield>
    17b2:	16 c0       	rjmp	.+44     	; 0x17e0 <xQueueGenericReceive+0xc2>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    17b4:	8a 81       	ldd	r24, Y+2	; 0x02
    17b6:	9b 81       	ldd	r25, Y+3	; 0x03
    17b8:	2c 81       	ldd	r18, Y+4	; 0x04
    17ba:	3d 81       	ldd	r19, Y+5	; 0x05
    17bc:	fc 01       	movw	r30, r24
    17be:	37 83       	std	Z+7, r19	; 0x07
    17c0:	26 83       	std	Z+6, r18	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    17c2:	8a 81       	ldd	r24, Y+2	; 0x02
    17c4:	9b 81       	ldd	r25, Y+3	; 0x03
    17c6:	fc 01       	movw	r30, r24
    17c8:	81 89       	ldd	r24, Z+17	; 0x11
    17ca:	88 23       	and	r24, r24
    17cc:	49 f0       	breq	.+18     	; 0x17e0 <xQueueGenericReceive+0xc2>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    17ce:	8a 81       	ldd	r24, Y+2	; 0x02
    17d0:	9b 81       	ldd	r25, Y+3	; 0x03
    17d2:	41 96       	adiw	r24, 0x11	; 17
    17d4:	0e 94 e0 13 	call	0x27c0	; 0x27c0 <xTaskRemoveFromEventList>
    17d8:	88 23       	and	r24, r24
    17da:	11 f0       	breq	.+4      	; 0x17e0 <xQueueGenericReceive+0xc2>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    17dc:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    17e0:	0f 90       	pop	r0
    17e2:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    17e4:	81 e0       	ldi	r24, 0x01	; 1
    17e6:	61 c0       	rjmp	.+194    	; 0x18aa <xQueueGenericReceive+0x18c>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    17e8:	8d 85       	ldd	r24, Y+13	; 0x0d
    17ea:	9e 85       	ldd	r25, Y+14	; 0x0e
    17ec:	00 97       	sbiw	r24, 0x00	; 0
    17ee:	21 f4       	brne	.+8      	; 0x17f8 <xQueueGenericReceive+0xda>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    17f0:	0f 90       	pop	r0
    17f2:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    17f4:	80 e0       	ldi	r24, 0x00	; 0
    17f6:	59 c0       	rjmp	.+178    	; 0x18aa <xQueueGenericReceive+0x18c>
				}
				else if( xEntryTimeSet == pdFALSE )
    17f8:	89 81       	ldd	r24, Y+1	; 0x01
    17fa:	88 23       	and	r24, r24
    17fc:	31 f4       	brne	.+12     	; 0x180a <xQueueGenericReceive+0xec>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    17fe:	ce 01       	movw	r24, r28
    1800:	06 96       	adiw	r24, 0x06	; 6
    1802:	0e 94 4d 14 	call	0x289a	; 0x289a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1806:	81 e0       	ldi	r24, 0x01	; 1
    1808:	89 83       	std	Y+1, r24	; 0x01
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    180a:	0f 90       	pop	r0
    180c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    180e:	0e 94 84 11 	call	0x2308	; 0x2308 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1812:	0f b6       	in	r0, 0x3f	; 63
    1814:	f8 94       	cli
    1816:	0f 92       	push	r0
    1818:	8a 81       	ldd	r24, Y+2	; 0x02
    181a:	9b 81       	ldd	r25, Y+3	; 0x03
    181c:	fc 01       	movw	r30, r24
    181e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1820:	8f 3f       	cpi	r24, 0xFF	; 255
    1822:	21 f4       	brne	.+8      	; 0x182c <xQueueGenericReceive+0x10e>
    1824:	8a 81       	ldd	r24, Y+2	; 0x02
    1826:	9b 81       	ldd	r25, Y+3	; 0x03
    1828:	fc 01       	movw	r30, r24
    182a:	15 8e       	std	Z+29, r1	; 0x1d
    182c:	8a 81       	ldd	r24, Y+2	; 0x02
    182e:	9b 81       	ldd	r25, Y+3	; 0x03
    1830:	fc 01       	movw	r30, r24
    1832:	86 8d       	ldd	r24, Z+30	; 0x1e
    1834:	8f 3f       	cpi	r24, 0xFF	; 255
    1836:	21 f4       	brne	.+8      	; 0x1840 <xQueueGenericReceive+0x122>
    1838:	8a 81       	ldd	r24, Y+2	; 0x02
    183a:	9b 81       	ldd	r25, Y+3	; 0x03
    183c:	fc 01       	movw	r30, r24
    183e:	16 8e       	std	Z+30, r1	; 0x1e
    1840:	0f 90       	pop	r0
    1842:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1844:	9e 01       	movw	r18, r28
    1846:	23 5f       	subi	r18, 0xF3	; 243
    1848:	3f 4f       	sbci	r19, 0xFF	; 255
    184a:	ce 01       	movw	r24, r28
    184c:	06 96       	adiw	r24, 0x06	; 6
    184e:	b9 01       	movw	r22, r18
    1850:	0e 94 68 14 	call	0x28d0	; 0x28d0 <xTaskCheckForTimeOut>
    1854:	88 23       	and	r24, r24
    1856:	01 f5       	brne	.+64     	; 0x1898 <xQueueGenericReceive+0x17a>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1858:	8a 81       	ldd	r24, Y+2	; 0x02
    185a:	9b 81       	ldd	r25, Y+3	; 0x03
    185c:	0e 94 33 0e 	call	0x1c66	; 0x1c66 <prvIsQueueEmpty>
    1860:	88 23       	and	r24, r24
    1862:	99 f0       	breq	.+38     	; 0x188a <xQueueGenericReceive+0x16c>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1864:	2d 85       	ldd	r18, Y+13	; 0x0d
    1866:	3e 85       	ldd	r19, Y+14	; 0x0e
    1868:	8a 81       	ldd	r24, Y+2	; 0x02
    186a:	9b 81       	ldd	r25, Y+3	; 0x03
    186c:	41 96       	adiw	r24, 0x11	; 17
    186e:	b9 01       	movw	r22, r18
    1870:	0e 94 9a 13 	call	0x2734	; 0x2734 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1874:	8a 81       	ldd	r24, Y+2	; 0x02
    1876:	9b 81       	ldd	r25, Y+3	; 0x03
    1878:	0e 94 cf 0d 	call	0x1b9e	; 0x1b9e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    187c:	0e 94 90 11 	call	0x2320	; 0x2320 <xTaskResumeAll>
    1880:	88 23       	and	r24, r24
    1882:	91 f4       	brne	.+36     	; 0x18a8 <xQueueGenericReceive+0x18a>
				{
					portYIELD_WITHIN_API();
    1884:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vPortYield>
    1888:	0f c0       	rjmp	.+30     	; 0x18a8 <xQueueGenericReceive+0x18a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    188a:	8a 81       	ldd	r24, Y+2	; 0x02
    188c:	9b 81       	ldd	r25, Y+3	; 0x03
    188e:	0e 94 cf 0d 	call	0x1b9e	; 0x1b9e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1892:	0e 94 90 11 	call	0x2320	; 0x2320 <xTaskResumeAll>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
    1896:	59 cf       	rjmp	.-334    	; 0x174a <xQueueGenericReceive+0x2c>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1898:	8a 81       	ldd	r24, Y+2	; 0x02
    189a:	9b 81       	ldd	r25, Y+3	; 0x03
    189c:	0e 94 cf 0d 	call	0x1b9e	; 0x1b9e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    18a0:	0e 94 90 11 	call	0x2320	; 0x2320 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    18a4:	80 e0       	ldi	r24, 0x00	; 0
    18a6:	01 c0       	rjmp	.+2      	; 0x18aa <xQueueGenericReceive+0x18c>
		}
	}
    18a8:	50 cf       	rjmp	.-352    	; 0x174a <xQueueGenericReceive+0x2c>
}
    18aa:	2f 96       	adiw	r28, 0x0f	; 15
    18ac:	0f b6       	in	r0, 0x3f	; 63
    18ae:	f8 94       	cli
    18b0:	de bf       	out	0x3e, r29	; 62
    18b2:	0f be       	out	0x3f, r0	; 63
    18b4:	cd bf       	out	0x3d, r28	; 61
    18b6:	df 91       	pop	r29
    18b8:	cf 91       	pop	r28
    18ba:	08 95       	ret

000018bc <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    18bc:	cf 93       	push	r28
    18be:	df 93       	push	r29
    18c0:	cd b7       	in	r28, 0x3d	; 61
    18c2:	de b7       	in	r29, 0x3e	; 62
    18c4:	2a 97       	sbiw	r28, 0x0a	; 10
    18c6:	0f b6       	in	r0, 0x3f	; 63
    18c8:	f8 94       	cli
    18ca:	de bf       	out	0x3e, r29	; 62
    18cc:	0f be       	out	0x3f, r0	; 63
    18ce:	cd bf       	out	0x3d, r28	; 61
    18d0:	9e 83       	std	Y+6, r25	; 0x06
    18d2:	8d 83       	std	Y+5, r24	; 0x05
    18d4:	78 87       	std	Y+8, r23	; 0x08
    18d6:	6f 83       	std	Y+7, r22	; 0x07
    18d8:	5a 87       	std	Y+10, r21	; 0x0a
    18da:	49 87       	std	Y+9, r20	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    18dc:	8d 81       	ldd	r24, Y+5	; 0x05
    18de:	9e 81       	ldd	r25, Y+6	; 0x06
    18e0:	9b 83       	std	Y+3, r25	; 0x03
    18e2:	8a 83       	std	Y+2, r24	; 0x02
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    18e4:	1c 82       	std	Y+4, r1	; 0x04
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    18e6:	8a 81       	ldd	r24, Y+2	; 0x02
    18e8:	9b 81       	ldd	r25, Y+3	; 0x03
    18ea:	fc 01       	movw	r30, r24
    18ec:	82 8d       	ldd	r24, Z+26	; 0x1a
    18ee:	88 23       	and	r24, r24
    18f0:	d9 f1       	breq	.+118    	; 0x1968 <xQueueReceiveFromISR+0xac>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    18f2:	2f 81       	ldd	r18, Y+7	; 0x07
    18f4:	38 85       	ldd	r19, Y+8	; 0x08
    18f6:	8a 81       	ldd	r24, Y+2	; 0x02
    18f8:	9b 81       	ldd	r25, Y+3	; 0x03
    18fa:	b9 01       	movw	r22, r18
    18fc:	0e 94 7f 0d 	call	0x1afe	; 0x1afe <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1900:	8a 81       	ldd	r24, Y+2	; 0x02
    1902:	9b 81       	ldd	r25, Y+3	; 0x03
    1904:	fc 01       	movw	r30, r24
    1906:	82 8d       	ldd	r24, Z+26	; 0x1a
    1908:	2f ef       	ldi	r18, 0xFF	; 255
    190a:	28 0f       	add	r18, r24
    190c:	8a 81       	ldd	r24, Y+2	; 0x02
    190e:	9b 81       	ldd	r25, Y+3	; 0x03
    1910:	fc 01       	movw	r30, r24
    1912:	22 8f       	std	Z+26, r18	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1914:	8a 81       	ldd	r24, Y+2	; 0x02
    1916:	9b 81       	ldd	r25, Y+3	; 0x03
    1918:	fc 01       	movw	r30, r24
    191a:	85 8d       	ldd	r24, Z+29	; 0x1d
    191c:	8f 3f       	cpi	r24, 0xFF	; 255
    191e:	b9 f4       	brne	.+46     	; 0x194e <xQueueReceiveFromISR+0x92>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1920:	8a 81       	ldd	r24, Y+2	; 0x02
    1922:	9b 81       	ldd	r25, Y+3	; 0x03
    1924:	fc 01       	movw	r30, r24
    1926:	80 85       	ldd	r24, Z+8	; 0x08
    1928:	88 23       	and	r24, r24
    192a:	d9 f0       	breq	.+54     	; 0x1962 <xQueueReceiveFromISR+0xa6>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    192c:	8a 81       	ldd	r24, Y+2	; 0x02
    192e:	9b 81       	ldd	r25, Y+3	; 0x03
    1930:	08 96       	adiw	r24, 0x08	; 8
    1932:	0e 94 e0 13 	call	0x27c0	; 0x27c0 <xTaskRemoveFromEventList>
    1936:	88 23       	and	r24, r24
    1938:	a1 f0       	breq	.+40     	; 0x1962 <xQueueReceiveFromISR+0xa6>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    193a:	89 85       	ldd	r24, Y+9	; 0x09
    193c:	9a 85       	ldd	r25, Y+10	; 0x0a
    193e:	00 97       	sbiw	r24, 0x00	; 0
    1940:	81 f0       	breq	.+32     	; 0x1962 <xQueueReceiveFromISR+0xa6>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1942:	89 85       	ldd	r24, Y+9	; 0x09
    1944:	9a 85       	ldd	r25, Y+10	; 0x0a
    1946:	21 e0       	ldi	r18, 0x01	; 1
    1948:	fc 01       	movw	r30, r24
    194a:	20 83       	st	Z, r18
    194c:	0a c0       	rjmp	.+20     	; 0x1962 <xQueueReceiveFromISR+0xa6>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    194e:	8a 81       	ldd	r24, Y+2	; 0x02
    1950:	9b 81       	ldd	r25, Y+3	; 0x03
    1952:	fc 01       	movw	r30, r24
    1954:	85 8d       	ldd	r24, Z+29	; 0x1d
    1956:	21 e0       	ldi	r18, 0x01	; 1
    1958:	28 0f       	add	r18, r24
    195a:	8a 81       	ldd	r24, Y+2	; 0x02
    195c:	9b 81       	ldd	r25, Y+3	; 0x03
    195e:	fc 01       	movw	r30, r24
    1960:	25 8f       	std	Z+29, r18	; 0x1d
			}

			xReturn = pdPASS;
    1962:	81 e0       	ldi	r24, 0x01	; 1
    1964:	89 83       	std	Y+1, r24	; 0x01
    1966:	01 c0       	rjmp	.+2      	; 0x196a <xQueueReceiveFromISR+0xae>
		}
		else
		{
			xReturn = pdFAIL;
    1968:	19 82       	std	Y+1, r1	; 0x01
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    196a:	89 81       	ldd	r24, Y+1	; 0x01
}
    196c:	2a 96       	adiw	r28, 0x0a	; 10
    196e:	0f b6       	in	r0, 0x3f	; 63
    1970:	f8 94       	cli
    1972:	de bf       	out	0x3e, r29	; 62
    1974:	0f be       	out	0x3f, r0	; 63
    1976:	cd bf       	out	0x3d, r28	; 61
    1978:	df 91       	pop	r29
    197a:	cf 91       	pop	r28
    197c:	08 95       	ret

0000197e <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    197e:	cf 93       	push	r28
    1980:	df 93       	push	r29
    1982:	00 d0       	rcall	.+0      	; 0x1984 <prvCopyDataToQueue+0x6>
    1984:	00 d0       	rcall	.+0      	; 0x1986 <prvCopyDataToQueue+0x8>
    1986:	00 d0       	rcall	.+0      	; 0x1988 <prvCopyDataToQueue+0xa>
    1988:	cd b7       	in	r28, 0x3d	; 61
    198a:	de b7       	in	r29, 0x3e	; 62
    198c:	9b 83       	std	Y+3, r25	; 0x03
    198e:	8a 83       	std	Y+2, r24	; 0x02
    1990:	7d 83       	std	Y+5, r23	; 0x05
    1992:	6c 83       	std	Y+4, r22	; 0x04
    1994:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xReturn = pdFALSE;
    1996:	19 82       	std	Y+1, r1	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1998:	8a 81       	ldd	r24, Y+2	; 0x02
    199a:	9b 81       	ldd	r25, Y+3	; 0x03
    199c:	fc 01       	movw	r30, r24
    199e:	84 8d       	ldd	r24, Z+28	; 0x1c
    19a0:	88 23       	and	r24, r24
    19a2:	09 f4       	brne	.+2      	; 0x19a6 <prvCopyDataToQueue+0x28>
    19a4:	98 c0       	rjmp	.+304    	; 0x1ad6 <prvCopyDataToQueue+0x158>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    19a6:	8e 81       	ldd	r24, Y+6	; 0x06
    19a8:	88 23       	and	r24, r24
    19aa:	d9 f5       	brne	.+118    	; 0x1a22 <prvCopyDataToQueue+0xa4>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
    19ac:	8a 81       	ldd	r24, Y+2	; 0x02
    19ae:	9b 81       	ldd	r25, Y+3	; 0x03
    19b0:	fc 01       	movw	r30, r24
    19b2:	84 8d       	ldd	r24, Z+28	; 0x1c
    19b4:	48 2f       	mov	r20, r24
    19b6:	50 e0       	ldi	r21, 0x00	; 0
    19b8:	8a 81       	ldd	r24, Y+2	; 0x02
    19ba:	9b 81       	ldd	r25, Y+3	; 0x03
    19bc:	fc 01       	movw	r30, r24
    19be:	84 81       	ldd	r24, Z+4	; 0x04
    19c0:	95 81       	ldd	r25, Z+5	; 0x05
    19c2:	2c 81       	ldd	r18, Y+4	; 0x04
    19c4:	3d 81       	ldd	r19, Y+5	; 0x05
    19c6:	b9 01       	movw	r22, r18
    19c8:	0e 94 3e 1a 	call	0x347c	; 0x347c <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    19cc:	8a 81       	ldd	r24, Y+2	; 0x02
    19ce:	9b 81       	ldd	r25, Y+3	; 0x03
    19d0:	fc 01       	movw	r30, r24
    19d2:	24 81       	ldd	r18, Z+4	; 0x04
    19d4:	35 81       	ldd	r19, Z+5	; 0x05
    19d6:	8a 81       	ldd	r24, Y+2	; 0x02
    19d8:	9b 81       	ldd	r25, Y+3	; 0x03
    19da:	fc 01       	movw	r30, r24
    19dc:	84 8d       	ldd	r24, Z+28	; 0x1c
    19de:	88 2f       	mov	r24, r24
    19e0:	90 e0       	ldi	r25, 0x00	; 0
    19e2:	28 0f       	add	r18, r24
    19e4:	39 1f       	adc	r19, r25
    19e6:	8a 81       	ldd	r24, Y+2	; 0x02
    19e8:	9b 81       	ldd	r25, Y+3	; 0x03
    19ea:	fc 01       	movw	r30, r24
    19ec:	35 83       	std	Z+5, r19	; 0x05
    19ee:	24 83       	std	Z+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    19f0:	8a 81       	ldd	r24, Y+2	; 0x02
    19f2:	9b 81       	ldd	r25, Y+3	; 0x03
    19f4:	fc 01       	movw	r30, r24
    19f6:	24 81       	ldd	r18, Z+4	; 0x04
    19f8:	35 81       	ldd	r19, Z+5	; 0x05
    19fa:	8a 81       	ldd	r24, Y+2	; 0x02
    19fc:	9b 81       	ldd	r25, Y+3	; 0x03
    19fe:	fc 01       	movw	r30, r24
    1a00:	82 81       	ldd	r24, Z+2	; 0x02
    1a02:	93 81       	ldd	r25, Z+3	; 0x03
    1a04:	28 17       	cp	r18, r24
    1a06:	39 07       	cpc	r19, r25
    1a08:	08 f4       	brcc	.+2      	; 0x1a0c <prvCopyDataToQueue+0x8e>
    1a0a:	65 c0       	rjmp	.+202    	; 0x1ad6 <prvCopyDataToQueue+0x158>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1a0c:	8a 81       	ldd	r24, Y+2	; 0x02
    1a0e:	9b 81       	ldd	r25, Y+3	; 0x03
    1a10:	fc 01       	movw	r30, r24
    1a12:	20 81       	ld	r18, Z
    1a14:	31 81       	ldd	r19, Z+1	; 0x01
    1a16:	8a 81       	ldd	r24, Y+2	; 0x02
    1a18:	9b 81       	ldd	r25, Y+3	; 0x03
    1a1a:	fc 01       	movw	r30, r24
    1a1c:	35 83       	std	Z+5, r19	; 0x05
    1a1e:	24 83       	std	Z+4, r18	; 0x04
    1a20:	5a c0       	rjmp	.+180    	; 0x1ad6 <prvCopyDataToQueue+0x158>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1a22:	8a 81       	ldd	r24, Y+2	; 0x02
    1a24:	9b 81       	ldd	r25, Y+3	; 0x03
    1a26:	fc 01       	movw	r30, r24
    1a28:	84 8d       	ldd	r24, Z+28	; 0x1c
    1a2a:	48 2f       	mov	r20, r24
    1a2c:	50 e0       	ldi	r21, 0x00	; 0
    1a2e:	8a 81       	ldd	r24, Y+2	; 0x02
    1a30:	9b 81       	ldd	r25, Y+3	; 0x03
    1a32:	fc 01       	movw	r30, r24
    1a34:	86 81       	ldd	r24, Z+6	; 0x06
    1a36:	97 81       	ldd	r25, Z+7	; 0x07
    1a38:	2c 81       	ldd	r18, Y+4	; 0x04
    1a3a:	3d 81       	ldd	r19, Y+5	; 0x05
    1a3c:	b9 01       	movw	r22, r18
    1a3e:	0e 94 3e 1a 	call	0x347c	; 0x347c <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    1a42:	8a 81       	ldd	r24, Y+2	; 0x02
    1a44:	9b 81       	ldd	r25, Y+3	; 0x03
    1a46:	fc 01       	movw	r30, r24
    1a48:	26 81       	ldd	r18, Z+6	; 0x06
    1a4a:	37 81       	ldd	r19, Z+7	; 0x07
    1a4c:	8a 81       	ldd	r24, Y+2	; 0x02
    1a4e:	9b 81       	ldd	r25, Y+3	; 0x03
    1a50:	fc 01       	movw	r30, r24
    1a52:	84 8d       	ldd	r24, Z+28	; 0x1c
    1a54:	88 2f       	mov	r24, r24
    1a56:	90 e0       	ldi	r25, 0x00	; 0
    1a58:	91 95       	neg	r25
    1a5a:	81 95       	neg	r24
    1a5c:	91 09       	sbc	r25, r1
    1a5e:	28 0f       	add	r18, r24
    1a60:	39 1f       	adc	r19, r25
    1a62:	8a 81       	ldd	r24, Y+2	; 0x02
    1a64:	9b 81       	ldd	r25, Y+3	; 0x03
    1a66:	fc 01       	movw	r30, r24
    1a68:	37 83       	std	Z+7, r19	; 0x07
    1a6a:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1a6c:	8a 81       	ldd	r24, Y+2	; 0x02
    1a6e:	9b 81       	ldd	r25, Y+3	; 0x03
    1a70:	fc 01       	movw	r30, r24
    1a72:	26 81       	ldd	r18, Z+6	; 0x06
    1a74:	37 81       	ldd	r19, Z+7	; 0x07
    1a76:	8a 81       	ldd	r24, Y+2	; 0x02
    1a78:	9b 81       	ldd	r25, Y+3	; 0x03
    1a7a:	fc 01       	movw	r30, r24
    1a7c:	80 81       	ld	r24, Z
    1a7e:	91 81       	ldd	r25, Z+1	; 0x01
    1a80:	28 17       	cp	r18, r24
    1a82:	39 07       	cpc	r19, r25
    1a84:	a8 f4       	brcc	.+42     	; 0x1ab0 <prvCopyDataToQueue+0x132>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1a86:	8a 81       	ldd	r24, Y+2	; 0x02
    1a88:	9b 81       	ldd	r25, Y+3	; 0x03
    1a8a:	fc 01       	movw	r30, r24
    1a8c:	22 81       	ldd	r18, Z+2	; 0x02
    1a8e:	33 81       	ldd	r19, Z+3	; 0x03
    1a90:	8a 81       	ldd	r24, Y+2	; 0x02
    1a92:	9b 81       	ldd	r25, Y+3	; 0x03
    1a94:	fc 01       	movw	r30, r24
    1a96:	84 8d       	ldd	r24, Z+28	; 0x1c
    1a98:	88 2f       	mov	r24, r24
    1a9a:	90 e0       	ldi	r25, 0x00	; 0
    1a9c:	91 95       	neg	r25
    1a9e:	81 95       	neg	r24
    1aa0:	91 09       	sbc	r25, r1
    1aa2:	28 0f       	add	r18, r24
    1aa4:	39 1f       	adc	r19, r25
    1aa6:	8a 81       	ldd	r24, Y+2	; 0x02
    1aa8:	9b 81       	ldd	r25, Y+3	; 0x03
    1aaa:	fc 01       	movw	r30, r24
    1aac:	37 83       	std	Z+7, r19	; 0x07
    1aae:	26 83       	std	Z+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    1ab0:	8e 81       	ldd	r24, Y+6	; 0x06
    1ab2:	82 30       	cpi	r24, 0x02	; 2
    1ab4:	81 f4       	brne	.+32     	; 0x1ad6 <prvCopyDataToQueue+0x158>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1ab6:	8a 81       	ldd	r24, Y+2	; 0x02
    1ab8:	9b 81       	ldd	r25, Y+3	; 0x03
    1aba:	fc 01       	movw	r30, r24
    1abc:	82 8d       	ldd	r24, Z+26	; 0x1a
    1abe:	88 23       	and	r24, r24
    1ac0:	51 f0       	breq	.+20     	; 0x1ad6 <prvCopyDataToQueue+0x158>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
    1ac2:	8a 81       	ldd	r24, Y+2	; 0x02
    1ac4:	9b 81       	ldd	r25, Y+3	; 0x03
    1ac6:	fc 01       	movw	r30, r24
    1ac8:	82 8d       	ldd	r24, Z+26	; 0x1a
    1aca:	2f ef       	ldi	r18, 0xFF	; 255
    1acc:	28 0f       	add	r18, r24
    1ace:	8a 81       	ldd	r24, Y+2	; 0x02
    1ad0:	9b 81       	ldd	r25, Y+3	; 0x03
    1ad2:	fc 01       	movw	r30, r24
    1ad4:	22 8f       	std	Z+26, r18	; 0x1a
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1ad6:	8a 81       	ldd	r24, Y+2	; 0x02
    1ad8:	9b 81       	ldd	r25, Y+3	; 0x03
    1ada:	fc 01       	movw	r30, r24
    1adc:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ade:	21 e0       	ldi	r18, 0x01	; 1
    1ae0:	28 0f       	add	r18, r24
    1ae2:	8a 81       	ldd	r24, Y+2	; 0x02
    1ae4:	9b 81       	ldd	r25, Y+3	; 0x03
    1ae6:	fc 01       	movw	r30, r24
    1ae8:	22 8f       	std	Z+26, r18	; 0x1a

	return xReturn;
    1aea:	89 81       	ldd	r24, Y+1	; 0x01
}
    1aec:	26 96       	adiw	r28, 0x06	; 6
    1aee:	0f b6       	in	r0, 0x3f	; 63
    1af0:	f8 94       	cli
    1af2:	de bf       	out	0x3e, r29	; 62
    1af4:	0f be       	out	0x3f, r0	; 63
    1af6:	cd bf       	out	0x3d, r28	; 61
    1af8:	df 91       	pop	r29
    1afa:	cf 91       	pop	r28
    1afc:	08 95       	ret

00001afe <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    1afe:	cf 93       	push	r28
    1b00:	df 93       	push	r29
    1b02:	00 d0       	rcall	.+0      	; 0x1b04 <prvCopyDataFromQueue+0x6>
    1b04:	00 d0       	rcall	.+0      	; 0x1b06 <prvCopyDataFromQueue+0x8>
    1b06:	cd b7       	in	r28, 0x3d	; 61
    1b08:	de b7       	in	r29, 0x3e	; 62
    1b0a:	9a 83       	std	Y+2, r25	; 0x02
    1b0c:	89 83       	std	Y+1, r24	; 0x01
    1b0e:	7c 83       	std	Y+4, r23	; 0x04
    1b10:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1b12:	89 81       	ldd	r24, Y+1	; 0x01
    1b14:	9a 81       	ldd	r25, Y+2	; 0x02
    1b16:	fc 01       	movw	r30, r24
    1b18:	84 8d       	ldd	r24, Z+28	; 0x1c
    1b1a:	88 23       	and	r24, r24
    1b1c:	c9 f1       	breq	.+114    	; 0x1b90 <prvCopyDataFromQueue+0x92>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1b1e:	89 81       	ldd	r24, Y+1	; 0x01
    1b20:	9a 81       	ldd	r25, Y+2	; 0x02
    1b22:	fc 01       	movw	r30, r24
    1b24:	26 81       	ldd	r18, Z+6	; 0x06
    1b26:	37 81       	ldd	r19, Z+7	; 0x07
    1b28:	89 81       	ldd	r24, Y+1	; 0x01
    1b2a:	9a 81       	ldd	r25, Y+2	; 0x02
    1b2c:	fc 01       	movw	r30, r24
    1b2e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1b30:	88 2f       	mov	r24, r24
    1b32:	90 e0       	ldi	r25, 0x00	; 0
    1b34:	28 0f       	add	r18, r24
    1b36:	39 1f       	adc	r19, r25
    1b38:	89 81       	ldd	r24, Y+1	; 0x01
    1b3a:	9a 81       	ldd	r25, Y+2	; 0x02
    1b3c:	fc 01       	movw	r30, r24
    1b3e:	37 83       	std	Z+7, r19	; 0x07
    1b40:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1b42:	89 81       	ldd	r24, Y+1	; 0x01
    1b44:	9a 81       	ldd	r25, Y+2	; 0x02
    1b46:	fc 01       	movw	r30, r24
    1b48:	26 81       	ldd	r18, Z+6	; 0x06
    1b4a:	37 81       	ldd	r19, Z+7	; 0x07
    1b4c:	89 81       	ldd	r24, Y+1	; 0x01
    1b4e:	9a 81       	ldd	r25, Y+2	; 0x02
    1b50:	fc 01       	movw	r30, r24
    1b52:	82 81       	ldd	r24, Z+2	; 0x02
    1b54:	93 81       	ldd	r25, Z+3	; 0x03
    1b56:	28 17       	cp	r18, r24
    1b58:	39 07       	cpc	r19, r25
    1b5a:	50 f0       	brcs	.+20     	; 0x1b70 <prvCopyDataFromQueue+0x72>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1b5c:	89 81       	ldd	r24, Y+1	; 0x01
    1b5e:	9a 81       	ldd	r25, Y+2	; 0x02
    1b60:	fc 01       	movw	r30, r24
    1b62:	20 81       	ld	r18, Z
    1b64:	31 81       	ldd	r19, Z+1	; 0x01
    1b66:	89 81       	ldd	r24, Y+1	; 0x01
    1b68:	9a 81       	ldd	r25, Y+2	; 0x02
    1b6a:	fc 01       	movw	r30, r24
    1b6c:	37 83       	std	Z+7, r19	; 0x07
    1b6e:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    1b70:	89 81       	ldd	r24, Y+1	; 0x01
    1b72:	9a 81       	ldd	r25, Y+2	; 0x02
    1b74:	fc 01       	movw	r30, r24
    1b76:	84 8d       	ldd	r24, Z+28	; 0x1c
    1b78:	48 2f       	mov	r20, r24
    1b7a:	50 e0       	ldi	r21, 0x00	; 0
    1b7c:	89 81       	ldd	r24, Y+1	; 0x01
    1b7e:	9a 81       	ldd	r25, Y+2	; 0x02
    1b80:	fc 01       	movw	r30, r24
    1b82:	26 81       	ldd	r18, Z+6	; 0x06
    1b84:	37 81       	ldd	r19, Z+7	; 0x07
    1b86:	8b 81       	ldd	r24, Y+3	; 0x03
    1b88:	9c 81       	ldd	r25, Y+4	; 0x04
    1b8a:	b9 01       	movw	r22, r18
    1b8c:	0e 94 3e 1a 	call	0x347c	; 0x347c <memcpy>
	}
}
    1b90:	0f 90       	pop	r0
    1b92:	0f 90       	pop	r0
    1b94:	0f 90       	pop	r0
    1b96:	0f 90       	pop	r0
    1b98:	df 91       	pop	r29
    1b9a:	cf 91       	pop	r28
    1b9c:	08 95       	ret

00001b9e <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1b9e:	cf 93       	push	r28
    1ba0:	df 93       	push	r29
    1ba2:	00 d0       	rcall	.+0      	; 0x1ba4 <prvUnlockQueue+0x6>
    1ba4:	cd b7       	in	r28, 0x3d	; 61
    1ba6:	de b7       	in	r29, 0x3e	; 62
    1ba8:	9a 83       	std	Y+2, r25	; 0x02
    1baa:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1bac:	0f b6       	in	r0, 0x3f	; 63
    1bae:	f8 94       	cli
    1bb0:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1bb2:	1b c0       	rjmp	.+54     	; 0x1bea <prvUnlockQueue+0x4c>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1bb4:	89 81       	ldd	r24, Y+1	; 0x01
    1bb6:	9a 81       	ldd	r25, Y+2	; 0x02
    1bb8:	fc 01       	movw	r30, r24
    1bba:	81 89       	ldd	r24, Z+17	; 0x11
    1bbc:	88 23       	and	r24, r24
    1bbe:	51 f0       	breq	.+20     	; 0x1bd4 <prvUnlockQueue+0x36>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1bc0:	89 81       	ldd	r24, Y+1	; 0x01
    1bc2:	9a 81       	ldd	r25, Y+2	; 0x02
    1bc4:	41 96       	adiw	r24, 0x11	; 17
    1bc6:	0e 94 e0 13 	call	0x27c0	; 0x27c0 <xTaskRemoveFromEventList>
    1bca:	88 23       	and	r24, r24
    1bcc:	21 f0       	breq	.+8      	; 0x1bd6 <prvUnlockQueue+0x38>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    1bce:	0e 94 db 14 	call	0x29b6	; 0x29b6 <vTaskMissedYield>
    1bd2:	01 c0       	rjmp	.+2      	; 0x1bd6 <prvUnlockQueue+0x38>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				else
				{
					break;
    1bd4:	10 c0       	rjmp	.+32     	; 0x1bf6 <prvUnlockQueue+0x58>
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    1bd6:	89 81       	ldd	r24, Y+1	; 0x01
    1bd8:	9a 81       	ldd	r25, Y+2	; 0x02
    1bda:	fc 01       	movw	r30, r24
    1bdc:	86 8d       	ldd	r24, Z+30	; 0x1e
    1bde:	2f ef       	ldi	r18, 0xFF	; 255
    1be0:	28 0f       	add	r18, r24
    1be2:	89 81       	ldd	r24, Y+1	; 0x01
    1be4:	9a 81       	ldd	r25, Y+2	; 0x02
    1be6:	fc 01       	movw	r30, r24
    1be8:	26 8f       	std	Z+30, r18	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1bea:	89 81       	ldd	r24, Y+1	; 0x01
    1bec:	9a 81       	ldd	r25, Y+2	; 0x02
    1bee:	fc 01       	movw	r30, r24
    1bf0:	86 8d       	ldd	r24, Z+30	; 0x1e
    1bf2:	18 16       	cp	r1, r24
    1bf4:	fc f2       	brlt	.-66     	; 0x1bb4 <prvUnlockQueue+0x16>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    1bf6:	89 81       	ldd	r24, Y+1	; 0x01
    1bf8:	9a 81       	ldd	r25, Y+2	; 0x02
    1bfa:	2f ef       	ldi	r18, 0xFF	; 255
    1bfc:	fc 01       	movw	r30, r24
    1bfe:	26 8f       	std	Z+30, r18	; 0x1e
	}
	taskEXIT_CRITICAL();
    1c00:	0f 90       	pop	r0
    1c02:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1c04:	0f b6       	in	r0, 0x3f	; 63
    1c06:	f8 94       	cli
    1c08:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1c0a:	1b c0       	rjmp	.+54     	; 0x1c42 <prvUnlockQueue+0xa4>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1c0c:	89 81       	ldd	r24, Y+1	; 0x01
    1c0e:	9a 81       	ldd	r25, Y+2	; 0x02
    1c10:	fc 01       	movw	r30, r24
    1c12:	80 85       	ldd	r24, Z+8	; 0x08
    1c14:	88 23       	and	r24, r24
    1c16:	a1 f0       	breq	.+40     	; 0x1c40 <prvUnlockQueue+0xa2>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1c18:	89 81       	ldd	r24, Y+1	; 0x01
    1c1a:	9a 81       	ldd	r25, Y+2	; 0x02
    1c1c:	08 96       	adiw	r24, 0x08	; 8
    1c1e:	0e 94 e0 13 	call	0x27c0	; 0x27c0 <xTaskRemoveFromEventList>
    1c22:	88 23       	and	r24, r24
    1c24:	11 f0       	breq	.+4      	; 0x1c2a <prvUnlockQueue+0x8c>
				{
					vTaskMissedYield();
    1c26:	0e 94 db 14 	call	0x29b6	; 0x29b6 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    1c2a:	89 81       	ldd	r24, Y+1	; 0x01
    1c2c:	9a 81       	ldd	r25, Y+2	; 0x02
    1c2e:	fc 01       	movw	r30, r24
    1c30:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c32:	2f ef       	ldi	r18, 0xFF	; 255
    1c34:	28 0f       	add	r18, r24
    1c36:	89 81       	ldd	r24, Y+1	; 0x01
    1c38:	9a 81       	ldd	r25, Y+2	; 0x02
    1c3a:	fc 01       	movw	r30, r24
    1c3c:	25 8f       	std	Z+29, r18	; 0x1d
    1c3e:	01 c0       	rjmp	.+2      	; 0x1c42 <prvUnlockQueue+0xa4>
			}
			else
			{
				break;
    1c40:	06 c0       	rjmp	.+12     	; 0x1c4e <prvUnlockQueue+0xb0>
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1c42:	89 81       	ldd	r24, Y+1	; 0x01
    1c44:	9a 81       	ldd	r25, Y+2	; 0x02
    1c46:	fc 01       	movw	r30, r24
    1c48:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c4a:	18 16       	cp	r1, r24
    1c4c:	fc f2       	brlt	.-66     	; 0x1c0c <prvUnlockQueue+0x6e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1c4e:	89 81       	ldd	r24, Y+1	; 0x01
    1c50:	9a 81       	ldd	r25, Y+2	; 0x02
    1c52:	2f ef       	ldi	r18, 0xFF	; 255
    1c54:	fc 01       	movw	r30, r24
    1c56:	25 8f       	std	Z+29, r18	; 0x1d
	}
	taskEXIT_CRITICAL();
    1c58:	0f 90       	pop	r0
    1c5a:	0f be       	out	0x3f, r0	; 63
}
    1c5c:	0f 90       	pop	r0
    1c5e:	0f 90       	pop	r0
    1c60:	df 91       	pop	r29
    1c62:	cf 91       	pop	r28
    1c64:	08 95       	ret

00001c66 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    1c66:	cf 93       	push	r28
    1c68:	df 93       	push	r29
    1c6a:	00 d0       	rcall	.+0      	; 0x1c6c <prvIsQueueEmpty+0x6>
    1c6c:	1f 92       	push	r1
    1c6e:	cd b7       	in	r28, 0x3d	; 61
    1c70:	de b7       	in	r29, 0x3e	; 62
    1c72:	9b 83       	std	Y+3, r25	; 0x03
    1c74:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1c76:	0f b6       	in	r0, 0x3f	; 63
    1c78:	f8 94       	cli
    1c7a:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1c7c:	8a 81       	ldd	r24, Y+2	; 0x02
    1c7e:	9b 81       	ldd	r25, Y+3	; 0x03
    1c80:	fc 01       	movw	r30, r24
    1c82:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c84:	88 23       	and	r24, r24
    1c86:	19 f4       	brne	.+6      	; 0x1c8e <prvIsQueueEmpty+0x28>
		{
			xReturn = pdTRUE;
    1c88:	81 e0       	ldi	r24, 0x01	; 1
    1c8a:	89 83       	std	Y+1, r24	; 0x01
    1c8c:	01 c0       	rjmp	.+2      	; 0x1c90 <prvIsQueueEmpty+0x2a>
		}
		else
		{
			xReturn = pdFALSE;
    1c8e:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    1c90:	0f 90       	pop	r0
    1c92:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1c94:	89 81       	ldd	r24, Y+1	; 0x01
}
    1c96:	0f 90       	pop	r0
    1c98:	0f 90       	pop	r0
    1c9a:	0f 90       	pop	r0
    1c9c:	df 91       	pop	r29
    1c9e:	cf 91       	pop	r28
    1ca0:	08 95       	ret

00001ca2 <prvIsQueueFull>:
	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    1ca2:	cf 93       	push	r28
    1ca4:	df 93       	push	r29
    1ca6:	00 d0       	rcall	.+0      	; 0x1ca8 <prvIsQueueFull+0x6>
    1ca8:	1f 92       	push	r1
    1caa:	cd b7       	in	r28, 0x3d	; 61
    1cac:	de b7       	in	r29, 0x3e	; 62
    1cae:	9b 83       	std	Y+3, r25	; 0x03
    1cb0:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1cb2:	0f b6       	in	r0, 0x3f	; 63
    1cb4:	f8 94       	cli
    1cb6:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1cb8:	8a 81       	ldd	r24, Y+2	; 0x02
    1cba:	9b 81       	ldd	r25, Y+3	; 0x03
    1cbc:	fc 01       	movw	r30, r24
    1cbe:	22 8d       	ldd	r18, Z+26	; 0x1a
    1cc0:	8a 81       	ldd	r24, Y+2	; 0x02
    1cc2:	9b 81       	ldd	r25, Y+3	; 0x03
    1cc4:	fc 01       	movw	r30, r24
    1cc6:	83 8d       	ldd	r24, Z+27	; 0x1b
    1cc8:	28 17       	cp	r18, r24
    1cca:	19 f4       	brne	.+6      	; 0x1cd2 <prvIsQueueFull+0x30>
		{
			xReturn = pdTRUE;
    1ccc:	81 e0       	ldi	r24, 0x01	; 1
    1cce:	89 83       	std	Y+1, r24	; 0x01
    1cd0:	01 c0       	rjmp	.+2      	; 0x1cd4 <prvIsQueueFull+0x32>
		}
		else
		{
			xReturn = pdFALSE;
    1cd2:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    1cd4:	0f 90       	pop	r0
    1cd6:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1cd8:	89 81       	ldd	r24, Y+1	; 0x01
}
    1cda:	0f 90       	pop	r0
    1cdc:	0f 90       	pop	r0
    1cde:	0f 90       	pop	r0
    1ce0:	df 91       	pop	r29
    1ce2:	cf 91       	pop	r28
    1ce4:	08 95       	ret

00001ce6 <vQueueAddToRegistry>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    1ce6:	cf 93       	push	r28
    1ce8:	df 93       	push	r29
    1cea:	00 d0       	rcall	.+0      	; 0x1cec <vQueueAddToRegistry+0x6>
    1cec:	00 d0       	rcall	.+0      	; 0x1cee <vQueueAddToRegistry+0x8>
    1cee:	1f 92       	push	r1
    1cf0:	cd b7       	in	r28, 0x3d	; 61
    1cf2:	de b7       	in	r29, 0x3e	; 62
    1cf4:	9b 83       	std	Y+3, r25	; 0x03
    1cf6:	8a 83       	std	Y+2, r24	; 0x02
    1cf8:	7d 83       	std	Y+5, r23	; 0x05
    1cfa:	6c 83       	std	Y+4, r22	; 0x04
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    1cfc:	19 82       	std	Y+1, r1	; 0x01
    1cfe:	2e c0       	rjmp	.+92     	; 0x1d5c <vQueueAddToRegistry+0x76>
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
    1d00:	89 81       	ldd	r24, Y+1	; 0x01
    1d02:	88 2f       	mov	r24, r24
    1d04:	90 e0       	ldi	r25, 0x00	; 0
    1d06:	88 0f       	add	r24, r24
    1d08:	99 1f       	adc	r25, r25
    1d0a:	88 0f       	add	r24, r24
    1d0c:	99 1f       	adc	r25, r25
    1d0e:	83 58       	subi	r24, 0x83	; 131
    1d10:	97 4f       	sbci	r25, 0xF7	; 247
    1d12:	fc 01       	movw	r30, r24
    1d14:	80 81       	ld	r24, Z
    1d16:	91 81       	ldd	r25, Z+1	; 0x01
    1d18:	00 97       	sbiw	r24, 0x00	; 0
    1d1a:	e9 f4       	brne	.+58     	; 0x1d56 <vQueueAddToRegistry+0x70>
			{
				/* Store the information on this queue. */
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
    1d1c:	89 81       	ldd	r24, Y+1	; 0x01
    1d1e:	88 2f       	mov	r24, r24
    1d20:	90 e0       	ldi	r25, 0x00	; 0
    1d22:	88 0f       	add	r24, r24
    1d24:	99 1f       	adc	r25, r25
    1d26:	88 0f       	add	r24, r24
    1d28:	99 1f       	adc	r25, r25
    1d2a:	83 58       	subi	r24, 0x83	; 131
    1d2c:	97 4f       	sbci	r25, 0xF7	; 247
    1d2e:	2c 81       	ldd	r18, Y+4	; 0x04
    1d30:	3d 81       	ldd	r19, Y+5	; 0x05
    1d32:	fc 01       	movw	r30, r24
    1d34:	31 83       	std	Z+1, r19	; 0x01
    1d36:	20 83       	st	Z, r18
				xQueueRegistry[ ux ].xHandle = xQueue;
    1d38:	89 81       	ldd	r24, Y+1	; 0x01
    1d3a:	88 2f       	mov	r24, r24
    1d3c:	90 e0       	ldi	r25, 0x00	; 0
    1d3e:	88 0f       	add	r24, r24
    1d40:	99 1f       	adc	r25, r25
    1d42:	88 0f       	add	r24, r24
    1d44:	99 1f       	adc	r25, r25
    1d46:	81 58       	subi	r24, 0x81	; 129
    1d48:	97 4f       	sbci	r25, 0xF7	; 247
    1d4a:	2a 81       	ldd	r18, Y+2	; 0x02
    1d4c:	3b 81       	ldd	r19, Y+3	; 0x03
    1d4e:	fc 01       	movw	r30, r24
    1d50:	31 83       	std	Z+1, r19	; 0x01
    1d52:	20 83       	st	Z, r18

				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
				break;
    1d54:	06 c0       	rjmp	.+12     	; 0x1d62 <vQueueAddToRegistry+0x7c>
	{
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    1d56:	89 81       	ldd	r24, Y+1	; 0x01
    1d58:	8f 5f       	subi	r24, 0xFF	; 255
    1d5a:	89 83       	std	Y+1, r24	; 0x01
    1d5c:	89 81       	ldd	r24, Y+1	; 0x01
    1d5e:	8a 30       	cpi	r24, 0x0A	; 10
    1d60:	78 f2       	brcs	.-98     	; 0x1d00 <vQueueAddToRegistry+0x1a>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    1d62:	0f 90       	pop	r0
    1d64:	0f 90       	pop	r0
    1d66:	0f 90       	pop	r0
    1d68:	0f 90       	pop	r0
    1d6a:	0f 90       	pop	r0
    1d6c:	df 91       	pop	r29
    1d6e:	cf 91       	pop	r28
    1d70:	08 95       	ret

00001d72 <xTaskGenericCreate>:
static void prvResetNextTaskUnblockTime( void );

/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    1d72:	af 92       	push	r10
    1d74:	bf 92       	push	r11
    1d76:	cf 92       	push	r12
    1d78:	df 92       	push	r13
    1d7a:	ef 92       	push	r14
    1d7c:	ff 92       	push	r15
    1d7e:	0f 93       	push	r16
    1d80:	1f 93       	push	r17
    1d82:	cf 93       	push	r28
    1d84:	df 93       	push	r29
    1d86:	cd b7       	in	r28, 0x3d	; 61
    1d88:	de b7       	in	r29, 0x3e	; 62
    1d8a:	64 97       	sbiw	r28, 0x14	; 20
    1d8c:	0f b6       	in	r0, 0x3f	; 63
    1d8e:	f8 94       	cli
    1d90:	de bf       	out	0x3e, r29	; 62
    1d92:	0f be       	out	0x3f, r0	; 63
    1d94:	cd bf       	out	0x3d, r28	; 61
    1d96:	9f 83       	std	Y+7, r25	; 0x07
    1d98:	8e 83       	std	Y+6, r24	; 0x06
    1d9a:	79 87       	std	Y+9, r23	; 0x09
    1d9c:	68 87       	std	Y+8, r22	; 0x08
    1d9e:	5b 87       	std	Y+11, r21	; 0x0b
    1da0:	4a 87       	std	Y+10, r20	; 0x0a
    1da2:	3d 87       	std	Y+13, r19	; 0x0d
    1da4:	2c 87       	std	Y+12, r18	; 0x0c
    1da6:	0e 87       	std	Y+14, r16	; 0x0e
    1da8:	f8 8a       	std	Y+16, r15	; 0x10
    1daa:	ef 86       	std	Y+15, r14	; 0x0f
    1dac:	da 8a       	std	Y+18, r13	; 0x12
    1dae:	c9 8a       	std	Y+17, r12	; 0x11
    1db0:	bc 8a       	std	Y+20, r11	; 0x14
    1db2:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    1db4:	29 89       	ldd	r18, Y+17	; 0x11
    1db6:	3a 89       	ldd	r19, Y+18	; 0x12
    1db8:	8a 85       	ldd	r24, Y+10	; 0x0a
    1dba:	9b 85       	ldd	r25, Y+11	; 0x0b
    1dbc:	b9 01       	movw	r22, r18
    1dbe:	0e 94 fc 15 	call	0x2bf8	; 0x2bf8 <prvAllocateTCBAndStack>
    1dc2:	9b 83       	std	Y+3, r25	; 0x03
    1dc4:	8a 83       	std	Y+2, r24	; 0x02

	if( pxNewTCB != NULL )
    1dc6:	8a 81       	ldd	r24, Y+2	; 0x02
    1dc8:	9b 81       	ldd	r25, Y+3	; 0x03
    1dca:	00 97       	sbiw	r24, 0x00	; 0
    1dcc:	09 f4       	brne	.+2      	; 0x1dd0 <xTaskGenericCreate+0x5e>
    1dce:	91 c0       	rjmp	.+290    	; 0x1ef2 <xTaskGenericCreate+0x180>
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
    1dd0:	8a 81       	ldd	r24, Y+2	; 0x02
    1dd2:	9b 81       	ldd	r25, Y+3	; 0x03
    1dd4:	fc 01       	movw	r30, r24
    1dd6:	27 89       	ldd	r18, Z+23	; 0x17
    1dd8:	30 8d       	ldd	r19, Z+24	; 0x18
    1dda:	8a 85       	ldd	r24, Y+10	; 0x0a
    1ddc:	9b 85       	ldd	r25, Y+11	; 0x0b
    1dde:	01 97       	sbiw	r24, 0x01	; 1
    1de0:	82 0f       	add	r24, r18
    1de2:	93 1f       	adc	r25, r19
    1de4:	9d 83       	std	Y+5, r25	; 0x05
    1de6:	8c 83       	std	Y+4, r24	; 0x04
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif /* portSTACK_GROWTH */

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    1de8:	4a 85       	ldd	r20, Y+10	; 0x0a
    1dea:	5b 85       	ldd	r21, Y+11	; 0x0b
    1dec:	2b 89       	ldd	r18, Y+19	; 0x13
    1dee:	3c 89       	ldd	r19, Y+20	; 0x14
    1df0:	68 85       	ldd	r22, Y+8	; 0x08
    1df2:	79 85       	ldd	r23, Y+9	; 0x09
    1df4:	8a 81       	ldd	r24, Y+2	; 0x02
    1df6:	9b 81       	ldd	r25, Y+3	; 0x03
    1df8:	8a 01       	movw	r16, r20
    1dfa:	4e 85       	ldd	r20, Y+14	; 0x0e
    1dfc:	0e 94 f5 14 	call	0x29ea	; 0x29ea <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1e00:	4c 85       	ldd	r20, Y+12	; 0x0c
    1e02:	5d 85       	ldd	r21, Y+13	; 0x0d
    1e04:	2e 81       	ldd	r18, Y+6	; 0x06
    1e06:	3f 81       	ldd	r19, Y+7	; 0x07
    1e08:	8c 81       	ldd	r24, Y+4	; 0x04
    1e0a:	9d 81       	ldd	r25, Y+5	; 0x05
    1e0c:	b9 01       	movw	r22, r18
    1e0e:	0e 94 1e 05 	call	0xa3c	; 0xa3c <pxPortInitialiseStack>
    1e12:	9c 01       	movw	r18, r24
    1e14:	8a 81       	ldd	r24, Y+2	; 0x02
    1e16:	9b 81       	ldd	r25, Y+3	; 0x03
    1e18:	fc 01       	movw	r30, r24
    1e1a:	31 83       	std	Z+1, r19	; 0x01
    1e1c:	20 83       	st	Z, r18
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
    1e1e:	8f 85       	ldd	r24, Y+15	; 0x0f
    1e20:	98 89       	ldd	r25, Y+16	; 0x10
    1e22:	00 97       	sbiw	r24, 0x00	; 0
    1e24:	39 f0       	breq	.+14     	; 0x1e34 <xTaskGenericCreate+0xc2>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    1e26:	8f 85       	ldd	r24, Y+15	; 0x0f
    1e28:	98 89       	ldd	r25, Y+16	; 0x10
    1e2a:	2a 81       	ldd	r18, Y+2	; 0x02
    1e2c:	3b 81       	ldd	r19, Y+3	; 0x03
    1e2e:	fc 01       	movw	r30, r24
    1e30:	31 83       	std	Z+1, r19	; 0x01
    1e32:	20 83       	st	Z, r18
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
    1e34:	0f b6       	in	r0, 0x3f	; 63
    1e36:	f8 94       	cli
    1e38:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    1e3a:	80 91 6a 08 	lds	r24, 0x086A
    1e3e:	8f 5f       	subi	r24, 0xFF	; 255
    1e40:	80 93 6a 08 	sts	0x086A, r24
			if( pxCurrentTCB == NULL )
    1e44:	80 91 1c 08 	lds	r24, 0x081C
    1e48:	90 91 1d 08 	lds	r25, 0x081D
    1e4c:	00 97       	sbiw	r24, 0x00	; 0
    1e4e:	69 f4       	brne	.+26     	; 0x1e6a <xTaskGenericCreate+0xf8>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    1e50:	8a 81       	ldd	r24, Y+2	; 0x02
    1e52:	9b 81       	ldd	r25, Y+3	; 0x03
    1e54:	90 93 1d 08 	sts	0x081D, r25
    1e58:	80 93 1c 08 	sts	0x081C, r24

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    1e5c:	80 91 6a 08 	lds	r24, 0x086A
    1e60:	81 30       	cpi	r24, 0x01	; 1
    1e62:	b1 f4       	brne	.+44     	; 0x1e90 <xTaskGenericCreate+0x11e>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    1e64:	0e 94 6e 15 	call	0x2adc	; 0x2adc <prvInitialiseTaskLists>
    1e68:	13 c0       	rjmp	.+38     	; 0x1e90 <xTaskGenericCreate+0x11e>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1e6a:	80 91 6e 08 	lds	r24, 0x086E
    1e6e:	88 23       	and	r24, r24
    1e70:	79 f4       	brne	.+30     	; 0x1e90 <xTaskGenericCreate+0x11e>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1e72:	80 91 1c 08 	lds	r24, 0x081C
    1e76:	90 91 1d 08 	lds	r25, 0x081D
    1e7a:	fc 01       	movw	r30, r24
    1e7c:	96 89       	ldd	r25, Z+22	; 0x16
    1e7e:	8e 85       	ldd	r24, Y+14	; 0x0e
    1e80:	89 17       	cp	r24, r25
    1e82:	30 f0       	brcs	.+12     	; 0x1e90 <xTaskGenericCreate+0x11e>
					{
						pxCurrentTCB = pxNewTCB;
    1e84:	8a 81       	ldd	r24, Y+2	; 0x02
    1e86:	9b 81       	ldd	r25, Y+3	; 0x03
    1e88:	90 93 1d 08 	sts	0x081D, r25
    1e8c:	80 93 1c 08 	sts	0x081C, r24
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
    1e90:	80 91 72 08 	lds	r24, 0x0872
    1e94:	8f 5f       	subi	r24, 0xFF	; 255
    1e96:	80 93 72 08 	sts	0x0872, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
    1e9a:	8a 81       	ldd	r24, Y+2	; 0x02
    1e9c:	9b 81       	ldd	r25, Y+3	; 0x03
    1e9e:	fc 01       	movw	r30, r24
    1ea0:	96 89       	ldd	r25, Z+22	; 0x16
    1ea2:	80 91 6d 08 	lds	r24, 0x086D
    1ea6:	89 17       	cp	r24, r25
    1ea8:	30 f4       	brcc	.+12     	; 0x1eb6 <xTaskGenericCreate+0x144>
    1eaa:	8a 81       	ldd	r24, Y+2	; 0x02
    1eac:	9b 81       	ldd	r25, Y+3	; 0x03
    1eae:	fc 01       	movw	r30, r24
    1eb0:	86 89       	ldd	r24, Z+22	; 0x16
    1eb2:	80 93 6d 08 	sts	0x086D, r24
    1eb6:	8a 81       	ldd	r24, Y+2	; 0x02
    1eb8:	9b 81       	ldd	r25, Y+3	; 0x03
    1eba:	ac 01       	movw	r20, r24
    1ebc:	4e 5f       	subi	r20, 0xFE	; 254
    1ebe:	5f 4f       	sbci	r21, 0xFF	; 255
    1ec0:	8a 81       	ldd	r24, Y+2	; 0x02
    1ec2:	9b 81       	ldd	r25, Y+3	; 0x03
    1ec4:	fc 01       	movw	r30, r24
    1ec6:	86 89       	ldd	r24, Z+22	; 0x16
    1ec8:	28 2f       	mov	r18, r24
    1eca:	30 e0       	ldi	r19, 0x00	; 0
    1ecc:	c9 01       	movw	r24, r18
    1ece:	88 0f       	add	r24, r24
    1ed0:	99 1f       	adc	r25, r25
    1ed2:	88 0f       	add	r24, r24
    1ed4:	99 1f       	adc	r25, r25
    1ed6:	88 0f       	add	r24, r24
    1ed8:	99 1f       	adc	r25, r25
    1eda:	82 0f       	add	r24, r18
    1edc:	93 1f       	adc	r25, r19
    1ede:	82 5e       	subi	r24, 0xE2	; 226
    1ee0:	97 4f       	sbci	r25, 0xF7	; 247
    1ee2:	ba 01       	movw	r22, r20
    1ee4:	0e 94 61 08 	call	0x10c2	; 0x10c2 <vListInsertEnd>

			xReturn = pdPASS;
    1ee8:	81 e0       	ldi	r24, 0x01	; 1
    1eea:	89 83       	std	Y+1, r24	; 0x01
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    1eec:	0f 90       	pop	r0
    1eee:	0f be       	out	0x3f, r0	; 63
    1ef0:	02 c0       	rjmp	.+4      	; 0x1ef6 <xTaskGenericCreate+0x184>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1ef2:	8f ef       	ldi	r24, 0xFF	; 255
    1ef4:	89 83       	std	Y+1, r24	; 0x01
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    1ef6:	89 81       	ldd	r24, Y+1	; 0x01
    1ef8:	81 30       	cpi	r24, 0x01	; 1
    1efa:	79 f4       	brne	.+30     	; 0x1f1a <xTaskGenericCreate+0x1a8>
	{
		if( xSchedulerRunning != pdFALSE )
    1efc:	80 91 6e 08 	lds	r24, 0x086E
    1f00:	88 23       	and	r24, r24
    1f02:	59 f0       	breq	.+22     	; 0x1f1a <xTaskGenericCreate+0x1a8>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1f04:	80 91 1c 08 	lds	r24, 0x081C
    1f08:	90 91 1d 08 	lds	r25, 0x081D
    1f0c:	fc 01       	movw	r30, r24
    1f0e:	96 89       	ldd	r25, Z+22	; 0x16
    1f10:	8e 85       	ldd	r24, Y+14	; 0x0e
    1f12:	98 17       	cp	r25, r24
    1f14:	10 f4       	brcc	.+4      	; 0x1f1a <xTaskGenericCreate+0x1a8>
			{
				taskYIELD_IF_USING_PREEMPTION();
    1f16:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vPortYield>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
    1f1a:	89 81       	ldd	r24, Y+1	; 0x01
}
    1f1c:	64 96       	adiw	r28, 0x14	; 20
    1f1e:	0f b6       	in	r0, 0x3f	; 63
    1f20:	f8 94       	cli
    1f22:	de bf       	out	0x3e, r29	; 62
    1f24:	0f be       	out	0x3f, r0	; 63
    1f26:	cd bf       	out	0x3d, r28	; 61
    1f28:	df 91       	pop	r29
    1f2a:	cf 91       	pop	r28
    1f2c:	1f 91       	pop	r17
    1f2e:	0f 91       	pop	r16
    1f30:	ff 90       	pop	r15
    1f32:	ef 90       	pop	r14
    1f34:	df 90       	pop	r13
    1f36:	cf 90       	pop	r12
    1f38:	bf 90       	pop	r11
    1f3a:	af 90       	pop	r10
    1f3c:	08 95       	ret

00001f3e <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    1f3e:	cf 93       	push	r28
    1f40:	df 93       	push	r29
    1f42:	cd b7       	in	r28, 0x3d	; 61
    1f44:	de b7       	in	r29, 0x3e	; 62
    1f46:	2a 97       	sbiw	r28, 0x0a	; 10
    1f48:	0f b6       	in	r0, 0x3f	; 63
    1f4a:	f8 94       	cli
    1f4c:	de bf       	out	0x3e, r29	; 62
    1f4e:	0f be       	out	0x3f, r0	; 63
    1f50:	cd bf       	out	0x3d, r28	; 61
    1f52:	98 87       	std	Y+8, r25	; 0x08
    1f54:	8f 83       	std	Y+7, r24	; 0x07
    1f56:	7a 87       	std	Y+10, r23	; 0x0a
    1f58:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    1f5a:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    1f5c:	0e 94 84 11 	call	0x2308	; 0x2308 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    1f60:	80 91 6b 08 	lds	r24, 0x086B
    1f64:	90 91 6c 08 	lds	r25, 0x086C
    1f68:	9b 83       	std	Y+3, r25	; 0x03
    1f6a:	8a 83       	std	Y+2, r24	; 0x02

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1f6c:	8f 81       	ldd	r24, Y+7	; 0x07
    1f6e:	98 85       	ldd	r25, Y+8	; 0x08
    1f70:	fc 01       	movw	r30, r24
    1f72:	20 81       	ld	r18, Z
    1f74:	31 81       	ldd	r19, Z+1	; 0x01
    1f76:	89 85       	ldd	r24, Y+9	; 0x09
    1f78:	9a 85       	ldd	r25, Y+10	; 0x0a
    1f7a:	82 0f       	add	r24, r18
    1f7c:	93 1f       	adc	r25, r19
    1f7e:	9d 83       	std	Y+5, r25	; 0x05
    1f80:	8c 83       	std	Y+4, r24	; 0x04

			if( xConstTickCount < *pxPreviousWakeTime )
    1f82:	8f 81       	ldd	r24, Y+7	; 0x07
    1f84:	98 85       	ldd	r25, Y+8	; 0x08
    1f86:	fc 01       	movw	r30, r24
    1f88:	20 81       	ld	r18, Z
    1f8a:	31 81       	ldd	r19, Z+1	; 0x01
    1f8c:	8a 81       	ldd	r24, Y+2	; 0x02
    1f8e:	9b 81       	ldd	r25, Y+3	; 0x03
    1f90:	82 17       	cp	r24, r18
    1f92:	93 07       	cpc	r25, r19
    1f94:	a0 f4       	brcc	.+40     	; 0x1fbe <vTaskDelayUntil+0x80>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    1f96:	8f 81       	ldd	r24, Y+7	; 0x07
    1f98:	98 85       	ldd	r25, Y+8	; 0x08
    1f9a:	fc 01       	movw	r30, r24
    1f9c:	20 81       	ld	r18, Z
    1f9e:	31 81       	ldd	r19, Z+1	; 0x01
    1fa0:	8c 81       	ldd	r24, Y+4	; 0x04
    1fa2:	9d 81       	ldd	r25, Y+5	; 0x05
    1fa4:	82 17       	cp	r24, r18
    1fa6:	93 07       	cpc	r25, r19
    1fa8:	e8 f4       	brcc	.+58     	; 0x1fe4 <vTaskDelayUntil+0xa6>
    1faa:	2c 81       	ldd	r18, Y+4	; 0x04
    1fac:	3d 81       	ldd	r19, Y+5	; 0x05
    1fae:	8a 81       	ldd	r24, Y+2	; 0x02
    1fb0:	9b 81       	ldd	r25, Y+3	; 0x03
    1fb2:	82 17       	cp	r24, r18
    1fb4:	93 07       	cpc	r25, r19
    1fb6:	b0 f4       	brcc	.+44     	; 0x1fe4 <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
    1fb8:	81 e0       	ldi	r24, 0x01	; 1
    1fba:	89 83       	std	Y+1, r24	; 0x01
    1fbc:	13 c0       	rjmp	.+38     	; 0x1fe4 <vTaskDelayUntil+0xa6>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    1fbe:	8f 81       	ldd	r24, Y+7	; 0x07
    1fc0:	98 85       	ldd	r25, Y+8	; 0x08
    1fc2:	fc 01       	movw	r30, r24
    1fc4:	20 81       	ld	r18, Z
    1fc6:	31 81       	ldd	r19, Z+1	; 0x01
    1fc8:	8c 81       	ldd	r24, Y+4	; 0x04
    1fca:	9d 81       	ldd	r25, Y+5	; 0x05
    1fcc:	82 17       	cp	r24, r18
    1fce:	93 07       	cpc	r25, r19
    1fd0:	38 f0       	brcs	.+14     	; 0x1fe0 <vTaskDelayUntil+0xa2>
    1fd2:	2c 81       	ldd	r18, Y+4	; 0x04
    1fd4:	3d 81       	ldd	r19, Y+5	; 0x05
    1fd6:	8a 81       	ldd	r24, Y+2	; 0x02
    1fd8:	9b 81       	ldd	r25, Y+3	; 0x03
    1fda:	82 17       	cp	r24, r18
    1fdc:	93 07       	cpc	r25, r19
    1fde:	10 f4       	brcc	.+4      	; 0x1fe4 <vTaskDelayUntil+0xa6>
				{
					xShouldDelay = pdTRUE;
    1fe0:	81 e0       	ldi	r24, 0x01	; 1
    1fe2:	89 83       	std	Y+1, r24	; 0x01
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1fe4:	8f 81       	ldd	r24, Y+7	; 0x07
    1fe6:	98 85       	ldd	r25, Y+8	; 0x08
    1fe8:	2c 81       	ldd	r18, Y+4	; 0x04
    1fea:	3d 81       	ldd	r19, Y+5	; 0x05
    1fec:	fc 01       	movw	r30, r24
    1fee:	31 83       	std	Z+1, r19	; 0x01
    1ff0:	20 83       	st	Z, r18

			if( xShouldDelay != pdFALSE )
    1ff2:	89 81       	ldd	r24, Y+1	; 0x01
    1ff4:	88 23       	and	r24, r24
    1ff6:	59 f0       	breq	.+22     	; 0x200e <vTaskDelayUntil+0xd0>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1ff8:	80 91 1c 08 	lds	r24, 0x081C
    1ffc:	90 91 1d 08 	lds	r25, 0x081D
    2000:	02 96       	adiw	r24, 0x02	; 2
    2002:	0e 94 28 09 	call	0x1250	; 0x1250 <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2006:	8c 81       	ldd	r24, Y+4	; 0x04
    2008:	9d 81       	ldd	r25, Y+5	; 0x05
    200a:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    200e:	0e 94 90 11 	call	0x2320	; 0x2320 <xTaskResumeAll>
    2012:	8e 83       	std	Y+6, r24	; 0x06

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2014:	8e 81       	ldd	r24, Y+6	; 0x06
    2016:	88 23       	and	r24, r24
    2018:	11 f4       	brne	.+4      	; 0x201e <vTaskDelayUntil+0xe0>
		{
			portYIELD_WITHIN_API();
    201a:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    201e:	2a 96       	adiw	r28, 0x0a	; 10
    2020:	0f b6       	in	r0, 0x3f	; 63
    2022:	f8 94       	cli
    2024:	de bf       	out	0x3e, r29	; 62
    2026:	0f be       	out	0x3f, r0	; 63
    2028:	cd bf       	out	0x3d, r28	; 61
    202a:	df 91       	pop	r29
    202c:	cf 91       	pop	r28
    202e:	08 95       	ret

00002030 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    2030:	cf 93       	push	r28
    2032:	df 93       	push	r29
    2034:	00 d0       	rcall	.+0      	; 0x2036 <vTaskDelay+0x6>
    2036:	00 d0       	rcall	.+0      	; 0x2038 <vTaskDelay+0x8>
    2038:	1f 92       	push	r1
    203a:	cd b7       	in	r28, 0x3d	; 61
    203c:	de b7       	in	r29, 0x3e	; 62
    203e:	9d 83       	std	Y+5, r25	; 0x05
    2040:	8c 83       	std	Y+4, r24	; 0x04
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;
    2042:	19 82       	std	Y+1, r1	; 0x01


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    2044:	8c 81       	ldd	r24, Y+4	; 0x04
    2046:	9d 81       	ldd	r25, Y+5	; 0x05
    2048:	00 97       	sbiw	r24, 0x00	; 0
    204a:	d1 f0       	breq	.+52     	; 0x2080 <vTaskDelay+0x50>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    204c:	0e 94 84 11 	call	0x2308	; 0x2308 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2050:	20 91 6b 08 	lds	r18, 0x086B
    2054:	30 91 6c 08 	lds	r19, 0x086C
    2058:	8c 81       	ldd	r24, Y+4	; 0x04
    205a:	9d 81       	ldd	r25, Y+5	; 0x05
    205c:	82 0f       	add	r24, r18
    205e:	93 1f       	adc	r25, r19
    2060:	9b 83       	std	Y+3, r25	; 0x03
    2062:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    2064:	80 91 1c 08 	lds	r24, 0x081C
    2068:	90 91 1d 08 	lds	r25, 0x081D
    206c:	02 96       	adiw	r24, 0x02	; 2
    206e:	0e 94 28 09 	call	0x1250	; 0x1250 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2072:	8a 81       	ldd	r24, Y+2	; 0x02
    2074:	9b 81       	ldd	r25, Y+3	; 0x03
    2076:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    207a:	0e 94 90 11 	call	0x2320	; 0x2320 <xTaskResumeAll>
    207e:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2080:	89 81       	ldd	r24, Y+1	; 0x01
    2082:	88 23       	and	r24, r24
    2084:	11 f4       	brne	.+4      	; 0x208a <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    2086:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    208a:	0f 90       	pop	r0
    208c:	0f 90       	pop	r0
    208e:	0f 90       	pop	r0
    2090:	0f 90       	pop	r0
    2092:	0f 90       	pop	r0
    2094:	df 91       	pop	r29
    2096:	cf 91       	pop	r28
    2098:	08 95       	ret

0000209a <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    209a:	cf 93       	push	r28
    209c:	df 93       	push	r29
    209e:	00 d0       	rcall	.+0      	; 0x20a0 <vTaskSuspend+0x6>
    20a0:	00 d0       	rcall	.+0      	; 0x20a2 <vTaskSuspend+0x8>
    20a2:	cd b7       	in	r28, 0x3d	; 61
    20a4:	de b7       	in	r29, 0x3e	; 62
    20a6:	9c 83       	std	Y+4, r25	; 0x04
    20a8:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    20aa:	0f b6       	in	r0, 0x3f	; 63
    20ac:	f8 94       	cli
    20ae:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    20b0:	8b 81       	ldd	r24, Y+3	; 0x03
    20b2:	9c 81       	ldd	r25, Y+4	; 0x04
    20b4:	00 97       	sbiw	r24, 0x00	; 0
    20b6:	29 f4       	brne	.+10     	; 0x20c2 <vTaskSuspend+0x28>
    20b8:	80 91 1c 08 	lds	r24, 0x081C
    20bc:	90 91 1d 08 	lds	r25, 0x081D
    20c0:	02 c0       	rjmp	.+4      	; 0x20c6 <vTaskSuspend+0x2c>
    20c2:	8b 81       	ldd	r24, Y+3	; 0x03
    20c4:	9c 81       	ldd	r25, Y+4	; 0x04
    20c6:	9a 83       	std	Y+2, r25	; 0x02
    20c8:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    20ca:	89 81       	ldd	r24, Y+1	; 0x01
    20cc:	9a 81       	ldd	r25, Y+2	; 0x02
    20ce:	02 96       	adiw	r24, 0x02	; 2
    20d0:	0e 94 28 09 	call	0x1250	; 0x1250 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    20d4:	89 81       	ldd	r24, Y+1	; 0x01
    20d6:	9a 81       	ldd	r25, Y+2	; 0x02
    20d8:	fc 01       	movw	r30, r24
    20da:	84 89       	ldd	r24, Z+20	; 0x14
    20dc:	95 89       	ldd	r25, Z+21	; 0x15
    20de:	00 97       	sbiw	r24, 0x00	; 0
    20e0:	29 f0       	breq	.+10     	; 0x20ec <vTaskSuspend+0x52>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    20e2:	89 81       	ldd	r24, Y+1	; 0x01
    20e4:	9a 81       	ldd	r25, Y+2	; 0x02
    20e6:	0c 96       	adiw	r24, 0x0c	; 12
    20e8:	0e 94 28 09 	call	0x1250	; 0x1250 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    20ec:	89 81       	ldd	r24, Y+1	; 0x01
    20ee:	9a 81       	ldd	r25, Y+2	; 0x02
    20f0:	02 96       	adiw	r24, 0x02	; 2
    20f2:	bc 01       	movw	r22, r24
    20f4:	81 e6       	ldi	r24, 0x61	; 97
    20f6:	98 e0       	ldi	r25, 0x08	; 8
    20f8:	0e 94 61 08 	call	0x10c2	; 0x10c2 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    20fc:	0f 90       	pop	r0
    20fe:	0f be       	out	0x3f, r0	; 63

		if( pxTCB == pxCurrentTCB )
    2100:	80 91 1c 08 	lds	r24, 0x081C
    2104:	90 91 1d 08 	lds	r25, 0x081D
    2108:	29 81       	ldd	r18, Y+1	; 0x01
    210a:	3a 81       	ldd	r19, Y+2	; 0x02
    210c:	28 17       	cp	r18, r24
    210e:	39 07       	cpc	r19, r25
    2110:	a9 f4       	brne	.+42     	; 0x213c <vTaskSuspend+0xa2>
		{
			if( xSchedulerRunning != pdFALSE )
    2112:	80 91 6e 08 	lds	r24, 0x086E
    2116:	88 23       	and	r24, r24
    2118:	19 f0       	breq	.+6      	; 0x2120 <vTaskSuspend+0x86>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    211a:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vPortYield>
    211e:	19 c0       	rjmp	.+50     	; 0x2152 <vTaskSuspend+0xb8>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    2120:	90 91 61 08 	lds	r25, 0x0861
    2124:	80 91 6a 08 	lds	r24, 0x086A
    2128:	98 17       	cp	r25, r24
    212a:	29 f4       	brne	.+10     	; 0x2136 <vTaskSuspend+0x9c>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    212c:	10 92 1d 08 	sts	0x081D, r1
    2130:	10 92 1c 08 	sts	0x081C, r1
    2134:	0e c0       	rjmp	.+28     	; 0x2152 <vTaskSuspend+0xb8>
				}
				else
				{
					vTaskSwitchContext();
    2136:	0e 94 2b 13 	call	0x2656	; 0x2656 <vTaskSwitchContext>
    213a:	0b c0       	rjmp	.+22     	; 0x2152 <vTaskSuspend+0xb8>
				}
			}
		}
		else
		{
			if( xSchedulerRunning != pdFALSE )
    213c:	80 91 6e 08 	lds	r24, 0x086E
    2140:	88 23       	and	r24, r24
    2142:	39 f0       	breq	.+14     	; 0x2152 <vTaskSuspend+0xb8>
			{
				/* A task other than the currently running task was suspended,
				reset the next expected unblock time in case it referred to the
				task that is now in the Suspended state. */
				taskENTER_CRITICAL();
    2144:	0f b6       	in	r0, 0x3f	; 63
    2146:	f8 94       	cli
    2148:	0f 92       	push	r0
				{
					prvResetNextTaskUnblockTime();
    214a:	0e 94 46 16 	call	0x2c8c	; 0x2c8c <prvResetNextTaskUnblockTime>
				}
				taskEXIT_CRITICAL();
    214e:	0f 90       	pop	r0
    2150:	0f be       	out	0x3f, r0	; 63
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    2152:	0f 90       	pop	r0
    2154:	0f 90       	pop	r0
    2156:	0f 90       	pop	r0
    2158:	0f 90       	pop	r0
    215a:	df 91       	pop	r29
    215c:	cf 91       	pop	r28
    215e:	08 95       	ret

00002160 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    2160:	cf 93       	push	r28
    2162:	df 93       	push	r29
    2164:	00 d0       	rcall	.+0      	; 0x2166 <prvTaskIsTaskSuspended+0x6>
    2166:	00 d0       	rcall	.+0      	; 0x2168 <prvTaskIsTaskSuspended+0x8>
    2168:	1f 92       	push	r1
    216a:	cd b7       	in	r28, 0x3d	; 61
    216c:	de b7       	in	r29, 0x3e	; 62
    216e:	9d 83       	std	Y+5, r25	; 0x05
    2170:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    2172:	19 82       	std	Y+1, r1	; 0x01
	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
    2174:	8c 81       	ldd	r24, Y+4	; 0x04
    2176:	9d 81       	ldd	r25, Y+5	; 0x05
    2178:	9b 83       	std	Y+3, r25	; 0x03
    217a:	8a 83       	std	Y+2, r24	; 0x02

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    217c:	8a 81       	ldd	r24, Y+2	; 0x02
    217e:	9b 81       	ldd	r25, Y+3	; 0x03
    2180:	fc 01       	movw	r30, r24
    2182:	82 85       	ldd	r24, Z+10	; 0x0a
    2184:	93 85       	ldd	r25, Z+11	; 0x0b
    2186:	f8 e0       	ldi	r31, 0x08	; 8
    2188:	81 36       	cpi	r24, 0x61	; 97
    218a:	9f 07       	cpc	r25, r31
    218c:	91 f4       	brne	.+36     	; 0x21b2 <prvTaskIsTaskSuspended+0x52>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    218e:	8a 81       	ldd	r24, Y+2	; 0x02
    2190:	9b 81       	ldd	r25, Y+3	; 0x03
    2192:	fc 01       	movw	r30, r24
    2194:	84 89       	ldd	r24, Z+20	; 0x14
    2196:	95 89       	ldd	r25, Z+21	; 0x15
    2198:	f8 e0       	ldi	r31, 0x08	; 8
    219a:	88 35       	cpi	r24, 0x58	; 88
    219c:	9f 07       	cpc	r25, r31
    219e:	49 f0       	breq	.+18     	; 0x21b2 <prvTaskIsTaskSuspended+0x52>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
    21a0:	8a 81       	ldd	r24, Y+2	; 0x02
    21a2:	9b 81       	ldd	r25, Y+3	; 0x03
    21a4:	fc 01       	movw	r30, r24
    21a6:	84 89       	ldd	r24, Z+20	; 0x14
    21a8:	95 89       	ldd	r25, Z+21	; 0x15
    21aa:	00 97       	sbiw	r24, 0x00	; 0
    21ac:	11 f4       	brne	.+4      	; 0x21b2 <prvTaskIsTaskSuspended+0x52>
				{
					xReturn = pdTRUE;
    21ae:	81 e0       	ldi	r24, 0x01	; 1
    21b0:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    21b2:	89 81       	ldd	r24, Y+1	; 0x01
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    21b4:	0f 90       	pop	r0
    21b6:	0f 90       	pop	r0
    21b8:	0f 90       	pop	r0
    21ba:	0f 90       	pop	r0
    21bc:	0f 90       	pop	r0
    21be:	df 91       	pop	r29
    21c0:	cf 91       	pop	r28
    21c2:	08 95       	ret

000021c4 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    21c4:	cf 93       	push	r28
    21c6:	df 93       	push	r29
    21c8:	00 d0       	rcall	.+0      	; 0x21ca <vTaskResume+0x6>
    21ca:	00 d0       	rcall	.+0      	; 0x21cc <vTaskResume+0x8>
    21cc:	cd b7       	in	r28, 0x3d	; 61
    21ce:	de b7       	in	r29, 0x3e	; 62
    21d0:	9c 83       	std	Y+4, r25	; 0x04
    21d2:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
    21d4:	8b 81       	ldd	r24, Y+3	; 0x03
    21d6:	9c 81       	ldd	r25, Y+4	; 0x04
    21d8:	9a 83       	std	Y+2, r25	; 0x02
    21da:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    21dc:	89 81       	ldd	r24, Y+1	; 0x01
    21de:	9a 81       	ldd	r25, Y+2	; 0x02
    21e0:	00 97       	sbiw	r24, 0x00	; 0
    21e2:	09 f4       	brne	.+2      	; 0x21e6 <vTaskResume+0x22>
    21e4:	4f c0       	rjmp	.+158    	; 0x2284 <vTaskResume+0xc0>
    21e6:	80 91 1c 08 	lds	r24, 0x081C
    21ea:	90 91 1d 08 	lds	r25, 0x081D
    21ee:	29 81       	ldd	r18, Y+1	; 0x01
    21f0:	3a 81       	ldd	r19, Y+2	; 0x02
    21f2:	28 17       	cp	r18, r24
    21f4:	39 07       	cpc	r19, r25
    21f6:	09 f4       	brne	.+2      	; 0x21fa <vTaskResume+0x36>
    21f8:	45 c0       	rjmp	.+138    	; 0x2284 <vTaskResume+0xc0>
		{
			taskENTER_CRITICAL();
    21fa:	0f b6       	in	r0, 0x3f	; 63
    21fc:	f8 94       	cli
    21fe:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    2200:	89 81       	ldd	r24, Y+1	; 0x01
    2202:	9a 81       	ldd	r25, Y+2	; 0x02
    2204:	0e 94 b0 10 	call	0x2160	; 0x2160 <prvTaskIsTaskSuspended>
    2208:	81 30       	cpi	r24, 0x01	; 1
    220a:	d1 f5       	brne	.+116    	; 0x2280 <vTaskResume+0xbc>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
    220c:	89 81       	ldd	r24, Y+1	; 0x01
    220e:	9a 81       	ldd	r25, Y+2	; 0x02
    2210:	02 96       	adiw	r24, 0x02	; 2
    2212:	0e 94 28 09 	call	0x1250	; 0x1250 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2216:	89 81       	ldd	r24, Y+1	; 0x01
    2218:	9a 81       	ldd	r25, Y+2	; 0x02
    221a:	fc 01       	movw	r30, r24
    221c:	96 89       	ldd	r25, Z+22	; 0x16
    221e:	80 91 6d 08 	lds	r24, 0x086D
    2222:	89 17       	cp	r24, r25
    2224:	30 f4       	brcc	.+12     	; 0x2232 <vTaskResume+0x6e>
    2226:	89 81       	ldd	r24, Y+1	; 0x01
    2228:	9a 81       	ldd	r25, Y+2	; 0x02
    222a:	fc 01       	movw	r30, r24
    222c:	86 89       	ldd	r24, Z+22	; 0x16
    222e:	80 93 6d 08 	sts	0x086D, r24
    2232:	89 81       	ldd	r24, Y+1	; 0x01
    2234:	9a 81       	ldd	r25, Y+2	; 0x02
    2236:	ac 01       	movw	r20, r24
    2238:	4e 5f       	subi	r20, 0xFE	; 254
    223a:	5f 4f       	sbci	r21, 0xFF	; 255
    223c:	89 81       	ldd	r24, Y+1	; 0x01
    223e:	9a 81       	ldd	r25, Y+2	; 0x02
    2240:	fc 01       	movw	r30, r24
    2242:	86 89       	ldd	r24, Z+22	; 0x16
    2244:	28 2f       	mov	r18, r24
    2246:	30 e0       	ldi	r19, 0x00	; 0
    2248:	c9 01       	movw	r24, r18
    224a:	88 0f       	add	r24, r24
    224c:	99 1f       	adc	r25, r25
    224e:	88 0f       	add	r24, r24
    2250:	99 1f       	adc	r25, r25
    2252:	88 0f       	add	r24, r24
    2254:	99 1f       	adc	r25, r25
    2256:	82 0f       	add	r24, r18
    2258:	93 1f       	adc	r25, r19
    225a:	82 5e       	subi	r24, 0xE2	; 226
    225c:	97 4f       	sbci	r25, 0xF7	; 247
    225e:	ba 01       	movw	r22, r20
    2260:	0e 94 61 08 	call	0x10c2	; 0x10c2 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2264:	89 81       	ldd	r24, Y+1	; 0x01
    2266:	9a 81       	ldd	r25, Y+2	; 0x02
    2268:	fc 01       	movw	r30, r24
    226a:	26 89       	ldd	r18, Z+22	; 0x16
    226c:	80 91 1c 08 	lds	r24, 0x081C
    2270:	90 91 1d 08 	lds	r25, 0x081D
    2274:	fc 01       	movw	r30, r24
    2276:	86 89       	ldd	r24, Z+22	; 0x16
    2278:	28 17       	cp	r18, r24
    227a:	10 f0       	brcs	.+4      	; 0x2280 <vTaskResume+0xbc>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    227c:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    2280:	0f 90       	pop	r0
    2282:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    2284:	0f 90       	pop	r0
    2286:	0f 90       	pop	r0
    2288:	0f 90       	pop	r0
    228a:	0f 90       	pop	r0
    228c:	df 91       	pop	r29
    228e:	cf 91       	pop	r28
    2290:	08 95       	ret

00002292 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    2292:	af 92       	push	r10
    2294:	bf 92       	push	r11
    2296:	cf 92       	push	r12
    2298:	df 92       	push	r13
    229a:	ef 92       	push	r14
    229c:	ff 92       	push	r15
    229e:	0f 93       	push	r16
    22a0:	cf 93       	push	r28
    22a2:	df 93       	push	r29
    22a4:	1f 92       	push	r1
    22a6:	cd b7       	in	r28, 0x3d	; 61
    22a8:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
    22aa:	a1 2c       	mov	r10, r1
    22ac:	b1 2c       	mov	r11, r1
    22ae:	c1 2c       	mov	r12, r1
    22b0:	d1 2c       	mov	r13, r1
    22b2:	e1 2c       	mov	r14, r1
    22b4:	f1 2c       	mov	r15, r1
    22b6:	00 e0       	ldi	r16, 0x00	; 0
    22b8:	20 e0       	ldi	r18, 0x00	; 0
    22ba:	30 e0       	ldi	r19, 0x00	; 0
    22bc:	45 e5       	ldi	r20, 0x55	; 85
    22be:	50 e0       	ldi	r21, 0x00	; 0
    22c0:	64 e9       	ldi	r22, 0x94	; 148
    22c2:	71 e0       	ldi	r23, 0x01	; 1
    22c4:	85 ee       	ldi	r24, 0xE5	; 229
    22c6:	94 e1       	ldi	r25, 0x14	; 20
    22c8:	0e 94 b9 0e 	call	0x1d72	; 0x1d72 <xTaskGenericCreate>
    22cc:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    22ce:	89 81       	ldd	r24, Y+1	; 0x01
    22d0:	81 30       	cpi	r24, 0x01	; 1
    22d2:	79 f4       	brne	.+30     	; 0x22f2 <vTaskStartScheduler+0x60>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    22d4:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
    22d6:	81 e0       	ldi	r24, 0x01	; 1
    22d8:	80 93 6e 08 	sts	0x086E, r24
		xTickCount = ( TickType_t ) 0U;
    22dc:	10 92 6c 08 	sts	0x086C, r1
    22e0:	10 92 6b 08 	sts	0x086B, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    22e4:	0e 94 c7 06 	call	0xd8e	; 0xd8e <xPortStartScheduler>
    22e8:	88 23       	and	r24, r24
    22ea:	19 f0       	breq	.+6      	; 0x22f2 <vTaskStartScheduler+0x60>
		{
			/* Should not reach here as if the scheduler is running the
			function will not return. */
			xSchedulerRunning = pdTRUE;
    22ec:	81 e0       	ldi	r24, 0x01	; 1
    22ee:	80 93 6e 08 	sts	0x086E, r24
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
    22f2:	0f 90       	pop	r0
    22f4:	df 91       	pop	r29
    22f6:	cf 91       	pop	r28
    22f8:	0f 91       	pop	r16
    22fa:	ff 90       	pop	r15
    22fc:	ef 90       	pop	r14
    22fe:	df 90       	pop	r13
    2300:	cf 90       	pop	r12
    2302:	bf 90       	pop	r11
    2304:	af 90       	pop	r10
    2306:	08 95       	ret

00002308 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    2308:	cf 93       	push	r28
    230a:	df 93       	push	r29
    230c:	cd b7       	in	r28, 0x3d	; 61
    230e:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    2310:	80 91 73 08 	lds	r24, 0x0873
    2314:	8f 5f       	subi	r24, 0xFF	; 255
    2316:	80 93 73 08 	sts	0x0873, r24
}
    231a:	df 91       	pop	r29
    231c:	cf 91       	pop	r28
    231e:	08 95       	ret

00002320 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    2320:	cf 93       	push	r28
    2322:	df 93       	push	r29
    2324:	00 d0       	rcall	.+0      	; 0x2326 <xTaskResumeAll+0x6>
    2326:	1f 92       	push	r1
    2328:	cd b7       	in	r28, 0x3d	; 61
    232a:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
    232c:	19 82       	std	Y+1, r1	; 0x01
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    232e:	0f b6       	in	r0, 0x3f	; 63
    2330:	f8 94       	cli
    2332:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2334:	80 91 73 08 	lds	r24, 0x0873
    2338:	81 50       	subi	r24, 0x01	; 1
    233a:	80 93 73 08 	sts	0x0873, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    233e:	80 91 73 08 	lds	r24, 0x0873
    2342:	88 23       	and	r24, r24
    2344:	09 f0       	breq	.+2      	; 0x2348 <xTaskResumeAll+0x28>
    2346:	71 c0       	rjmp	.+226    	; 0x242a <xTaskResumeAll+0x10a>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    2348:	80 91 6a 08 	lds	r24, 0x086A
    234c:	88 23       	and	r24, r24
    234e:	09 f4       	brne	.+2      	; 0x2352 <xTaskResumeAll+0x32>
    2350:	6c c0       	rjmp	.+216    	; 0x242a <xTaskResumeAll+0x10a>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    2352:	49 c0       	rjmp	.+146    	; 0x23e6 <xTaskResumeAll+0xc6>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    2354:	80 91 5d 08 	lds	r24, 0x085D
    2358:	90 91 5e 08 	lds	r25, 0x085E
    235c:	fc 01       	movw	r30, r24
    235e:	86 81       	ldd	r24, Z+6	; 0x06
    2360:	97 81       	ldd	r25, Z+7	; 0x07
    2362:	9b 83       	std	Y+3, r25	; 0x03
    2364:	8a 83       	std	Y+2, r24	; 0x02
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2366:	8a 81       	ldd	r24, Y+2	; 0x02
    2368:	9b 81       	ldd	r25, Y+3	; 0x03
    236a:	0c 96       	adiw	r24, 0x0c	; 12
    236c:	0e 94 28 09 	call	0x1250	; 0x1250 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    2370:	8a 81       	ldd	r24, Y+2	; 0x02
    2372:	9b 81       	ldd	r25, Y+3	; 0x03
    2374:	02 96       	adiw	r24, 0x02	; 2
    2376:	0e 94 28 09 	call	0x1250	; 0x1250 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    237a:	8a 81       	ldd	r24, Y+2	; 0x02
    237c:	9b 81       	ldd	r25, Y+3	; 0x03
    237e:	fc 01       	movw	r30, r24
    2380:	96 89       	ldd	r25, Z+22	; 0x16
    2382:	80 91 6d 08 	lds	r24, 0x086D
    2386:	89 17       	cp	r24, r25
    2388:	30 f4       	brcc	.+12     	; 0x2396 <xTaskResumeAll+0x76>
    238a:	8a 81       	ldd	r24, Y+2	; 0x02
    238c:	9b 81       	ldd	r25, Y+3	; 0x03
    238e:	fc 01       	movw	r30, r24
    2390:	86 89       	ldd	r24, Z+22	; 0x16
    2392:	80 93 6d 08 	sts	0x086D, r24
    2396:	8a 81       	ldd	r24, Y+2	; 0x02
    2398:	9b 81       	ldd	r25, Y+3	; 0x03
    239a:	ac 01       	movw	r20, r24
    239c:	4e 5f       	subi	r20, 0xFE	; 254
    239e:	5f 4f       	sbci	r21, 0xFF	; 255
    23a0:	8a 81       	ldd	r24, Y+2	; 0x02
    23a2:	9b 81       	ldd	r25, Y+3	; 0x03
    23a4:	fc 01       	movw	r30, r24
    23a6:	86 89       	ldd	r24, Z+22	; 0x16
    23a8:	28 2f       	mov	r18, r24
    23aa:	30 e0       	ldi	r19, 0x00	; 0
    23ac:	c9 01       	movw	r24, r18
    23ae:	88 0f       	add	r24, r24
    23b0:	99 1f       	adc	r25, r25
    23b2:	88 0f       	add	r24, r24
    23b4:	99 1f       	adc	r25, r25
    23b6:	88 0f       	add	r24, r24
    23b8:	99 1f       	adc	r25, r25
    23ba:	82 0f       	add	r24, r18
    23bc:	93 1f       	adc	r25, r19
    23be:	82 5e       	subi	r24, 0xE2	; 226
    23c0:	97 4f       	sbci	r25, 0xF7	; 247
    23c2:	ba 01       	movw	r22, r20
    23c4:	0e 94 61 08 	call	0x10c2	; 0x10c2 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    23c8:	8a 81       	ldd	r24, Y+2	; 0x02
    23ca:	9b 81       	ldd	r25, Y+3	; 0x03
    23cc:	fc 01       	movw	r30, r24
    23ce:	26 89       	ldd	r18, Z+22	; 0x16
    23d0:	80 91 1c 08 	lds	r24, 0x081C
    23d4:	90 91 1d 08 	lds	r25, 0x081D
    23d8:	fc 01       	movw	r30, r24
    23da:	86 89       	ldd	r24, Z+22	; 0x16
    23dc:	28 17       	cp	r18, r24
    23de:	18 f0       	brcs	.+6      	; 0x23e6 <xTaskResumeAll+0xc6>
					{
						xYieldPending = pdTRUE;
    23e0:	81 e0       	ldi	r24, 0x01	; 1
    23e2:	80 93 70 08 	sts	0x0870, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    23e6:	80 91 58 08 	lds	r24, 0x0858
    23ea:	88 23       	and	r24, r24
    23ec:	09 f0       	breq	.+2      	; 0x23f0 <xTaskResumeAll+0xd0>
    23ee:	b2 cf       	rjmp	.-156    	; 0x2354 <xTaskResumeAll+0x34>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
    23f0:	80 91 6f 08 	lds	r24, 0x086F
    23f4:	88 23       	and	r24, r24
    23f6:	89 f0       	breq	.+34     	; 0x241a <xTaskResumeAll+0xfa>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    23f8:	0c c0       	rjmp	.+24     	; 0x2412 <xTaskResumeAll+0xf2>
					{
						if( xTaskIncrementTick() != pdFALSE )
    23fa:	0e 94 35 12 	call	0x246a	; 0x246a <xTaskIncrementTick>
    23fe:	88 23       	and	r24, r24
    2400:	19 f0       	breq	.+6      	; 0x2408 <xTaskResumeAll+0xe8>
						{
							xYieldPending = pdTRUE;
    2402:	81 e0       	ldi	r24, 0x01	; 1
    2404:	80 93 70 08 	sts	0x0870, r24
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
    2408:	80 91 6f 08 	lds	r24, 0x086F
    240c:	81 50       	subi	r24, 0x01	; 1
    240e:	80 93 6f 08 	sts	0x086F, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    2412:	80 91 6f 08 	lds	r24, 0x086F
    2416:	88 23       	and	r24, r24
    2418:	81 f7       	brne	.-32     	; 0x23fa <xTaskResumeAll+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
    241a:	80 91 70 08 	lds	r24, 0x0870
    241e:	81 30       	cpi	r24, 0x01	; 1
    2420:	21 f4       	brne	.+8      	; 0x242a <xTaskResumeAll+0x10a>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    2422:	81 e0       	ldi	r24, 0x01	; 1
    2424:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    2426:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    242a:	0f 90       	pop	r0
    242c:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    242e:	89 81       	ldd	r24, Y+1	; 0x01
}
    2430:	0f 90       	pop	r0
    2432:	0f 90       	pop	r0
    2434:	0f 90       	pop	r0
    2436:	df 91       	pop	r29
    2438:	cf 91       	pop	r28
    243a:	08 95       	ret

0000243c <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    243c:	cf 93       	push	r28
    243e:	df 93       	push	r29
    2440:	00 d0       	rcall	.+0      	; 0x2442 <xTaskGetTickCount+0x6>
    2442:	cd b7       	in	r28, 0x3d	; 61
    2444:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    2446:	0f b6       	in	r0, 0x3f	; 63
    2448:	f8 94       	cli
    244a:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    244c:	80 91 6b 08 	lds	r24, 0x086B
    2450:	90 91 6c 08 	lds	r25, 0x086C
    2454:	9a 83       	std	Y+2, r25	; 0x02
    2456:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    2458:	0f 90       	pop	r0
    245a:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    245c:	89 81       	ldd	r24, Y+1	; 0x01
    245e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2460:	0f 90       	pop	r0
    2462:	0f 90       	pop	r0
    2464:	df 91       	pop	r29
    2466:	cf 91       	pop	r28
    2468:	08 95       	ret

0000246a <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    246a:	cf 93       	push	r28
    246c:	df 93       	push	r29
    246e:	cd b7       	in	r28, 0x3d	; 61
    2470:	de b7       	in	r29, 0x3e	; 62
    2472:	29 97       	sbiw	r28, 0x09	; 9
    2474:	0f b6       	in	r0, 0x3f	; 63
    2476:	f8 94       	cli
    2478:	de bf       	out	0x3e, r29	; 62
    247a:	0f be       	out	0x3f, r0	; 63
    247c:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    247e:	19 82       	std	Y+1, r1	; 0x01

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2480:	80 91 73 08 	lds	r24, 0x0873
    2484:	88 23       	and	r24, r24
    2486:	09 f0       	breq	.+2      	; 0x248a <xTaskIncrementTick+0x20>
    2488:	cf c0       	rjmp	.+414    	; 0x2628 <xTaskIncrementTick+0x1be>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
    248a:	80 91 6b 08 	lds	r24, 0x086B
    248e:	90 91 6c 08 	lds	r25, 0x086C
    2492:	01 96       	adiw	r24, 0x01	; 1
    2494:	90 93 6c 08 	sts	0x086C, r25
    2498:	80 93 6b 08 	sts	0x086B, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    249c:	80 91 6b 08 	lds	r24, 0x086B
    24a0:	90 91 6c 08 	lds	r25, 0x086C
    24a4:	9b 83       	std	Y+3, r25	; 0x03
    24a6:	8a 83       	std	Y+2, r24	; 0x02

			if( xConstTickCount == ( TickType_t ) 0U )
    24a8:	8a 81       	ldd	r24, Y+2	; 0x02
    24aa:	9b 81       	ldd	r25, Y+3	; 0x03
    24ac:	00 97       	sbiw	r24, 0x00	; 0
    24ae:	d9 f4       	brne	.+54     	; 0x24e6 <xTaskIncrementTick+0x7c>
			{
				taskSWITCH_DELAYED_LISTS();
    24b0:	80 91 54 08 	lds	r24, 0x0854
    24b4:	90 91 55 08 	lds	r25, 0x0855
    24b8:	9d 83       	std	Y+5, r25	; 0x05
    24ba:	8c 83       	std	Y+4, r24	; 0x04
    24bc:	80 91 56 08 	lds	r24, 0x0856
    24c0:	90 91 57 08 	lds	r25, 0x0857
    24c4:	90 93 55 08 	sts	0x0855, r25
    24c8:	80 93 54 08 	sts	0x0854, r24
    24cc:	8c 81       	ldd	r24, Y+4	; 0x04
    24ce:	9d 81       	ldd	r25, Y+5	; 0x05
    24d0:	90 93 57 08 	sts	0x0857, r25
    24d4:	80 93 56 08 	sts	0x0856, r24
    24d8:	80 91 71 08 	lds	r24, 0x0871
    24dc:	8f 5f       	subi	r24, 0xFF	; 255
    24de:	80 93 71 08 	sts	0x0871, r24
    24e2:	0e 94 46 16 	call	0x2c8c	; 0x2c8c <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    24e6:	80 91 0d 01 	lds	r24, 0x010D
    24ea:	90 91 0e 01 	lds	r25, 0x010E
    24ee:	2a 81       	ldd	r18, Y+2	; 0x02
    24f0:	3b 81       	ldd	r19, Y+3	; 0x03
    24f2:	28 17       	cp	r18, r24
    24f4:	39 07       	cpc	r19, r25
    24f6:	08 f4       	brcc	.+2      	; 0x24fa <xTaskIncrementTick+0x90>
    24f8:	77 c0       	rjmp	.+238    	; 0x25e8 <xTaskIncrementTick+0x17e>
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    24fa:	80 91 54 08 	lds	r24, 0x0854
    24fe:	90 91 55 08 	lds	r25, 0x0855
    2502:	fc 01       	movw	r30, r24
    2504:	80 81       	ld	r24, Z
    2506:	88 23       	and	r24, r24
    2508:	39 f4       	brne	.+14     	; 0x2518 <xTaskIncrementTick+0xae>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
    250a:	8f ef       	ldi	r24, 0xFF	; 255
    250c:	9f ef       	ldi	r25, 0xFF	; 255
    250e:	90 93 0e 01 	sts	0x010E, r25
    2512:	80 93 0d 01 	sts	0x010D, r24
						break;
    2516:	68 c0       	rjmp	.+208    	; 0x25e8 <xTaskIncrementTick+0x17e>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2518:	80 91 54 08 	lds	r24, 0x0854
    251c:	90 91 55 08 	lds	r25, 0x0855
    2520:	fc 01       	movw	r30, r24
    2522:	85 81       	ldd	r24, Z+5	; 0x05
    2524:	96 81       	ldd	r25, Z+6	; 0x06
    2526:	fc 01       	movw	r30, r24
    2528:	86 81       	ldd	r24, Z+6	; 0x06
    252a:	97 81       	ldd	r25, Z+7	; 0x07
    252c:	9f 83       	std	Y+7, r25	; 0x07
    252e:	8e 83       	std	Y+6, r24	; 0x06
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    2530:	8e 81       	ldd	r24, Y+6	; 0x06
    2532:	9f 81       	ldd	r25, Y+7	; 0x07
    2534:	fc 01       	movw	r30, r24
    2536:	82 81       	ldd	r24, Z+2	; 0x02
    2538:	93 81       	ldd	r25, Z+3	; 0x03
    253a:	99 87       	std	Y+9, r25	; 0x09
    253c:	88 87       	std	Y+8, r24	; 0x08

						if( xConstTickCount < xItemValue )
    253e:	2a 81       	ldd	r18, Y+2	; 0x02
    2540:	3b 81       	ldd	r19, Y+3	; 0x03
    2542:	88 85       	ldd	r24, Y+8	; 0x08
    2544:	99 85       	ldd	r25, Y+9	; 0x09
    2546:	28 17       	cp	r18, r24
    2548:	39 07       	cpc	r19, r25
    254a:	38 f4       	brcc	.+14     	; 0x255a <xTaskIncrementTick+0xf0>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
    254c:	88 85       	ldd	r24, Y+8	; 0x08
    254e:	99 85       	ldd	r25, Y+9	; 0x09
    2550:	90 93 0e 01 	sts	0x010E, r25
    2554:	80 93 0d 01 	sts	0x010D, r24
							break;
    2558:	47 c0       	rjmp	.+142    	; 0x25e8 <xTaskIncrementTick+0x17e>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    255a:	8e 81       	ldd	r24, Y+6	; 0x06
    255c:	9f 81       	ldd	r25, Y+7	; 0x07
    255e:	02 96       	adiw	r24, 0x02	; 2
    2560:	0e 94 28 09 	call	0x1250	; 0x1250 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    2564:	8e 81       	ldd	r24, Y+6	; 0x06
    2566:	9f 81       	ldd	r25, Y+7	; 0x07
    2568:	fc 01       	movw	r30, r24
    256a:	84 89       	ldd	r24, Z+20	; 0x14
    256c:	95 89       	ldd	r25, Z+21	; 0x15
    256e:	00 97       	sbiw	r24, 0x00	; 0
    2570:	29 f0       	breq	.+10     	; 0x257c <xTaskIncrementTick+0x112>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2572:	8e 81       	ldd	r24, Y+6	; 0x06
    2574:	9f 81       	ldd	r25, Y+7	; 0x07
    2576:	0c 96       	adiw	r24, 0x0c	; 12
    2578:	0e 94 28 09 	call	0x1250	; 0x1250 <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    257c:	8e 81       	ldd	r24, Y+6	; 0x06
    257e:	9f 81       	ldd	r25, Y+7	; 0x07
    2580:	fc 01       	movw	r30, r24
    2582:	96 89       	ldd	r25, Z+22	; 0x16
    2584:	80 91 6d 08 	lds	r24, 0x086D
    2588:	89 17       	cp	r24, r25
    258a:	30 f4       	brcc	.+12     	; 0x2598 <xTaskIncrementTick+0x12e>
    258c:	8e 81       	ldd	r24, Y+6	; 0x06
    258e:	9f 81       	ldd	r25, Y+7	; 0x07
    2590:	fc 01       	movw	r30, r24
    2592:	86 89       	ldd	r24, Z+22	; 0x16
    2594:	80 93 6d 08 	sts	0x086D, r24
    2598:	8e 81       	ldd	r24, Y+6	; 0x06
    259a:	9f 81       	ldd	r25, Y+7	; 0x07
    259c:	ac 01       	movw	r20, r24
    259e:	4e 5f       	subi	r20, 0xFE	; 254
    25a0:	5f 4f       	sbci	r21, 0xFF	; 255
    25a2:	8e 81       	ldd	r24, Y+6	; 0x06
    25a4:	9f 81       	ldd	r25, Y+7	; 0x07
    25a6:	fc 01       	movw	r30, r24
    25a8:	86 89       	ldd	r24, Z+22	; 0x16
    25aa:	28 2f       	mov	r18, r24
    25ac:	30 e0       	ldi	r19, 0x00	; 0
    25ae:	c9 01       	movw	r24, r18
    25b0:	88 0f       	add	r24, r24
    25b2:	99 1f       	adc	r25, r25
    25b4:	88 0f       	add	r24, r24
    25b6:	99 1f       	adc	r25, r25
    25b8:	88 0f       	add	r24, r24
    25ba:	99 1f       	adc	r25, r25
    25bc:	82 0f       	add	r24, r18
    25be:	93 1f       	adc	r25, r19
    25c0:	82 5e       	subi	r24, 0xE2	; 226
    25c2:	97 4f       	sbci	r25, 0xF7	; 247
    25c4:	ba 01       	movw	r22, r20
    25c6:	0e 94 61 08 	call	0x10c2	; 0x10c2 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    25ca:	8e 81       	ldd	r24, Y+6	; 0x06
    25cc:	9f 81       	ldd	r25, Y+7	; 0x07
    25ce:	fc 01       	movw	r30, r24
    25d0:	26 89       	ldd	r18, Z+22	; 0x16
    25d2:	80 91 1c 08 	lds	r24, 0x081C
    25d6:	90 91 1d 08 	lds	r25, 0x081D
    25da:	fc 01       	movw	r30, r24
    25dc:	86 89       	ldd	r24, Z+22	; 0x16
    25de:	28 17       	cp	r18, r24
    25e0:	10 f0       	brcs	.+4      	; 0x25e6 <xTaskIncrementTick+0x17c>
							{
								xSwitchRequired = pdTRUE;
    25e2:	81 e0       	ldi	r24, 0x01	; 1
    25e4:	89 83       	std	Y+1, r24	; 0x01
								mtCOVERAGE_TEST_MARKER();
							}
						}
						#endif /* configUSE_PREEMPTION */
					}
				}
    25e6:	89 cf       	rjmp	.-238    	; 0x24fa <xTaskIncrementTick+0x90>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    25e8:	80 91 1c 08 	lds	r24, 0x081C
    25ec:	90 91 1d 08 	lds	r25, 0x081D
    25f0:	fc 01       	movw	r30, r24
    25f2:	86 89       	ldd	r24, Z+22	; 0x16
    25f4:	28 2f       	mov	r18, r24
    25f6:	30 e0       	ldi	r19, 0x00	; 0
    25f8:	c9 01       	movw	r24, r18
    25fa:	88 0f       	add	r24, r24
    25fc:	99 1f       	adc	r25, r25
    25fe:	88 0f       	add	r24, r24
    2600:	99 1f       	adc	r25, r25
    2602:	88 0f       	add	r24, r24
    2604:	99 1f       	adc	r25, r25
    2606:	82 0f       	add	r24, r18
    2608:	93 1f       	adc	r25, r19
    260a:	82 5e       	subi	r24, 0xE2	; 226
    260c:	97 4f       	sbci	r25, 0xF7	; 247
    260e:	fc 01       	movw	r30, r24
    2610:	80 81       	ld	r24, Z
    2612:	82 30       	cpi	r24, 0x02	; 2
    2614:	10 f0       	brcs	.+4      	; 0x261a <xTaskIncrementTick+0x1b0>
			{
				xSwitchRequired = pdTRUE;
    2616:	81 e0       	ldi	r24, 0x01	; 1
    2618:	89 83       	std	Y+1, r24	; 0x01

		#if ( configUSE_TICK_HOOK == 1 )
		{
			/* Guard against the tick hook being called when the pended tick
			count is being unwound (when the scheduler is being unlocked). */
			if( uxPendedTicks == ( UBaseType_t ) 0U )
    261a:	80 91 6f 08 	lds	r24, 0x086F
    261e:	88 23       	and	r24, r24
    2620:	51 f4       	brne	.+20     	; 0x2636 <xTaskIncrementTick+0x1cc>
			{
				vApplicationTickHook();
    2622:	0e 94 ac 04 	call	0x958	; 0x958 <vApplicationTickHook>
    2626:	07 c0       	rjmp	.+14     	; 0x2636 <xTaskIncrementTick+0x1cc>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    2628:	80 91 6f 08 	lds	r24, 0x086F
    262c:	8f 5f       	subi	r24, 0xFF	; 255
    262e:	80 93 6f 08 	sts	0x086F, r24

		/* The tick hook gets called at regular intervals, even if the
		scheduler is locked. */
		#if ( configUSE_TICK_HOOK == 1 )
		{
			vApplicationTickHook();
    2632:	0e 94 ac 04 	call	0x958	; 0x958 <vApplicationTickHook>
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    2636:	80 91 70 08 	lds	r24, 0x0870
    263a:	88 23       	and	r24, r24
    263c:	11 f0       	breq	.+4      	; 0x2642 <xTaskIncrementTick+0x1d8>
		{
			xSwitchRequired = pdTRUE;
    263e:	81 e0       	ldi	r24, 0x01	; 1
    2640:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    2642:	89 81       	ldd	r24, Y+1	; 0x01
}
    2644:	29 96       	adiw	r28, 0x09	; 9
    2646:	0f b6       	in	r0, 0x3f	; 63
    2648:	f8 94       	cli
    264a:	de bf       	out	0x3e, r29	; 62
    264c:	0f be       	out	0x3f, r0	; 63
    264e:	cd bf       	out	0x3d, r28	; 61
    2650:	df 91       	pop	r29
    2652:	cf 91       	pop	r28
    2654:	08 95       	ret

00002656 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    2656:	cf 93       	push	r28
    2658:	df 93       	push	r29
    265a:	00 d0       	rcall	.+0      	; 0x265c <vTaskSwitchContext+0x6>
    265c:	cd b7       	in	r28, 0x3d	; 61
    265e:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    2660:	80 91 73 08 	lds	r24, 0x0873
    2664:	88 23       	and	r24, r24
    2666:	21 f0       	breq	.+8      	; 0x2670 <vTaskSwitchContext+0x1a>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    2668:	81 e0       	ldi	r24, 0x01	; 1
    266a:	80 93 70 08 	sts	0x0870, r24
    266e:	5d c0       	rjmp	.+186    	; 0x272a <vTaskSwitchContext+0xd4>
	}
	else
	{
		xYieldPending = pdFALSE;
    2670:	10 92 70 08 	sts	0x0870, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    2674:	05 c0       	rjmp	.+10     	; 0x2680 <vTaskSwitchContext+0x2a>
    2676:	80 91 6d 08 	lds	r24, 0x086D
    267a:	81 50       	subi	r24, 0x01	; 1
    267c:	80 93 6d 08 	sts	0x086D, r24
    2680:	80 91 6d 08 	lds	r24, 0x086D
    2684:	28 2f       	mov	r18, r24
    2686:	30 e0       	ldi	r19, 0x00	; 0
    2688:	c9 01       	movw	r24, r18
    268a:	88 0f       	add	r24, r24
    268c:	99 1f       	adc	r25, r25
    268e:	88 0f       	add	r24, r24
    2690:	99 1f       	adc	r25, r25
    2692:	88 0f       	add	r24, r24
    2694:	99 1f       	adc	r25, r25
    2696:	82 0f       	add	r24, r18
    2698:	93 1f       	adc	r25, r19
    269a:	82 5e       	subi	r24, 0xE2	; 226
    269c:	97 4f       	sbci	r25, 0xF7	; 247
    269e:	fc 01       	movw	r30, r24
    26a0:	80 81       	ld	r24, Z
    26a2:	88 23       	and	r24, r24
    26a4:	41 f3       	breq	.-48     	; 0x2676 <vTaskSwitchContext+0x20>
    26a6:	80 91 6d 08 	lds	r24, 0x086D
    26aa:	28 2f       	mov	r18, r24
    26ac:	30 e0       	ldi	r19, 0x00	; 0
    26ae:	c9 01       	movw	r24, r18
    26b0:	88 0f       	add	r24, r24
    26b2:	99 1f       	adc	r25, r25
    26b4:	88 0f       	add	r24, r24
    26b6:	99 1f       	adc	r25, r25
    26b8:	88 0f       	add	r24, r24
    26ba:	99 1f       	adc	r25, r25
    26bc:	82 0f       	add	r24, r18
    26be:	93 1f       	adc	r25, r19
    26c0:	82 5e       	subi	r24, 0xE2	; 226
    26c2:	97 4f       	sbci	r25, 0xF7	; 247
    26c4:	9a 83       	std	Y+2, r25	; 0x02
    26c6:	89 83       	std	Y+1, r24	; 0x01
    26c8:	89 81       	ldd	r24, Y+1	; 0x01
    26ca:	9a 81       	ldd	r25, Y+2	; 0x02
    26cc:	fc 01       	movw	r30, r24
    26ce:	81 81       	ldd	r24, Z+1	; 0x01
    26d0:	92 81       	ldd	r25, Z+2	; 0x02
    26d2:	fc 01       	movw	r30, r24
    26d4:	22 81       	ldd	r18, Z+2	; 0x02
    26d6:	33 81       	ldd	r19, Z+3	; 0x03
    26d8:	89 81       	ldd	r24, Y+1	; 0x01
    26da:	9a 81       	ldd	r25, Y+2	; 0x02
    26dc:	fc 01       	movw	r30, r24
    26de:	32 83       	std	Z+2, r19	; 0x02
    26e0:	21 83       	std	Z+1, r18	; 0x01
    26e2:	89 81       	ldd	r24, Y+1	; 0x01
    26e4:	9a 81       	ldd	r25, Y+2	; 0x02
    26e6:	fc 01       	movw	r30, r24
    26e8:	21 81       	ldd	r18, Z+1	; 0x01
    26ea:	32 81       	ldd	r19, Z+2	; 0x02
    26ec:	89 81       	ldd	r24, Y+1	; 0x01
    26ee:	9a 81       	ldd	r25, Y+2	; 0x02
    26f0:	03 96       	adiw	r24, 0x03	; 3
    26f2:	28 17       	cp	r18, r24
    26f4:	39 07       	cpc	r19, r25
    26f6:	69 f4       	brne	.+26     	; 0x2712 <vTaskSwitchContext+0xbc>
    26f8:	89 81       	ldd	r24, Y+1	; 0x01
    26fa:	9a 81       	ldd	r25, Y+2	; 0x02
    26fc:	fc 01       	movw	r30, r24
    26fe:	81 81       	ldd	r24, Z+1	; 0x01
    2700:	92 81       	ldd	r25, Z+2	; 0x02
    2702:	fc 01       	movw	r30, r24
    2704:	22 81       	ldd	r18, Z+2	; 0x02
    2706:	33 81       	ldd	r19, Z+3	; 0x03
    2708:	89 81       	ldd	r24, Y+1	; 0x01
    270a:	9a 81       	ldd	r25, Y+2	; 0x02
    270c:	fc 01       	movw	r30, r24
    270e:	32 83       	std	Z+2, r19	; 0x02
    2710:	21 83       	std	Z+1, r18	; 0x01
    2712:	89 81       	ldd	r24, Y+1	; 0x01
    2714:	9a 81       	ldd	r25, Y+2	; 0x02
    2716:	fc 01       	movw	r30, r24
    2718:	81 81       	ldd	r24, Z+1	; 0x01
    271a:	92 81       	ldd	r25, Z+2	; 0x02
    271c:	fc 01       	movw	r30, r24
    271e:	86 81       	ldd	r24, Z+6	; 0x06
    2720:	97 81       	ldd	r25, Z+7	; 0x07
    2722:	90 93 1d 08 	sts	0x081D, r25
    2726:	80 93 1c 08 	sts	0x081C, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    272a:	0f 90       	pop	r0
    272c:	0f 90       	pop	r0
    272e:	df 91       	pop	r29
    2730:	cf 91       	pop	r28
    2732:	08 95       	ret

00002734 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    2734:	cf 93       	push	r28
    2736:	df 93       	push	r29
    2738:	00 d0       	rcall	.+0      	; 0x273a <vTaskPlaceOnEventList+0x6>
    273a:	00 d0       	rcall	.+0      	; 0x273c <vTaskPlaceOnEventList+0x8>
    273c:	00 d0       	rcall	.+0      	; 0x273e <vTaskPlaceOnEventList+0xa>
    273e:	cd b7       	in	r28, 0x3d	; 61
    2740:	de b7       	in	r29, 0x3e	; 62
    2742:	9c 83       	std	Y+4, r25	; 0x04
    2744:	8b 83       	std	Y+3, r24	; 0x03
    2746:	7e 83       	std	Y+6, r23	; 0x06
    2748:	6d 83       	std	Y+5, r22	; 0x05

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    274a:	80 91 1c 08 	lds	r24, 0x081C
    274e:	90 91 1d 08 	lds	r25, 0x081D
    2752:	9c 01       	movw	r18, r24
    2754:	24 5f       	subi	r18, 0xF4	; 244
    2756:	3f 4f       	sbci	r19, 0xFF	; 255
    2758:	8b 81       	ldd	r24, Y+3	; 0x03
    275a:	9c 81       	ldd	r25, Y+4	; 0x04
    275c:	b9 01       	movw	r22, r18
    275e:	0e 94 af 08 	call	0x115e	; 0x115e <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    2762:	80 91 1c 08 	lds	r24, 0x081C
    2766:	90 91 1d 08 	lds	r25, 0x081D
    276a:	02 96       	adiw	r24, 0x02	; 2
    276c:	0e 94 28 09 	call	0x1250	; 0x1250 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    2770:	8d 81       	ldd	r24, Y+5	; 0x05
    2772:	9e 81       	ldd	r25, Y+6	; 0x06
    2774:	8f 3f       	cpi	r24, 0xFF	; 255
    2776:	2f ef       	ldi	r18, 0xFF	; 255
    2778:	92 07       	cpc	r25, r18
    277a:	59 f4       	brne	.+22     	; 0x2792 <vTaskPlaceOnEventList+0x5e>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure the task is not woken by a timing event.  It will
			block indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    277c:	80 91 1c 08 	lds	r24, 0x081C
    2780:	90 91 1d 08 	lds	r25, 0x081D
    2784:	02 96       	adiw	r24, 0x02	; 2
    2786:	bc 01       	movw	r22, r24
    2788:	81 e6       	ldi	r24, 0x61	; 97
    278a:	98 e0       	ldi	r25, 0x08	; 8
    278c:	0e 94 61 08 	call	0x10c2	; 0x10c2 <vListInsertEnd>
    2790:	0e c0       	rjmp	.+28     	; 0x27ae <vTaskPlaceOnEventList+0x7a>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			scheduler will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    2792:	20 91 6b 08 	lds	r18, 0x086B
    2796:	30 91 6c 08 	lds	r19, 0x086C
    279a:	8d 81       	ldd	r24, Y+5	; 0x05
    279c:	9e 81       	ldd	r25, Y+6	; 0x06
    279e:	82 0f       	add	r24, r18
    27a0:	93 1f       	adc	r25, r19
    27a2:	9a 83       	std	Y+2, r25	; 0x02
    27a4:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    27a6:	89 81       	ldd	r24, Y+1	; 0x01
    27a8:	9a 81       	ldd	r25, Y+2	; 0x02
    27aa:	0e 94 b2 15 	call	0x2b64	; 0x2b64 <prvAddCurrentTaskToDelayedList>
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    27ae:	26 96       	adiw	r28, 0x06	; 6
    27b0:	0f b6       	in	r0, 0x3f	; 63
    27b2:	f8 94       	cli
    27b4:	de bf       	out	0x3e, r29	; 62
    27b6:	0f be       	out	0x3f, r0	; 63
    27b8:	cd bf       	out	0x3d, r28	; 61
    27ba:	df 91       	pop	r29
    27bc:	cf 91       	pop	r28
    27be:	08 95       	ret

000027c0 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    27c0:	cf 93       	push	r28
    27c2:	df 93       	push	r29
    27c4:	00 d0       	rcall	.+0      	; 0x27c6 <xTaskRemoveFromEventList+0x6>
    27c6:	00 d0       	rcall	.+0      	; 0x27c8 <xTaskRemoveFromEventList+0x8>
    27c8:	1f 92       	push	r1
    27ca:	cd b7       	in	r28, 0x3d	; 61
    27cc:	de b7       	in	r29, 0x3e	; 62
    27ce:	9d 83       	std	Y+5, r25	; 0x05
    27d0:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    27d2:	8c 81       	ldd	r24, Y+4	; 0x04
    27d4:	9d 81       	ldd	r25, Y+5	; 0x05
    27d6:	fc 01       	movw	r30, r24
    27d8:	85 81       	ldd	r24, Z+5	; 0x05
    27da:	96 81       	ldd	r25, Z+6	; 0x06
    27dc:	fc 01       	movw	r30, r24
    27de:	86 81       	ldd	r24, Z+6	; 0x06
    27e0:	97 81       	ldd	r25, Z+7	; 0x07
    27e2:	9b 83       	std	Y+3, r25	; 0x03
    27e4:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    27e6:	8a 81       	ldd	r24, Y+2	; 0x02
    27e8:	9b 81       	ldd	r25, Y+3	; 0x03
    27ea:	0c 96       	adiw	r24, 0x0c	; 12
    27ec:	0e 94 28 09 	call	0x1250	; 0x1250 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    27f0:	80 91 73 08 	lds	r24, 0x0873
    27f4:	88 23       	and	r24, r24
    27f6:	69 f5       	brne	.+90     	; 0x2852 <xTaskRemoveFromEventList+0x92>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    27f8:	8a 81       	ldd	r24, Y+2	; 0x02
    27fa:	9b 81       	ldd	r25, Y+3	; 0x03
    27fc:	02 96       	adiw	r24, 0x02	; 2
    27fe:	0e 94 28 09 	call	0x1250	; 0x1250 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    2802:	8a 81       	ldd	r24, Y+2	; 0x02
    2804:	9b 81       	ldd	r25, Y+3	; 0x03
    2806:	fc 01       	movw	r30, r24
    2808:	96 89       	ldd	r25, Z+22	; 0x16
    280a:	80 91 6d 08 	lds	r24, 0x086D
    280e:	89 17       	cp	r24, r25
    2810:	30 f4       	brcc	.+12     	; 0x281e <xTaskRemoveFromEventList+0x5e>
    2812:	8a 81       	ldd	r24, Y+2	; 0x02
    2814:	9b 81       	ldd	r25, Y+3	; 0x03
    2816:	fc 01       	movw	r30, r24
    2818:	86 89       	ldd	r24, Z+22	; 0x16
    281a:	80 93 6d 08 	sts	0x086D, r24
    281e:	8a 81       	ldd	r24, Y+2	; 0x02
    2820:	9b 81       	ldd	r25, Y+3	; 0x03
    2822:	ac 01       	movw	r20, r24
    2824:	4e 5f       	subi	r20, 0xFE	; 254
    2826:	5f 4f       	sbci	r21, 0xFF	; 255
    2828:	8a 81       	ldd	r24, Y+2	; 0x02
    282a:	9b 81       	ldd	r25, Y+3	; 0x03
    282c:	fc 01       	movw	r30, r24
    282e:	86 89       	ldd	r24, Z+22	; 0x16
    2830:	28 2f       	mov	r18, r24
    2832:	30 e0       	ldi	r19, 0x00	; 0
    2834:	c9 01       	movw	r24, r18
    2836:	88 0f       	add	r24, r24
    2838:	99 1f       	adc	r25, r25
    283a:	88 0f       	add	r24, r24
    283c:	99 1f       	adc	r25, r25
    283e:	88 0f       	add	r24, r24
    2840:	99 1f       	adc	r25, r25
    2842:	82 0f       	add	r24, r18
    2844:	93 1f       	adc	r25, r19
    2846:	82 5e       	subi	r24, 0xE2	; 226
    2848:	97 4f       	sbci	r25, 0xF7	; 247
    284a:	ba 01       	movw	r22, r20
    284c:	0e 94 61 08 	call	0x10c2	; 0x10c2 <vListInsertEnd>
    2850:	08 c0       	rjmp	.+16     	; 0x2862 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2852:	8a 81       	ldd	r24, Y+2	; 0x02
    2854:	9b 81       	ldd	r25, Y+3	; 0x03
    2856:	0c 96       	adiw	r24, 0x0c	; 12
    2858:	bc 01       	movw	r22, r24
    285a:	88 e5       	ldi	r24, 0x58	; 88
    285c:	98 e0       	ldi	r25, 0x08	; 8
    285e:	0e 94 61 08 	call	0x10c2	; 0x10c2 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    2862:	8a 81       	ldd	r24, Y+2	; 0x02
    2864:	9b 81       	ldd	r25, Y+3	; 0x03
    2866:	fc 01       	movw	r30, r24
    2868:	26 89       	ldd	r18, Z+22	; 0x16
    286a:	80 91 1c 08 	lds	r24, 0x081C
    286e:	90 91 1d 08 	lds	r25, 0x081D
    2872:	fc 01       	movw	r30, r24
    2874:	86 89       	ldd	r24, Z+22	; 0x16
    2876:	82 17       	cp	r24, r18
    2878:	30 f4       	brcc	.+12     	; 0x2886 <xTaskRemoveFromEventList+0xc6>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    287a:	81 e0       	ldi	r24, 0x01	; 1
    287c:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    287e:	81 e0       	ldi	r24, 0x01	; 1
    2880:	80 93 70 08 	sts	0x0870, r24
    2884:	01 c0       	rjmp	.+2      	; 0x2888 <xTaskRemoveFromEventList+0xc8>
	}
	else
	{
		xReturn = pdFALSE;
    2886:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2888:	89 81       	ldd	r24, Y+1	; 0x01
}
    288a:	0f 90       	pop	r0
    288c:	0f 90       	pop	r0
    288e:	0f 90       	pop	r0
    2890:	0f 90       	pop	r0
    2892:	0f 90       	pop	r0
    2894:	df 91       	pop	r29
    2896:	cf 91       	pop	r28
    2898:	08 95       	ret

0000289a <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    289a:	cf 93       	push	r28
    289c:	df 93       	push	r29
    289e:	00 d0       	rcall	.+0      	; 0x28a0 <vTaskSetTimeOutState+0x6>
    28a0:	cd b7       	in	r28, 0x3d	; 61
    28a2:	de b7       	in	r29, 0x3e	; 62
    28a4:	9a 83       	std	Y+2, r25	; 0x02
    28a6:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    28a8:	20 91 71 08 	lds	r18, 0x0871
    28ac:	89 81       	ldd	r24, Y+1	; 0x01
    28ae:	9a 81       	ldd	r25, Y+2	; 0x02
    28b0:	fc 01       	movw	r30, r24
    28b2:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    28b4:	20 91 6b 08 	lds	r18, 0x086B
    28b8:	30 91 6c 08 	lds	r19, 0x086C
    28bc:	89 81       	ldd	r24, Y+1	; 0x01
    28be:	9a 81       	ldd	r25, Y+2	; 0x02
    28c0:	fc 01       	movw	r30, r24
    28c2:	32 83       	std	Z+2, r19	; 0x02
    28c4:	21 83       	std	Z+1, r18	; 0x01
}
    28c6:	0f 90       	pop	r0
    28c8:	0f 90       	pop	r0
    28ca:	df 91       	pop	r29
    28cc:	cf 91       	pop	r28
    28ce:	08 95       	ret

000028d0 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    28d0:	cf 93       	push	r28
    28d2:	df 93       	push	r29
    28d4:	cd b7       	in	r28, 0x3d	; 61
    28d6:	de b7       	in	r29, 0x3e	; 62
    28d8:	27 97       	sbiw	r28, 0x07	; 7
    28da:	0f b6       	in	r0, 0x3f	; 63
    28dc:	f8 94       	cli
    28de:	de bf       	out	0x3e, r29	; 62
    28e0:	0f be       	out	0x3f, r0	; 63
    28e2:	cd bf       	out	0x3d, r28	; 61
    28e4:	9d 83       	std	Y+5, r25	; 0x05
    28e6:	8c 83       	std	Y+4, r24	; 0x04
    28e8:	7f 83       	std	Y+7, r23	; 0x07
    28ea:	6e 83       	std	Y+6, r22	; 0x06
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    28ec:	0f b6       	in	r0, 0x3f	; 63
    28ee:	f8 94       	cli
    28f0:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    28f2:	80 91 6b 08 	lds	r24, 0x086B
    28f6:	90 91 6c 08 	lds	r25, 0x086C
    28fa:	9b 83       	std	Y+3, r25	; 0x03
    28fc:	8a 83       	std	Y+2, r24	; 0x02

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    28fe:	8e 81       	ldd	r24, Y+6	; 0x06
    2900:	9f 81       	ldd	r25, Y+7	; 0x07
    2902:	fc 01       	movw	r30, r24
    2904:	80 81       	ld	r24, Z
    2906:	91 81       	ldd	r25, Z+1	; 0x01
    2908:	8f 3f       	cpi	r24, 0xFF	; 255
    290a:	ff ef       	ldi	r31, 0xFF	; 255
    290c:	9f 07       	cpc	r25, r31
    290e:	11 f4       	brne	.+4      	; 0x2914 <xTaskCheckForTimeOut+0x44>
			{
				xReturn = pdFALSE;
    2910:	19 82       	std	Y+1, r1	; 0x01
    2912:	45 c0       	rjmp	.+138    	; 0x299e <xTaskCheckForTimeOut+0xce>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    2914:	8c 81       	ldd	r24, Y+4	; 0x04
    2916:	9d 81       	ldd	r25, Y+5	; 0x05
    2918:	fc 01       	movw	r30, r24
    291a:	90 81       	ld	r25, Z
    291c:	80 91 71 08 	lds	r24, 0x0871
    2920:	98 17       	cp	r25, r24
    2922:	69 f0       	breq	.+26     	; 0x293e <xTaskCheckForTimeOut+0x6e>
    2924:	8c 81       	ldd	r24, Y+4	; 0x04
    2926:	9d 81       	ldd	r25, Y+5	; 0x05
    2928:	fc 01       	movw	r30, r24
    292a:	21 81       	ldd	r18, Z+1	; 0x01
    292c:	32 81       	ldd	r19, Z+2	; 0x02
    292e:	8a 81       	ldd	r24, Y+2	; 0x02
    2930:	9b 81       	ldd	r25, Y+3	; 0x03
    2932:	82 17       	cp	r24, r18
    2934:	93 07       	cpc	r25, r19
    2936:	18 f0       	brcs	.+6      	; 0x293e <xTaskCheckForTimeOut+0x6e>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2938:	81 e0       	ldi	r24, 0x01	; 1
    293a:	89 83       	std	Y+1, r24	; 0x01
    293c:	30 c0       	rjmp	.+96     	; 0x299e <xTaskCheckForTimeOut+0xce>
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    293e:	8c 81       	ldd	r24, Y+4	; 0x04
    2940:	9d 81       	ldd	r25, Y+5	; 0x05
    2942:	fc 01       	movw	r30, r24
    2944:	81 81       	ldd	r24, Z+1	; 0x01
    2946:	92 81       	ldd	r25, Z+2	; 0x02
    2948:	2a 81       	ldd	r18, Y+2	; 0x02
    294a:	3b 81       	ldd	r19, Y+3	; 0x03
    294c:	28 1b       	sub	r18, r24
    294e:	39 0b       	sbc	r19, r25
    2950:	8e 81       	ldd	r24, Y+6	; 0x06
    2952:	9f 81       	ldd	r25, Y+7	; 0x07
    2954:	fc 01       	movw	r30, r24
    2956:	80 81       	ld	r24, Z
    2958:	91 81       	ldd	r25, Z+1	; 0x01
    295a:	28 17       	cp	r18, r24
    295c:	39 07       	cpc	r19, r25
    295e:	e8 f4       	brcc	.+58     	; 0x299a <xTaskCheckForTimeOut+0xca>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    2960:	8e 81       	ldd	r24, Y+6	; 0x06
    2962:	9f 81       	ldd	r25, Y+7	; 0x07
    2964:	fc 01       	movw	r30, r24
    2966:	20 81       	ld	r18, Z
    2968:	31 81       	ldd	r19, Z+1	; 0x01
    296a:	8c 81       	ldd	r24, Y+4	; 0x04
    296c:	9d 81       	ldd	r25, Y+5	; 0x05
    296e:	fc 01       	movw	r30, r24
    2970:	41 81       	ldd	r20, Z+1	; 0x01
    2972:	52 81       	ldd	r21, Z+2	; 0x02
    2974:	8a 81       	ldd	r24, Y+2	; 0x02
    2976:	9b 81       	ldd	r25, Y+3	; 0x03
    2978:	ba 01       	movw	r22, r20
    297a:	68 1b       	sub	r22, r24
    297c:	79 0b       	sbc	r23, r25
    297e:	cb 01       	movw	r24, r22
    2980:	28 0f       	add	r18, r24
    2982:	39 1f       	adc	r19, r25
    2984:	8e 81       	ldd	r24, Y+6	; 0x06
    2986:	9f 81       	ldd	r25, Y+7	; 0x07
    2988:	fc 01       	movw	r30, r24
    298a:	31 83       	std	Z+1, r19	; 0x01
    298c:	20 83       	st	Z, r18
			vTaskSetTimeOutState( pxTimeOut );
    298e:	8c 81       	ldd	r24, Y+4	; 0x04
    2990:	9d 81       	ldd	r25, Y+5	; 0x05
    2992:	0e 94 4d 14 	call	0x289a	; 0x289a <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2996:	19 82       	std	Y+1, r1	; 0x01
    2998:	02 c0       	rjmp	.+4      	; 0x299e <xTaskCheckForTimeOut+0xce>
		}
		else
		{
			xReturn = pdTRUE;
    299a:	81 e0       	ldi	r24, 0x01	; 1
    299c:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    299e:	0f 90       	pop	r0
    29a0:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    29a2:	89 81       	ldd	r24, Y+1	; 0x01
}
    29a4:	27 96       	adiw	r28, 0x07	; 7
    29a6:	0f b6       	in	r0, 0x3f	; 63
    29a8:	f8 94       	cli
    29aa:	de bf       	out	0x3e, r29	; 62
    29ac:	0f be       	out	0x3f, r0	; 63
    29ae:	cd bf       	out	0x3d, r28	; 61
    29b0:	df 91       	pop	r29
    29b2:	cf 91       	pop	r28
    29b4:	08 95       	ret

000029b6 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    29b6:	cf 93       	push	r28
    29b8:	df 93       	push	r29
    29ba:	cd b7       	in	r28, 0x3d	; 61
    29bc:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    29be:	81 e0       	ldi	r24, 0x01	; 1
    29c0:	80 93 70 08 	sts	0x0870, r24
}
    29c4:	df 91       	pop	r29
    29c6:	cf 91       	pop	r28
    29c8:	08 95       	ret

000029ca <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    29ca:	cf 93       	push	r28
    29cc:	df 93       	push	r29
    29ce:	00 d0       	rcall	.+0      	; 0x29d0 <prvIdleTask+0x6>
    29d0:	cd b7       	in	r28, 0x3d	; 61
    29d2:	de b7       	in	r29, 0x3e	; 62
    29d4:	9a 83       	std	Y+2, r25	; 0x02
    29d6:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    29d8:	0e 94 ab 15 	call	0x2b56	; 0x2b56 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    29dc:	80 91 1e 08 	lds	r24, 0x081E
    29e0:	82 30       	cpi	r24, 0x02	; 2
    29e2:	10 f0       	brcs	.+4      	; 0x29e8 <prvIdleTask+0x1e>
			{
				taskYIELD();
    29e4:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <vPortYield>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
    29e8:	f7 cf       	rjmp	.-18     	; 0x29d8 <prvIdleTask+0xe>

000029ea <prvInitialiseTCBVariables>:
	}
#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    29ea:	0f 93       	push	r16
    29ec:	1f 93       	push	r17
    29ee:	cf 93       	push	r28
    29f0:	df 93       	push	r29
    29f2:	cd b7       	in	r28, 0x3d	; 61
    29f4:	de b7       	in	r29, 0x3e	; 62
    29f6:	2a 97       	sbiw	r28, 0x0a	; 10
    29f8:	0f b6       	in	r0, 0x3f	; 63
    29fa:	f8 94       	cli
    29fc:	de bf       	out	0x3e, r29	; 62
    29fe:	0f be       	out	0x3f, r0	; 63
    2a00:	cd bf       	out	0x3d, r28	; 61
    2a02:	9b 83       	std	Y+3, r25	; 0x03
    2a04:	8a 83       	std	Y+2, r24	; 0x02
    2a06:	7d 83       	std	Y+5, r23	; 0x05
    2a08:	6c 83       	std	Y+4, r22	; 0x04
    2a0a:	4e 83       	std	Y+6, r20	; 0x06
    2a0c:	38 87       	std	Y+8, r19	; 0x08
    2a0e:	2f 83       	std	Y+7, r18	; 0x07
    2a10:	1a 87       	std	Y+10, r17	; 0x0a
    2a12:	09 87       	std	Y+9, r16	; 0x09
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    2a14:	19 82       	std	Y+1, r1	; 0x01
    2a16:	22 c0       	rjmp	.+68     	; 0x2a5c <prvInitialiseTCBVariables+0x72>
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
    2a18:	89 81       	ldd	r24, Y+1	; 0x01
    2a1a:	88 2f       	mov	r24, r24
    2a1c:	90 e0       	ldi	r25, 0x00	; 0
    2a1e:	29 81       	ldd	r18, Y+1	; 0x01
    2a20:	22 2f       	mov	r18, r18
    2a22:	30 e0       	ldi	r19, 0x00	; 0
    2a24:	4c 81       	ldd	r20, Y+4	; 0x04
    2a26:	5d 81       	ldd	r21, Y+5	; 0x05
    2a28:	24 0f       	add	r18, r20
    2a2a:	35 1f       	adc	r19, r21
    2a2c:	f9 01       	movw	r30, r18
    2a2e:	40 81       	ld	r20, Z
    2a30:	2a 81       	ldd	r18, Y+2	; 0x02
    2a32:	3b 81       	ldd	r19, Y+3	; 0x03
    2a34:	82 0f       	add	r24, r18
    2a36:	93 1f       	adc	r25, r19
    2a38:	49 96       	adiw	r24, 0x19	; 25
    2a3a:	fc 01       	movw	r30, r24
    2a3c:	40 83       	st	Z, r20

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    2a3e:	89 81       	ldd	r24, Y+1	; 0x01
    2a40:	88 2f       	mov	r24, r24
    2a42:	90 e0       	ldi	r25, 0x00	; 0
    2a44:	2c 81       	ldd	r18, Y+4	; 0x04
    2a46:	3d 81       	ldd	r19, Y+5	; 0x05
    2a48:	82 0f       	add	r24, r18
    2a4a:	93 1f       	adc	r25, r19
    2a4c:	fc 01       	movw	r30, r24
    2a4e:	80 81       	ld	r24, Z
    2a50:	88 23       	and	r24, r24
    2a52:	09 f4       	brne	.+2      	; 0x2a56 <prvInitialiseTCBVariables+0x6c>
		{
			break;
    2a54:	06 c0       	rjmp	.+12     	; 0x2a62 <prvInitialiseTCBVariables+0x78>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    2a56:	89 81       	ldd	r24, Y+1	; 0x01
    2a58:	8f 5f       	subi	r24, 0xFF	; 255
    2a5a:	89 83       	std	Y+1, r24	; 0x01
    2a5c:	89 81       	ldd	r24, Y+1	; 0x01
    2a5e:	84 30       	cpi	r24, 0x04	; 4
    2a60:	d8 f2       	brcs	.-74     	; 0x2a18 <prvInitialiseTCBVariables+0x2e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    2a62:	8a 81       	ldd	r24, Y+2	; 0x02
    2a64:	9b 81       	ldd	r25, Y+3	; 0x03
    2a66:	fc 01       	movw	r30, r24
    2a68:	14 8e       	std	Z+28, r1	; 0x1c

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    2a6a:	8e 81       	ldd	r24, Y+6	; 0x06
    2a6c:	84 30       	cpi	r24, 0x04	; 4
    2a6e:	10 f0       	brcs	.+4      	; 0x2a74 <prvInitialiseTCBVariables+0x8a>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    2a70:	83 e0       	ldi	r24, 0x03	; 3
    2a72:	8e 83       	std	Y+6, r24	; 0x06
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
    2a74:	8a 81       	ldd	r24, Y+2	; 0x02
    2a76:	9b 81       	ldd	r25, Y+3	; 0x03
    2a78:	2e 81       	ldd	r18, Y+6	; 0x06
    2a7a:	fc 01       	movw	r30, r24
    2a7c:	26 8b       	std	Z+22, r18	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    2a7e:	8a 81       	ldd	r24, Y+2	; 0x02
    2a80:	9b 81       	ldd	r25, Y+3	; 0x03
    2a82:	02 96       	adiw	r24, 0x02	; 2
    2a84:	0e 94 50 08 	call	0x10a0	; 0x10a0 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    2a88:	8a 81       	ldd	r24, Y+2	; 0x02
    2a8a:	9b 81       	ldd	r25, Y+3	; 0x03
    2a8c:	0c 96       	adiw	r24, 0x0c	; 12
    2a8e:	0e 94 50 08 	call	0x10a0	; 0x10a0 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    2a92:	8a 81       	ldd	r24, Y+2	; 0x02
    2a94:	9b 81       	ldd	r25, Y+3	; 0x03
    2a96:	2a 81       	ldd	r18, Y+2	; 0x02
    2a98:	3b 81       	ldd	r19, Y+3	; 0x03
    2a9a:	fc 01       	movw	r30, r24
    2a9c:	31 87       	std	Z+9, r19	; 0x09
    2a9e:	20 87       	std	Z+8, r18	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2aa0:	8e 81       	ldd	r24, Y+6	; 0x06
    2aa2:	88 2f       	mov	r24, r24
    2aa4:	90 e0       	ldi	r25, 0x00	; 0
    2aa6:	24 e0       	ldi	r18, 0x04	; 4
    2aa8:	30 e0       	ldi	r19, 0x00	; 0
    2aaa:	28 1b       	sub	r18, r24
    2aac:	39 0b       	sbc	r19, r25
    2aae:	8a 81       	ldd	r24, Y+2	; 0x02
    2ab0:	9b 81       	ldd	r25, Y+3	; 0x03
    2ab2:	fc 01       	movw	r30, r24
    2ab4:	35 87       	std	Z+13, r19	; 0x0d
    2ab6:	24 87       	std	Z+12, r18	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    2ab8:	8a 81       	ldd	r24, Y+2	; 0x02
    2aba:	9b 81       	ldd	r25, Y+3	; 0x03
    2abc:	2a 81       	ldd	r18, Y+2	; 0x02
    2abe:	3b 81       	ldd	r19, Y+3	; 0x03
    2ac0:	fc 01       	movw	r30, r24
    2ac2:	33 8b       	std	Z+19, r19	; 0x13
    2ac4:	22 8b       	std	Z+18, r18	; 0x12
	{
		/* Initialise this task's Newlib reent structure. */
		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
	}
	#endif /* configUSE_NEWLIB_REENTRANT */
}
    2ac6:	2a 96       	adiw	r28, 0x0a	; 10
    2ac8:	0f b6       	in	r0, 0x3f	; 63
    2aca:	f8 94       	cli
    2acc:	de bf       	out	0x3e, r29	; 62
    2ace:	0f be       	out	0x3f, r0	; 63
    2ad0:	cd bf       	out	0x3d, r28	; 61
    2ad2:	df 91       	pop	r29
    2ad4:	cf 91       	pop	r28
    2ad6:	1f 91       	pop	r17
    2ad8:	0f 91       	pop	r16
    2ada:	08 95       	ret

00002adc <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    2adc:	cf 93       	push	r28
    2ade:	df 93       	push	r29
    2ae0:	1f 92       	push	r1
    2ae2:	cd b7       	in	r28, 0x3d	; 61
    2ae4:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    2ae6:	19 82       	std	Y+1, r1	; 0x01
    2ae8:	13 c0       	rjmp	.+38     	; 0x2b10 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    2aea:	89 81       	ldd	r24, Y+1	; 0x01
    2aec:	28 2f       	mov	r18, r24
    2aee:	30 e0       	ldi	r19, 0x00	; 0
    2af0:	c9 01       	movw	r24, r18
    2af2:	88 0f       	add	r24, r24
    2af4:	99 1f       	adc	r25, r25
    2af6:	88 0f       	add	r24, r24
    2af8:	99 1f       	adc	r25, r25
    2afa:	88 0f       	add	r24, r24
    2afc:	99 1f       	adc	r25, r25
    2afe:	82 0f       	add	r24, r18
    2b00:	93 1f       	adc	r25, r19
    2b02:	82 5e       	subi	r24, 0xE2	; 226
    2b04:	97 4f       	sbci	r25, 0xF7	; 247
    2b06:	0e 94 1b 08 	call	0x1036	; 0x1036 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    2b0a:	89 81       	ldd	r24, Y+1	; 0x01
    2b0c:	8f 5f       	subi	r24, 0xFF	; 255
    2b0e:	89 83       	std	Y+1, r24	; 0x01
    2b10:	89 81       	ldd	r24, Y+1	; 0x01
    2b12:	84 30       	cpi	r24, 0x04	; 4
    2b14:	50 f3       	brcs	.-44     	; 0x2aea <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    2b16:	82 e4       	ldi	r24, 0x42	; 66
    2b18:	98 e0       	ldi	r25, 0x08	; 8
    2b1a:	0e 94 1b 08 	call	0x1036	; 0x1036 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    2b1e:	8b e4       	ldi	r24, 0x4B	; 75
    2b20:	98 e0       	ldi	r25, 0x08	; 8
    2b22:	0e 94 1b 08 	call	0x1036	; 0x1036 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    2b26:	88 e5       	ldi	r24, 0x58	; 88
    2b28:	98 e0       	ldi	r25, 0x08	; 8
    2b2a:	0e 94 1b 08 	call	0x1036	; 0x1036 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    2b2e:	81 e6       	ldi	r24, 0x61	; 97
    2b30:	98 e0       	ldi	r25, 0x08	; 8
    2b32:	0e 94 1b 08 	call	0x1036	; 0x1036 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    2b36:	82 e4       	ldi	r24, 0x42	; 66
    2b38:	98 e0       	ldi	r25, 0x08	; 8
    2b3a:	90 93 55 08 	sts	0x0855, r25
    2b3e:	80 93 54 08 	sts	0x0854, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    2b42:	8b e4       	ldi	r24, 0x4B	; 75
    2b44:	98 e0       	ldi	r25, 0x08	; 8
    2b46:	90 93 57 08 	sts	0x0857, r25
    2b4a:	80 93 56 08 	sts	0x0856, r24
}
    2b4e:	0f 90       	pop	r0
    2b50:	df 91       	pop	r29
    2b52:	cf 91       	pop	r28
    2b54:	08 95       	ret

00002b56 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    2b56:	cf 93       	push	r28
    2b58:	df 93       	push	r29
    2b5a:	cd b7       	in	r28, 0x3d	; 61
    2b5c:	de b7       	in	r29, 0x3e	; 62
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* vTaskDelete */
}
    2b5e:	df 91       	pop	r29
    2b60:	cf 91       	pop	r28
    2b62:	08 95       	ret

00002b64 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
    2b64:	cf 93       	push	r28
    2b66:	df 93       	push	r29
    2b68:	00 d0       	rcall	.+0      	; 0x2b6a <prvAddCurrentTaskToDelayedList+0x6>
    2b6a:	cd b7       	in	r28, 0x3d	; 61
    2b6c:	de b7       	in	r29, 0x3e	; 62
    2b6e:	9a 83       	std	Y+2, r25	; 0x02
    2b70:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    2b72:	80 91 1c 08 	lds	r24, 0x081C
    2b76:	90 91 1d 08 	lds	r25, 0x081D
    2b7a:	29 81       	ldd	r18, Y+1	; 0x01
    2b7c:	3a 81       	ldd	r19, Y+2	; 0x02
    2b7e:	fc 01       	movw	r30, r24
    2b80:	33 83       	std	Z+3, r19	; 0x03
    2b82:	22 83       	std	Z+2, r18	; 0x02

	if( xTimeToWake < xTickCount )
    2b84:	80 91 6b 08 	lds	r24, 0x086B
    2b88:	90 91 6c 08 	lds	r25, 0x086C
    2b8c:	29 81       	ldd	r18, Y+1	; 0x01
    2b8e:	3a 81       	ldd	r19, Y+2	; 0x02
    2b90:	28 17       	cp	r18, r24
    2b92:	39 07       	cpc	r19, r25
    2b94:	78 f4       	brcc	.+30     	; 0x2bb4 <prvAddCurrentTaskToDelayedList+0x50>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    2b96:	80 91 1c 08 	lds	r24, 0x081C
    2b9a:	90 91 1d 08 	lds	r25, 0x081D
    2b9e:	9c 01       	movw	r18, r24
    2ba0:	2e 5f       	subi	r18, 0xFE	; 254
    2ba2:	3f 4f       	sbci	r19, 0xFF	; 255
    2ba4:	80 91 56 08 	lds	r24, 0x0856
    2ba8:	90 91 57 08 	lds	r25, 0x0857
    2bac:	b9 01       	movw	r22, r18
    2bae:	0e 94 af 08 	call	0x115e	; 0x115e <vListInsert>
    2bb2:	1d c0       	rjmp	.+58     	; 0x2bee <prvAddCurrentTaskToDelayedList+0x8a>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    2bb4:	80 91 1c 08 	lds	r24, 0x081C
    2bb8:	90 91 1d 08 	lds	r25, 0x081D
    2bbc:	9c 01       	movw	r18, r24
    2bbe:	2e 5f       	subi	r18, 0xFE	; 254
    2bc0:	3f 4f       	sbci	r19, 0xFF	; 255
    2bc2:	80 91 54 08 	lds	r24, 0x0854
    2bc6:	90 91 55 08 	lds	r25, 0x0855
    2bca:	b9 01       	movw	r22, r18
    2bcc:	0e 94 af 08 	call	0x115e	; 0x115e <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    2bd0:	80 91 0d 01 	lds	r24, 0x010D
    2bd4:	90 91 0e 01 	lds	r25, 0x010E
    2bd8:	29 81       	ldd	r18, Y+1	; 0x01
    2bda:	3a 81       	ldd	r19, Y+2	; 0x02
    2bdc:	28 17       	cp	r18, r24
    2bde:	39 07       	cpc	r19, r25
    2be0:	30 f4       	brcc	.+12     	; 0x2bee <prvAddCurrentTaskToDelayedList+0x8a>
		{
			xNextTaskUnblockTime = xTimeToWake;
    2be2:	89 81       	ldd	r24, Y+1	; 0x01
    2be4:	9a 81       	ldd	r25, Y+2	; 0x02
    2be6:	90 93 0e 01 	sts	0x010E, r25
    2bea:	80 93 0d 01 	sts	0x010D, r24
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    2bee:	0f 90       	pop	r0
    2bf0:	0f 90       	pop	r0
    2bf2:	df 91       	pop	r29
    2bf4:	cf 91       	pop	r28
    2bf6:	08 95       	ret

00002bf8 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
{
    2bf8:	cf 93       	push	r28
    2bfa:	df 93       	push	r29
    2bfc:	00 d0       	rcall	.+0      	; 0x2bfe <prvAllocateTCBAndStack+0x6>
    2bfe:	00 d0       	rcall	.+0      	; 0x2c00 <prvAllocateTCBAndStack+0x8>
    2c00:	00 d0       	rcall	.+0      	; 0x2c02 <prvAllocateTCBAndStack+0xa>
    2c02:	cd b7       	in	r28, 0x3d	; 61
    2c04:	de b7       	in	r29, 0x3e	; 62
    2c06:	9c 83       	std	Y+4, r25	; 0x04
    2c08:	8b 83       	std	Y+3, r24	; 0x03
    2c0a:	7e 83       	std	Y+6, r23	; 0x06
    2c0c:	6d 83       	std	Y+5, r22	; 0x05
TCB_t *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
    2c0e:	8d e1       	ldi	r24, 0x1D	; 29
    2c10:	90 e0       	ldi	r25, 0x00	; 0
    2c12:	0e 94 bc 04 	call	0x978	; 0x978 <pvPortMalloc>
    2c16:	9a 83       	std	Y+2, r25	; 0x02
    2c18:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    2c1a:	89 81       	ldd	r24, Y+1	; 0x01
    2c1c:	9a 81       	ldd	r25, Y+2	; 0x02
    2c1e:	00 97       	sbiw	r24, 0x00	; 0
    2c20:	51 f1       	breq	.+84     	; 0x2c76 <prvAllocateTCBAndStack+0x7e>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2c22:	8d 81       	ldd	r24, Y+5	; 0x05
    2c24:	9e 81       	ldd	r25, Y+6	; 0x06
    2c26:	00 97       	sbiw	r24, 0x00	; 0
    2c28:	29 f4       	brne	.+10     	; 0x2c34 <prvAllocateTCBAndStack+0x3c>
    2c2a:	8b 81       	ldd	r24, Y+3	; 0x03
    2c2c:	9c 81       	ldd	r25, Y+4	; 0x04
    2c2e:	0e 94 bc 04 	call	0x978	; 0x978 <pvPortMalloc>
    2c32:	02 c0       	rjmp	.+4      	; 0x2c38 <prvAllocateTCBAndStack+0x40>
    2c34:	8d 81       	ldd	r24, Y+5	; 0x05
    2c36:	9e 81       	ldd	r25, Y+6	; 0x06
    2c38:	29 81       	ldd	r18, Y+1	; 0x01
    2c3a:	3a 81       	ldd	r19, Y+2	; 0x02
    2c3c:	f9 01       	movw	r30, r18
    2c3e:	90 8f       	std	Z+24, r25	; 0x18
    2c40:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    2c42:	89 81       	ldd	r24, Y+1	; 0x01
    2c44:	9a 81       	ldd	r25, Y+2	; 0x02
    2c46:	fc 01       	movw	r30, r24
    2c48:	87 89       	ldd	r24, Z+23	; 0x17
    2c4a:	90 8d       	ldd	r25, Z+24	; 0x18
    2c4c:	00 97       	sbiw	r24, 0x00	; 0
    2c4e:	39 f4       	brne	.+14     	; 0x2c5e <prvAllocateTCBAndStack+0x66>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    2c50:	89 81       	ldd	r24, Y+1	; 0x01
    2c52:	9a 81       	ldd	r25, Y+2	; 0x02
    2c54:	0e 94 12 05 	call	0xa24	; 0xa24 <vPortFree>
			pxNewTCB = NULL;
    2c58:	1a 82       	std	Y+2, r1	; 0x02
    2c5a:	19 82       	std	Y+1, r1	; 0x01
    2c5c:	0c c0       	rjmp	.+24     	; 0x2c76 <prvAllocateTCBAndStack+0x7e>
		{
			/* Avoid dependency on memset() if it is not required. */
			#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
			{
				/* Just to help debugging. */
				( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
    2c5e:	89 81       	ldd	r24, Y+1	; 0x01
    2c60:	9a 81       	ldd	r25, Y+2	; 0x02
    2c62:	fc 01       	movw	r30, r24
    2c64:	87 89       	ldd	r24, Z+23	; 0x17
    2c66:	90 8d       	ldd	r25, Z+24	; 0x18
    2c68:	2b 81       	ldd	r18, Y+3	; 0x03
    2c6a:	3c 81       	ldd	r19, Y+4	; 0x04
    2c6c:	a9 01       	movw	r20, r18
    2c6e:	65 ea       	ldi	r22, 0xA5	; 165
    2c70:	70 e0       	ldi	r23, 0x00	; 0
    2c72:	0e 94 47 1a 	call	0x348e	; 0x348e <memset>
			}
			#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
		}
	}

	return pxNewTCB;
    2c76:	89 81       	ldd	r24, Y+1	; 0x01
    2c78:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2c7a:	26 96       	adiw	r28, 0x06	; 6
    2c7c:	0f b6       	in	r0, 0x3f	; 63
    2c7e:	f8 94       	cli
    2c80:	de bf       	out	0x3e, r29	; 62
    2c82:	0f be       	out	0x3f, r0	; 63
    2c84:	cd bf       	out	0x3d, r28	; 61
    2c86:	df 91       	pop	r29
    2c88:	cf 91       	pop	r28
    2c8a:	08 95       	ret

00002c8c <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    2c8c:	cf 93       	push	r28
    2c8e:	df 93       	push	r29
    2c90:	00 d0       	rcall	.+0      	; 0x2c92 <prvResetNextTaskUnblockTime+0x6>
    2c92:	cd b7       	in	r28, 0x3d	; 61
    2c94:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2c96:	80 91 54 08 	lds	r24, 0x0854
    2c9a:	90 91 55 08 	lds	r25, 0x0855
    2c9e:	fc 01       	movw	r30, r24
    2ca0:	80 81       	ld	r24, Z
    2ca2:	88 23       	and	r24, r24
    2ca4:	39 f4       	brne	.+14     	; 0x2cb4 <prvResetNextTaskUnblockTime+0x28>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    2ca6:	8f ef       	ldi	r24, 0xFF	; 255
    2ca8:	9f ef       	ldi	r25, 0xFF	; 255
    2caa:	90 93 0e 01 	sts	0x010E, r25
    2cae:	80 93 0d 01 	sts	0x010D, r24
    2cb2:	15 c0       	rjmp	.+42     	; 0x2cde <prvResetNextTaskUnblockTime+0x52>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2cb4:	80 91 54 08 	lds	r24, 0x0854
    2cb8:	90 91 55 08 	lds	r25, 0x0855
    2cbc:	fc 01       	movw	r30, r24
    2cbe:	85 81       	ldd	r24, Z+5	; 0x05
    2cc0:	96 81       	ldd	r25, Z+6	; 0x06
    2cc2:	fc 01       	movw	r30, r24
    2cc4:	86 81       	ldd	r24, Z+6	; 0x06
    2cc6:	97 81       	ldd	r25, Z+7	; 0x07
    2cc8:	9a 83       	std	Y+2, r25	; 0x02
    2cca:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
    2ccc:	89 81       	ldd	r24, Y+1	; 0x01
    2cce:	9a 81       	ldd	r25, Y+2	; 0x02
    2cd0:	fc 01       	movw	r30, r24
    2cd2:	82 81       	ldd	r24, Z+2	; 0x02
    2cd4:	93 81       	ldd	r25, Z+3	; 0x03
    2cd6:	90 93 0e 01 	sts	0x010E, r25
    2cda:	80 93 0d 01 	sts	0x010D, r24
	}
}
    2cde:	0f 90       	pop	r0
    2ce0:	0f 90       	pop	r0
    2ce2:	df 91       	pop	r29
    2ce4:	cf 91       	pop	r28
    2ce6:	08 95       	ret

00002ce8 <vStartLEDFlashTasks>:
static portTASK_FUNCTION_PROTO( vLEDFlashTask, pvParameters );

/*-----------------------------------------------------------*/

void vStartLEDFlashTasks( UBaseType_t uxPriority )
{
    2ce8:	af 92       	push	r10
    2cea:	bf 92       	push	r11
    2cec:	cf 92       	push	r12
    2cee:	df 92       	push	r13
    2cf0:	ef 92       	push	r14
    2cf2:	ff 92       	push	r15
    2cf4:	0f 93       	push	r16
    2cf6:	cf 93       	push	r28
    2cf8:	df 93       	push	r29
    2cfa:	1f 92       	push	r1
    2cfc:	cd b7       	in	r28, 0x3d	; 61
    2cfe:	de b7       	in	r29, 0x3e	; 62
    2d00:	89 83       	std	Y+1, r24	; 0x01
	/* Create the three tasks. */
	//for( xLEDTask = 0; xLEDTask < ledNUMBER_OF_LEDS; ++xLEDTask )  // Commented out for only one LED
	//{
		/* Spawn the task. */
		xTaskCreate( vLEDFlashTask, "L", ledSTACK_SIZE*2, NULL, uxPriority, &ledTaskHandle );
    2d02:	a1 2c       	mov	r10, r1
    2d04:	b1 2c       	mov	r11, r1
    2d06:	c1 2c       	mov	r12, r1
    2d08:	d1 2c       	mov	r13, r1
    2d0a:	0f 2e       	mov	r0, r31
    2d0c:	f5 ea       	ldi	r31, 0xA5	; 165
    2d0e:	ef 2e       	mov	r14, r31
    2d10:	f8 e0       	ldi	r31, 0x08	; 8
    2d12:	ff 2e       	mov	r15, r31
    2d14:	f0 2d       	mov	r31, r0
    2d16:	09 81       	ldd	r16, Y+1	; 0x01
    2d18:	20 e0       	ldi	r18, 0x00	; 0
    2d1a:	30 e0       	ldi	r19, 0x00	; 0
    2d1c:	4a ea       	ldi	r20, 0xAA	; 170
    2d1e:	50 e0       	ldi	r21, 0x00	; 0
    2d20:	69 e9       	ldi	r22, 0x99	; 153
    2d22:	71 e0       	ldi	r23, 0x01	; 1
    2d24:	81 ea       	ldi	r24, 0xA1	; 161
    2d26:	96 e1       	ldi	r25, 0x16	; 22
    2d28:	0e 94 b9 0e 	call	0x1d72	; 0x1d72 <xTaskGenericCreate>
	//}
}
    2d2c:	0f 90       	pop	r0
    2d2e:	df 91       	pop	r29
    2d30:	cf 91       	pop	r28
    2d32:	0f 91       	pop	r16
    2d34:	ff 90       	pop	r15
    2d36:	ef 90       	pop	r14
    2d38:	df 90       	pop	r13
    2d3a:	cf 90       	pop	r12
    2d3c:	bf 90       	pop	r11
    2d3e:	af 90       	pop	r10
    2d40:	08 95       	ret

00002d42 <vLEDFlashTask>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vLEDFlashTask, pvParameters )
{
    2d42:	cf 93       	push	r28
    2d44:	df 93       	push	r29
    2d46:	cd b7       	in	r28, 0x3d	; 61
    2d48:	de b7       	in	r29, 0x3e	; 62
    2d4a:	27 97       	sbiw	r28, 0x07	; 7
    2d4c:	0f b6       	in	r0, 0x3f	; 63
    2d4e:	f8 94       	cli
    2d50:	de bf       	out	0x3e, r29	; 62
    2d52:	0f be       	out	0x3f, r0	; 63
    2d54:	cd bf       	out	0x3d, r28	; 61
    2d56:	9f 83       	std	Y+7, r25	; 0x07
    2d58:	8e 83       	std	Y+6, r24	; 0x06

	/* The parameters are not used. */
	( void ) pvParameters;

	/* Calculate the LED and flash rate. */
	uxLED = 2; // Edited so that the calculation is spared
    2d5a:	82 e0       	ldi	r24, 0x02	; 2
    2d5c:	89 83       	std	Y+1, r24	; 0x01

	xFlashRate = ledFLASH_RATE_BASE + ( ledFLASH_RATE_BASE * ( TickType_t ) uxLED );
    2d5e:	89 81       	ldd	r24, Y+1	; 0x01
    2d60:	88 2f       	mov	r24, r24
    2d62:	90 e0       	ldi	r25, 0x00	; 0
    2d64:	ac 01       	movw	r20, r24
    2d66:	4f 5f       	subi	r20, 0xFF	; 255
    2d68:	5f 4f       	sbci	r21, 0xFF	; 255
    2d6a:	2d e4       	ldi	r18, 0x4D	; 77
    2d6c:	31 e0       	ldi	r19, 0x01	; 1
    2d6e:	42 9f       	mul	r20, r18
    2d70:	c0 01       	movw	r24, r0
    2d72:	43 9f       	mul	r20, r19
    2d74:	90 0d       	add	r25, r0
    2d76:	52 9f       	mul	r21, r18
    2d78:	90 0d       	add	r25, r0
    2d7a:	11 24       	eor	r1, r1
    2d7c:	9b 83       	std	Y+3, r25	; 0x03
    2d7e:	8a 83       	std	Y+2, r24	; 0x02
	xFlashRate /= portTICK_PERIOD_MS;

	/* We will turn the LED on and off again in the delay period, so each
	delay is only half the total period. */
	xFlashRate /= ( TickType_t ) 2;
    2d80:	8a 81       	ldd	r24, Y+2	; 0x02
    2d82:	9b 81       	ldd	r25, Y+3	; 0x03
    2d84:	96 95       	lsr	r25
    2d86:	87 95       	ror	r24
    2d88:	9b 83       	std	Y+3, r25	; 0x03
    2d8a:	8a 83       	std	Y+2, r24	; 0x02
	

	/* We need to initialize xLastFlashTime prior to the first call to 
	vTaskDelayUntil(). */
	xLastFlashTime = xTaskGetTickCount();
    2d8c:	0e 94 1e 12 	call	0x243c	; 0x243c <xTaskGetTickCount>
    2d90:	9d 83       	std	Y+5, r25	; 0x05
    2d92:	8c 83       	std	Y+4, r24	; 0x04

	for(;;)
	{
		/* Delay for half the flash period then turn the LED on. */
		vTaskDelayUntil( &xLastFlashTime, ledTaskRate );
    2d94:	20 91 a7 08 	lds	r18, 0x08A7
    2d98:	30 91 a8 08 	lds	r19, 0x08A8
    2d9c:	ce 01       	movw	r24, r28
    2d9e:	04 96       	adiw	r24, 0x04	; 4
    2da0:	b9 01       	movw	r22, r18
    2da2:	0e 94 9f 0f 	call	0x1f3e	; 0x1f3e <vTaskDelayUntil>
		vParTestToggleLED( uxLED );
    2da6:	89 81       	ldd	r24, Y+1	; 0x01
    2da8:	0e 94 3f 17 	call	0x2e7e	; 0x2e7e <vParTestToggleLED>
		//PORTB = 0b00010000;
		
		/* Delay for half the flash period then turn the LED off. */
		vTaskDelayUntil( &xLastFlashTime, ledTaskRate );
    2dac:	20 91 a7 08 	lds	r18, 0x08A7
    2db0:	30 91 a8 08 	lds	r19, 0x08A8
    2db4:	ce 01       	movw	r24, r28
    2db6:	04 96       	adiw	r24, 0x04	; 4
    2db8:	b9 01       	movw	r22, r18
    2dba:	0e 94 9f 0f 	call	0x1f3e	; 0x1f3e <vTaskDelayUntil>
		vParTestToggleLED( uxLED );
    2dbe:	89 81       	ldd	r24, Y+1	; 0x01
    2dc0:	0e 94 3f 17 	call	0x2e7e	; 0x2e7e <vParTestToggleLED>
		//PORTB = 0x00;
		
		//ubtWM = uxTaskGetStackHighWaterMark(NULL); // GET Watermark Data
		//fnPrintWaterMark(ubtWM,1);
	}
    2dc4:	e7 cf       	rjmp	.-50     	; 0x2d94 <vLEDFlashTask+0x52>

00002dc6 <vParTestInitialise>:
	// Defining the drive table

/*-----------------------------------------------------------*/

void vParTestInitialise( void )
{
    2dc6:	cf 93       	push	r28
    2dc8:	df 93       	push	r29
    2dca:	cd b7       	in	r28, 0x3d	; 61
    2dcc:	de b7       	in	r29, 0x3e	; 62
	ucCurrentOutputValue = partstALL_OUTPUTS_OFF;
    2dce:	10 92 74 08 	sts	0x0874, r1
	
	// Set MOTOR_DRIVE Circuitry to the right value as to not short anything out
	DDRC = portC_DIRECTIONS;
    2dd2:	87 e2       	ldi	r24, 0x27	; 39
    2dd4:	90 e0       	ldi	r25, 0x00	; 0
    2dd6:	2f e3       	ldi	r18, 0x3F	; 63
    2dd8:	fc 01       	movw	r30, r24
    2dda:	20 83       	st	Z, r18
	PORTC = portC_INIT_OUTPUT;
    2ddc:	88 e2       	ldi	r24, 0x28	; 40
    2dde:	90 e0       	ldi	r25, 0x00	; 0
    2de0:	27 e0       	ldi	r18, 0x07	; 7
    2de2:	fc 01       	movw	r30, r24
    2de4:	20 83       	st	Z, r18
	
	// Set the necessary ports on PD
	DDRD = portD_DIRECTIONS;
    2de6:	8a e2       	ldi	r24, 0x2A	; 42
    2de8:	90 e0       	ldi	r25, 0x00	; 0
    2dea:	2c e1       	ldi	r18, 0x1C	; 28
    2dec:	fc 01       	movw	r30, r24
    2dee:	20 83       	st	Z, r18
	
	/* Set the right ports of PB to be outputs */
	// Set the right ports to be outputs with local binary values
	DDRB = portB_DIRECTIONS; 
    2df0:	84 e2       	ldi	r24, 0x24	; 36
    2df2:	90 e0       	ldi	r25, 0x00	; 0
    2df4:	fc 01       	movw	r30, r24
    2df6:	10 82       	st	Z, r1
	PORTB = partstALL_OUTPUTS_OFF; // Turn off both outputs
    2df8:	85 e2       	ldi	r24, 0x25	; 37
    2dfa:	90 e0       	ldi	r25, 0x00	; 0
    2dfc:	fc 01       	movw	r30, r24
    2dfe:	10 82       	st	Z, r1
	
}
    2e00:	df 91       	pop	r29
    2e02:	cf 91       	pop	r28
    2e04:	08 95       	ret

00002e06 <vParTestSetLED>:
/*-----------------------------------------------------------*/

void vParTestSetLED( unsigned portBASE_TYPE uxLED, signed portBASE_TYPE xValue )
{
    2e06:	cf 93       	push	r28
    2e08:	df 93       	push	r29
    2e0a:	00 d0       	rcall	.+0      	; 0x2e0c <vParTestSetLED+0x6>
    2e0c:	1f 92       	push	r1
    2e0e:	cd b7       	in	r28, 0x3d	; 61
    2e10:	de b7       	in	r29, 0x3e	; 62
    2e12:	8a 83       	std	Y+2, r24	; 0x02
    2e14:	6b 83       	std	Y+3, r22	; 0x03
unsigned char ucBit = ( unsigned char ) 1;
    2e16:	81 e0       	ldi	r24, 0x01	; 1
    2e18:	89 83       	std	Y+1, r24	; 0x01

	if( uxLED <= partstMAX_OUTPUT_LED )
    2e1a:	8a 81       	ldd	r24, Y+2	; 0x02
    2e1c:	88 30       	cpi	r24, 0x08	; 8
    2e1e:	48 f5       	brcc	.+82     	; 0x2e72 <vParTestSetLED+0x6c>
	{
		ucBit <<= uxLED;	
    2e20:	89 81       	ldd	r24, Y+1	; 0x01
    2e22:	88 2f       	mov	r24, r24
    2e24:	90 e0       	ldi	r25, 0x00	; 0
    2e26:	2a 81       	ldd	r18, Y+2	; 0x02
    2e28:	22 2f       	mov	r18, r18
    2e2a:	30 e0       	ldi	r19, 0x00	; 0
    2e2c:	02 c0       	rjmp	.+4      	; 0x2e32 <vParTestSetLED+0x2c>
    2e2e:	88 0f       	add	r24, r24
    2e30:	99 1f       	adc	r25, r25
    2e32:	2a 95       	dec	r18
    2e34:	e2 f7       	brpl	.-8      	; 0x2e2e <vParTestSetLED+0x28>
    2e36:	89 83       	std	Y+1, r24	; 0x01

		vTaskSuspendAll();
    2e38:	0e 94 84 11 	call	0x2308	; 0x2308 <vTaskSuspendAll>
		{
			if( xValue == pdTRUE )
    2e3c:	8b 81       	ldd	r24, Y+3	; 0x03
    2e3e:	81 30       	cpi	r24, 0x01	; 1
    2e40:	39 f4       	brne	.+14     	; 0x2e50 <vParTestSetLED+0x4a>
			{
				ucCurrentOutputValue |= ucBit;
    2e42:	90 91 74 08 	lds	r25, 0x0874
    2e46:	89 81       	ldd	r24, Y+1	; 0x01
    2e48:	89 2b       	or	r24, r25
    2e4a:	80 93 74 08 	sts	0x0874, r24
    2e4e:	09 c0       	rjmp	.+18     	; 0x2e62 <vParTestSetLED+0x5c>
			}
			else
			{
				ucBit ^= ( unsigned char ) 0xff;
    2e50:	89 81       	ldd	r24, Y+1	; 0x01
    2e52:	80 95       	com	r24
    2e54:	89 83       	std	Y+1, r24	; 0x01
				ucCurrentOutputValue &= ucBit;
    2e56:	90 91 74 08 	lds	r25, 0x0874
    2e5a:	89 81       	ldd	r24, Y+1	; 0x01
    2e5c:	89 23       	and	r24, r25
    2e5e:	80 93 74 08 	sts	0x0874, r24
			}

			PORTD = ucCurrentOutputValue;
    2e62:	8b e2       	ldi	r24, 0x2B	; 43
    2e64:	90 e0       	ldi	r25, 0x00	; 0
    2e66:	20 91 74 08 	lds	r18, 0x0874
    2e6a:	fc 01       	movw	r30, r24
    2e6c:	20 83       	st	Z, r18
		}
		xTaskResumeAll();
    2e6e:	0e 94 90 11 	call	0x2320	; 0x2320 <xTaskResumeAll>
	}
}
    2e72:	0f 90       	pop	r0
    2e74:	0f 90       	pop	r0
    2e76:	0f 90       	pop	r0
    2e78:	df 91       	pop	r29
    2e7a:	cf 91       	pop	r28
    2e7c:	08 95       	ret

00002e7e <vParTestToggleLED>:
/*-----------------------------------------------------------*/

void vParTestToggleLED( unsigned portBASE_TYPE uxLED )
{
    2e7e:	cf 93       	push	r28
    2e80:	df 93       	push	r29
    2e82:	00 d0       	rcall	.+0      	; 0x2e84 <vParTestToggleLED+0x6>
    2e84:	cd b7       	in	r28, 0x3d	; 61
    2e86:	de b7       	in	r29, 0x3e	; 62
    2e88:	8a 83       	std	Y+2, r24	; 0x02
unsigned char ucBit;

	if( uxLED <= partstMAX_OUTPUT_LED )
    2e8a:	8a 81       	ldd	r24, Y+2	; 0x02
    2e8c:	88 30       	cpi	r24, 0x08	; 8
    2e8e:	50 f5       	brcc	.+84     	; 0x2ee4 <vParTestToggleLED+0x66>
	{
		ucBit = ( ( unsigned char ) 1 ) << uxLED;
    2e90:	8a 81       	ldd	r24, Y+2	; 0x02
    2e92:	28 2f       	mov	r18, r24
    2e94:	30 e0       	ldi	r19, 0x00	; 0
    2e96:	81 e0       	ldi	r24, 0x01	; 1
    2e98:	90 e0       	ldi	r25, 0x00	; 0
    2e9a:	02 c0       	rjmp	.+4      	; 0x2ea0 <vParTestToggleLED+0x22>
    2e9c:	88 0f       	add	r24, r24
    2e9e:	99 1f       	adc	r25, r25
    2ea0:	2a 95       	dec	r18
    2ea2:	e2 f7       	brpl	.-8      	; 0x2e9c <vParTestToggleLED+0x1e>
    2ea4:	89 83       	std	Y+1, r24	; 0x01

		vTaskSuspendAll();
    2ea6:	0e 94 84 11 	call	0x2308	; 0x2308 <vTaskSuspendAll>
		{
			if( ucCurrentOutputValue & ucBit )
    2eaa:	90 91 74 08 	lds	r25, 0x0874
    2eae:	89 81       	ldd	r24, Y+1	; 0x01
    2eb0:	89 23       	and	r24, r25
    2eb2:	88 23       	and	r24, r24
    2eb4:	49 f0       	breq	.+18     	; 0x2ec8 <vParTestToggleLED+0x4a>
			{
				ucCurrentOutputValue &= ~ucBit;
    2eb6:	89 81       	ldd	r24, Y+1	; 0x01
    2eb8:	98 2f       	mov	r25, r24
    2eba:	90 95       	com	r25
    2ebc:	80 91 74 08 	lds	r24, 0x0874
    2ec0:	89 23       	and	r24, r25
    2ec2:	80 93 74 08 	sts	0x0874, r24
    2ec6:	06 c0       	rjmp	.+12     	; 0x2ed4 <vParTestToggleLED+0x56>
			}
			else
			{
				ucCurrentOutputValue |= ucBit;
    2ec8:	90 91 74 08 	lds	r25, 0x0874
    2ecc:	89 81       	ldd	r24, Y+1	; 0x01
    2ece:	89 2b       	or	r24, r25
    2ed0:	80 93 74 08 	sts	0x0874, r24
			}

			PORTD = ucCurrentOutputValue;
    2ed4:	8b e2       	ldi	r24, 0x2B	; 43
    2ed6:	90 e0       	ldi	r25, 0x00	; 0
    2ed8:	20 91 74 08 	lds	r18, 0x0874
    2edc:	fc 01       	movw	r30, r24
    2ede:	20 83       	st	Z, r18
		}
		xTaskResumeAll();			
    2ee0:	0e 94 90 11 	call	0x2320	; 0x2320 <xTaskResumeAll>
	}
}
    2ee4:	0f 90       	pop	r0
    2ee6:	0f 90       	pop	r0
    2ee8:	df 91       	pop	r29
    2eea:	cf 91       	pop	r28
    2eec:	08 95       	ret

00002eee <vStartSerialTask>:
// This next variable holds the header to the UI. 

//////////////////////////////////////////////////////////////////////////
// Start the necessary tasks in the following function
void vStartSerialTask( UBaseType_t uxPriority, uint32_t ulBaudRate, UBaseType_t uxLED)
{	
    2eee:	af 92       	push	r10
    2ef0:	bf 92       	push	r11
    2ef2:	cf 92       	push	r12
    2ef4:	df 92       	push	r13
    2ef6:	ef 92       	push	r14
    2ef8:	ff 92       	push	r15
    2efa:	0f 93       	push	r16
    2efc:	cf 93       	push	r28
    2efe:	df 93       	push	r29
    2f00:	00 d0       	rcall	.+0      	; 0x2f02 <vStartSerialTask+0x14>
    2f02:	00 d0       	rcall	.+0      	; 0x2f04 <vStartSerialTask+0x16>
    2f04:	00 d0       	rcall	.+0      	; 0x2f06 <vStartSerialTask+0x18>
    2f06:	cd b7       	in	r28, 0x3d	; 61
    2f08:	de b7       	in	r29, 0x3e	; 62
    2f0a:	89 83       	std	Y+1, r24	; 0x01
    2f0c:	4a 83       	std	Y+2, r20	; 0x02
    2f0e:	5b 83       	std	Y+3, r21	; 0x03
    2f10:	6c 83       	std	Y+4, r22	; 0x04
    2f12:	7d 83       	std	Y+5, r23	; 0x05
    2f14:	2e 83       	std	Y+6, r18	; 0x06
	// Store the LED and Initialize the USART port - THIS was modded so that the LED is not needed
	(void) uxLED;
	xSerialPortInitMinimal(ulBaudRate, comBUFFER_LEN);
    2f16:	8a 81       	ldd	r24, Y+2	; 0x02
    2f18:	9b 81       	ldd	r25, Y+3	; 0x03
    2f1a:	ac 81       	ldd	r26, Y+4	; 0x04
    2f1c:	bd 81       	ldd	r27, Y+5	; 0x05
    2f1e:	44 e0       	ldi	r20, 0x04	; 4
    2f20:	bc 01       	movw	r22, r24
    2f22:	cd 01       	movw	r24, r26
    2f24:	0e 94 0e 03 	call	0x61c	; 0x61c <xSerialPortInitMinimal>
	
	// Start the Task
	xTaskCreate(vWelcomeTask,"T",configMINIMAL_STACK_SIZE*2,NULL,uxPriority, &comTaskHandle );
    2f28:	a1 2c       	mov	r10, r1
    2f2a:	b1 2c       	mov	r11, r1
    2f2c:	c1 2c       	mov	r12, r1
    2f2e:	d1 2c       	mov	r13, r1
    2f30:	0f 2e       	mov	r0, r31
    2f32:	fe ea       	ldi	r31, 0xAE	; 174
    2f34:	ef 2e       	mov	r14, r31
    2f36:	f8 e0       	ldi	r31, 0x08	; 8
    2f38:	ff 2e       	mov	r15, r31
    2f3a:	f0 2d       	mov	r31, r0
    2f3c:	09 81       	ldd	r16, Y+1	; 0x01
    2f3e:	20 e0       	ldi	r18, 0x00	; 0
    2f40:	30 e0       	ldi	r19, 0x00	; 0
    2f42:	4a ea       	ldi	r20, 0xAA	; 170
    2f44:	50 e0       	ldi	r21, 0x00	; 0
    2f46:	6b e9       	ldi	r22, 0x9B	; 155
    2f48:	71 e0       	ldi	r23, 0x01	; 1
    2f4a:	89 eb       	ldi	r24, 0xB9	; 185
    2f4c:	97 e1       	ldi	r25, 0x17	; 23
    2f4e:	0e 94 b9 0e 	call	0x1d72	; 0x1d72 <xTaskGenericCreate>
}
    2f52:	26 96       	adiw	r28, 0x06	; 6
    2f54:	0f b6       	in	r0, 0x3f	; 63
    2f56:	f8 94       	cli
    2f58:	de bf       	out	0x3e, r29	; 62
    2f5a:	0f be       	out	0x3f, r0	; 63
    2f5c:	cd bf       	out	0x3d, r28	; 61
    2f5e:	df 91       	pop	r29
    2f60:	cf 91       	pop	r28
    2f62:	0f 91       	pop	r16
    2f64:	ff 90       	pop	r15
    2f66:	ef 90       	pop	r14
    2f68:	df 90       	pop	r13
    2f6a:	cf 90       	pop	r12
    2f6c:	bf 90       	pop	r11
    2f6e:	af 90       	pop	r10
    2f70:	08 95       	ret

00002f72 <vWelcomeTask>:

//////////////////////////////////////////////////////////////////////////
// WELCOME TASK Definition
// This function will clear and display the welcome screen on the terminal
static portTASK_FUNCTION( vWelcomeTask, pvParameters )
{
    2f72:	cf 93       	push	r28
    2f74:	df 93       	push	r29
    2f76:	00 d0       	rcall	.+0      	; 0x2f78 <vWelcomeTask+0x6>
    2f78:	1f 92       	push	r1
    2f7a:	cd b7       	in	r28, 0x3d	; 61
    2f7c:	de b7       	in	r29, 0x3e	; 62
    2f7e:	9b 83       	std	Y+3, r25	; 0x03
    2f80:	8a 83       	std	Y+2, r24	; 0x02
	// Just to stop compiler warnings.
	( void ) pvParameters;
	// UBaseType_t ubtWM;	// Only Neceesary when debugging through COM port
	
	fnPrintString(txClearReset,7);
    2f82:	67 e0       	ldi	r22, 0x07	; 7
    2f84:	70 e0       	ldi	r23, 0x00	; 0
    2f86:	80 e1       	ldi	r24, 0x10	; 16
    2f88:	91 e0       	ldi	r25, 0x01	; 1
    2f8a:	0e 94 2c 18 	call	0x3058	; 0x3058 <fnPrintString>
	fnPrintString(txStartMessA,22);
    2f8e:	66 e1       	ldi	r22, 0x16	; 22
    2f90:	70 e0       	ldi	r23, 0x00	; 0
    2f92:	87 e1       	ldi	r24, 0x17	; 23
    2f94:	91 e0       	ldi	r25, 0x01	; 1
    2f96:	0e 94 2c 18 	call	0x3058	; 0x3058 <fnPrintString>
	fnPrintString(txStartMessB,28);
    2f9a:	6c e1       	ldi	r22, 0x1C	; 28
    2f9c:	70 e0       	ldi	r23, 0x00	; 0
    2f9e:	8d e2       	ldi	r24, 0x2D	; 45
    2fa0:	91 e0       	ldi	r25, 0x01	; 1
    2fa2:	0e 94 2c 18 	call	0x3058	; 0x3058 <fnPrintString>
	fnPrintString(txStartMessC,25);
    2fa6:	69 e1       	ldi	r22, 0x19	; 25
    2fa8:	70 e0       	ldi	r23, 0x00	; 0
    2faa:	89 e4       	ldi	r24, 0x49	; 73
    2fac:	91 e0       	ldi	r25, 0x01	; 1
    2fae:	0e 94 2c 18 	call	0x3058	; 0x3058 <fnPrintString>
		
	for( ;; )
	{
		// This is can also be the Rx code to interface with the board
		// Block until the first byte is received
		if (xSerialGetChar(xPort, &rxChar, comRX_BLOCK_TIME))
    2fb2:	80 91 75 08 	lds	r24, 0x0875
    2fb6:	90 91 76 08 	lds	r25, 0x0876
    2fba:	4f ef       	ldi	r20, 0xFF	; 255
    2fbc:	5f ef       	ldi	r21, 0xFF	; 255
    2fbe:	9e 01       	movw	r18, r28
    2fc0:	2f 5f       	subi	r18, 0xFF	; 255
    2fc2:	3f 4f       	sbci	r19, 0xFF	; 255
    2fc4:	b9 01       	movw	r22, r18
    2fc6:	0e 94 9a 03 	call	0x734	; 0x734 <xSerialGetChar>
    2fca:	88 23       	and	r24, r24
    2fcc:	09 f4       	brne	.+2      	; 0x2fd0 <vWelcomeTask+0x5e>
    2fce:	43 c0       	rjmp	.+134    	; 0x3056 <vWelcomeTask+0xe4>
		{
			// DO the following ONLY if the motor is present and functional
			if ( intPhase < 7 && intPhase > 0 ) {
    2fd0:	80 91 08 01 	lds	r24, 0x0108
    2fd4:	87 30       	cpi	r24, 0x07	; 7
    2fd6:	78 f5       	brcc	.+94     	; 0x3036 <vWelcomeTask+0xc4>
    2fd8:	80 91 08 01 	lds	r24, 0x0108
    2fdc:	88 23       	and	r24, r24
    2fde:	59 f1       	breq	.+86     	; 0x3036 <vWelcomeTask+0xc4>
				if ( rxChar == 'r' || rxChar == 'R' ) {	// If the character was R-r (RUN)
    2fe0:	89 81       	ldd	r24, Y+1	; 0x01
    2fe2:	82 37       	cpi	r24, 0x72	; 114
    2fe4:	19 f0       	breq	.+6      	; 0x2fec <vWelcomeTask+0x7a>
    2fe6:	89 81       	ldd	r24, Y+1	; 0x01
    2fe8:	82 35       	cpi	r24, 0x52	; 82
    2fea:	69 f4       	brne	.+26     	; 0x3006 <vWelcomeTask+0x94>
					if ( txMode == 'N' ) {	// If the Motor is at Rest
    2fec:	80 91 0f 01 	lds	r24, 0x010F
    2ff0:	8e 34       	cpi	r24, 0x4E	; 78
    2ff2:	41 f4       	brne	.+16     	; 0x3004 <vWelcomeTask+0x92>
						txMode = 'r';	// Switch Motor mode to RAMP up
    2ff4:	82 e7       	ldi	r24, 0x72	; 114
    2ff6:	80 93 0f 01 	sts	0x010F, r24
						clkElapsed = 0;	// Reset the RAMP timer
    2ffa:	10 92 7a 08 	sts	0x087A, r1
    2ffe:	10 92 79 08 	sts	0x0879, r1
		if (xSerialGetChar(xPort, &rxChar, comRX_BLOCK_TIME))
		{
			// DO the following ONLY if the motor is present and functional
			if ( intPhase < 7 && intPhase > 0 ) {
				if ( rxChar == 'r' || rxChar == 'R' ) {	// If the character was R-r (RUN)
					if ( txMode == 'N' ) {	// If the Motor is at Rest
    3002:	12 c0       	rjmp	.+36     	; 0x3028 <vWelcomeTask+0xb6>
    3004:	11 c0       	rjmp	.+34     	; 0x3028 <vWelcomeTask+0xb6>
						txMode = 'r';	// Switch Motor mode to RAMP up
						clkElapsed = 0;	// Reset the RAMP timer
					}
				} else if ( rxChar == 's' || rxChar == 'S' ) {	// If the character was S-s (STOP)
    3006:	89 81       	ldd	r24, Y+1	; 0x01
    3008:	83 37       	cpi	r24, 0x73	; 115
    300a:	19 f0       	breq	.+6      	; 0x3012 <vWelcomeTask+0xa0>
    300c:	89 81       	ldd	r24, Y+1	; 0x01
    300e:	83 35       	cpi	r24, 0x53	; 83
    3010:	59 f4       	brne	.+22     	; 0x3028 <vWelcomeTask+0xb6>
					if ( txMode == 'R' )	{	// If the motor is Running
    3012:	80 91 0f 01 	lds	r24, 0x010F
    3016:	82 35       	cpi	r24, 0x52	; 82
    3018:	39 f4       	brne	.+14     	; 0x3028 <vWelcomeTask+0xb6>
						txMode = 's';	// Switch the mode to RAMP down
    301a:	83 e7       	ldi	r24, 0x73	; 115
    301c:	80 93 0f 01 	sts	0x010F, r24
						clkElapsed = 0;	// Reset the RAMP timer
    3020:	10 92 7a 08 	sts	0x087A, r1
    3024:	10 92 79 08 	sts	0x0879, r1
					}
				}
				
				// ####### Resume the Ramp Up Task
				vTaskResume( VMOtorRamp_Handle );
    3028:	80 91 77 08 	lds	r24, 0x0877
    302c:	90 91 78 08 	lds	r25, 0x0878
    3030:	0e 94 e2 10 	call	0x21c4	; 0x21c4 <vTaskResume>
    3034:	10 c0       	rjmp	.+32     	; 0x3056 <vWelcomeTask+0xe4>
			} else {	// The motor is either not present OR it is not functional
				PORTC = mtrCW_Rotate[7];	// Clamp the Motor
    3036:	88 e2       	ldi	r24, 0x28	; 40
    3038:	90 e0       	ldi	r25, 0x00	; 0
    303a:	20 91 07 01 	lds	r18, 0x0107
    303e:	fc 01       	movw	r30, r24
    3040:	20 83       	st	Z, r18
				ledTaskRate = LED_TASK_RATE_ERROR;	// Set the Error Status Light
    3042:	83 e3       	ldi	r24, 0x33	; 51
    3044:	91 e0       	ldi	r25, 0x01	; 1
    3046:	90 93 a8 08 	sts	0x08A8, r25
    304a:	80 93 a7 08 	sts	0x08A7, r24
				txMode = 'N';	// Emphasize Motor Status of not-running
    304e:	8e e4       	ldi	r24, 0x4E	; 78
    3050:	80 93 0f 01 	sts	0x010F, r24
			}
		}
		
		//ubtWM = uxTaskGetStackHighWaterMark(NULL);  // GET watermark DATA
		//fnPrintWaterMark(ubtWM,2);
	}	
    3054:	ae cf       	rjmp	.-164    	; 0x2fb2 <vWelcomeTask+0x40>
    3056:	ad cf       	rjmp	.-166    	; 0x2fb2 <vWelcomeTask+0x40>

00003058 <fnPrintString>:

//////////////////////////////////////////////////////////////////////////
// The following is not a task, this is a function that will print the
//     given string on RS232
void fnPrintString(char* lnMessage, int lnSize)
{
    3058:	cf 93       	push	r28
    305a:	df 93       	push	r29
    305c:	00 d0       	rcall	.+0      	; 0x305e <fnPrintString+0x6>
    305e:	00 d0       	rcall	.+0      	; 0x3060 <fnPrintString+0x8>
    3060:	00 d0       	rcall	.+0      	; 0x3062 <fnPrintString+0xa>
    3062:	cd b7       	in	r28, 0x3d	; 61
    3064:	de b7       	in	r29, 0x3e	; 62
    3066:	9c 83       	std	Y+4, r25	; 0x04
    3068:	8b 83       	std	Y+3, r24	; 0x03
    306a:	7e 83       	std	Y+6, r23	; 0x06
    306c:	6d 83       	std	Y+5, r22	; 0x05
	int i; // Loop counter
	for( i=0 ; i<lnSize ; i++ )
    306e:	1a 82       	std	Y+2, r1	; 0x02
    3070:	19 82       	std	Y+1, r1	; 0x01
    3072:	20 c0       	rjmp	.+64     	; 0x30b4 <fnPrintString+0x5c>
	{
		vTaskDelay(1);
    3074:	81 e0       	ldi	r24, 0x01	; 1
    3076:	90 e0       	ldi	r25, 0x00	; 0
    3078:	0e 94 18 10 	call	0x2030	; 0x2030 <vTaskDelay>
		if( xSerialPutChar( xPort, *(lnMessage + i), comNO_BLOCK ) == pdPASS )
    307c:	89 81       	ldd	r24, Y+1	; 0x01
    307e:	9a 81       	ldd	r25, Y+2	; 0x02
    3080:	2b 81       	ldd	r18, Y+3	; 0x03
    3082:	3c 81       	ldd	r19, Y+4	; 0x04
    3084:	82 0f       	add	r24, r18
    3086:	93 1f       	adc	r25, r19
    3088:	fc 01       	movw	r30, r24
    308a:	80 81       	ld	r24, Z
    308c:	28 2f       	mov	r18, r24
    308e:	80 91 75 08 	lds	r24, 0x0875
    3092:	90 91 76 08 	lds	r25, 0x0876
    3096:	40 e0       	ldi	r20, 0x00	; 0
    3098:	50 e0       	ldi	r21, 0x00	; 0
    309a:	62 2f       	mov	r22, r18
    309c:	0e 94 c0 03 	call	0x780	; 0x780 <xSerialPutChar>
    30a0:	81 30       	cpi	r24, 0x01	; 1
    30a2:	19 f4       	brne	.+6      	; 0x30aa <fnPrintString+0x52>
		{
			vParTestToggleLED((portBASE_TYPE) 6); // Blink while activity
    30a4:	86 e0       	ldi	r24, 0x06	; 6
    30a6:	0e 94 3f 17 	call	0x2e7e	; 0x2e7e <vParTestToggleLED>
// The following is not a task, this is a function that will print the
//     given string on RS232
void fnPrintString(char* lnMessage, int lnSize)
{
	int i; // Loop counter
	for( i=0 ; i<lnSize ; i++ )
    30aa:	89 81       	ldd	r24, Y+1	; 0x01
    30ac:	9a 81       	ldd	r25, Y+2	; 0x02
    30ae:	01 96       	adiw	r24, 0x01	; 1
    30b0:	9a 83       	std	Y+2, r25	; 0x02
    30b2:	89 83       	std	Y+1, r24	; 0x01
    30b4:	29 81       	ldd	r18, Y+1	; 0x01
    30b6:	3a 81       	ldd	r19, Y+2	; 0x02
    30b8:	8d 81       	ldd	r24, Y+5	; 0x05
    30ba:	9e 81       	ldd	r25, Y+6	; 0x06
    30bc:	28 17       	cp	r18, r24
    30be:	39 07       	cpc	r19, r25
    30c0:	cc f2       	brlt	.-78     	; 0x3074 <fnPrintString+0x1c>
			vParTestToggleLED((portBASE_TYPE) 6); // Blink while activity
		}
	}
	
	// Turn the LED off while we are not doing anything.
	vParTestSetLED((portBASE_TYPE) 6, pdFALSE);
    30c2:	60 e0       	ldi	r22, 0x00	; 0
    30c4:	86 e0       	ldi	r24, 0x06	; 6
    30c6:	0e 94 03 17 	call	0x2e06	; 0x2e06 <vParTestSetLED>
}
    30ca:	26 96       	adiw	r28, 0x06	; 6
    30cc:	0f b6       	in	r0, 0x3f	; 63
    30ce:	f8 94       	cli
    30d0:	de bf       	out	0x3e, r29	; 62
    30d2:	0f be       	out	0x3f, r0	; 63
    30d4:	cd bf       	out	0x3d, r28	; 61
    30d6:	df 91       	pop	r29
    30d8:	cf 91       	pop	r28
    30da:	08 95       	ret

000030dc <__subsf3>:
    30dc:	50 58       	subi	r21, 0x80	; 128

000030de <__addsf3>:
    30de:	bb 27       	eor	r27, r27
    30e0:	aa 27       	eor	r26, r26
    30e2:	0e d0       	rcall	.+28     	; 0x3100 <__addsf3x>
    30e4:	08 c1       	rjmp	.+528    	; 0x32f6 <__fp_round>
    30e6:	f9 d0       	rcall	.+498    	; 0x32da <__fp_pscA>
    30e8:	30 f0       	brcs	.+12     	; 0x30f6 <__addsf3+0x18>
    30ea:	fe d0       	rcall	.+508    	; 0x32e8 <__fp_pscB>
    30ec:	20 f0       	brcs	.+8      	; 0x30f6 <__addsf3+0x18>
    30ee:	31 f4       	brne	.+12     	; 0x30fc <__addsf3+0x1e>
    30f0:	9f 3f       	cpi	r25, 0xFF	; 255
    30f2:	11 f4       	brne	.+4      	; 0x30f8 <__addsf3+0x1a>
    30f4:	1e f4       	brtc	.+6      	; 0x30fc <__addsf3+0x1e>
    30f6:	ee c0       	rjmp	.+476    	; 0x32d4 <__fp_nan>
    30f8:	0e f4       	brtc	.+2      	; 0x30fc <__addsf3+0x1e>
    30fa:	e0 95       	com	r30
    30fc:	e7 fb       	bst	r30, 7
    30fe:	e4 c0       	rjmp	.+456    	; 0x32c8 <__fp_inf>

00003100 <__addsf3x>:
    3100:	e9 2f       	mov	r30, r25
    3102:	0a d1       	rcall	.+532    	; 0x3318 <__fp_split3>
    3104:	80 f3       	brcs	.-32     	; 0x30e6 <__addsf3+0x8>
    3106:	ba 17       	cp	r27, r26
    3108:	62 07       	cpc	r22, r18
    310a:	73 07       	cpc	r23, r19
    310c:	84 07       	cpc	r24, r20
    310e:	95 07       	cpc	r25, r21
    3110:	18 f0       	brcs	.+6      	; 0x3118 <__addsf3x+0x18>
    3112:	71 f4       	brne	.+28     	; 0x3130 <__addsf3x+0x30>
    3114:	9e f5       	brtc	.+102    	; 0x317c <__addsf3x+0x7c>
    3116:	22 c1       	rjmp	.+580    	; 0x335c <__fp_zero>
    3118:	0e f4       	brtc	.+2      	; 0x311c <__addsf3x+0x1c>
    311a:	e0 95       	com	r30
    311c:	0b 2e       	mov	r0, r27
    311e:	ba 2f       	mov	r27, r26
    3120:	a0 2d       	mov	r26, r0
    3122:	0b 01       	movw	r0, r22
    3124:	b9 01       	movw	r22, r18
    3126:	90 01       	movw	r18, r0
    3128:	0c 01       	movw	r0, r24
    312a:	ca 01       	movw	r24, r20
    312c:	a0 01       	movw	r20, r0
    312e:	11 24       	eor	r1, r1
    3130:	ff 27       	eor	r31, r31
    3132:	59 1b       	sub	r21, r25
    3134:	99 f0       	breq	.+38     	; 0x315c <__addsf3x+0x5c>
    3136:	59 3f       	cpi	r21, 0xF9	; 249
    3138:	50 f4       	brcc	.+20     	; 0x314e <__addsf3x+0x4e>
    313a:	50 3e       	cpi	r21, 0xE0	; 224
    313c:	68 f1       	brcs	.+90     	; 0x3198 <__addsf3x+0x98>
    313e:	1a 16       	cp	r1, r26
    3140:	f0 40       	sbci	r31, 0x00	; 0
    3142:	a2 2f       	mov	r26, r18
    3144:	23 2f       	mov	r18, r19
    3146:	34 2f       	mov	r19, r20
    3148:	44 27       	eor	r20, r20
    314a:	58 5f       	subi	r21, 0xF8	; 248
    314c:	f3 cf       	rjmp	.-26     	; 0x3134 <__addsf3x+0x34>
    314e:	46 95       	lsr	r20
    3150:	37 95       	ror	r19
    3152:	27 95       	ror	r18
    3154:	a7 95       	ror	r26
    3156:	f0 40       	sbci	r31, 0x00	; 0
    3158:	53 95       	inc	r21
    315a:	c9 f7       	brne	.-14     	; 0x314e <__addsf3x+0x4e>
    315c:	7e f4       	brtc	.+30     	; 0x317c <__addsf3x+0x7c>
    315e:	1f 16       	cp	r1, r31
    3160:	ba 0b       	sbc	r27, r26
    3162:	62 0b       	sbc	r22, r18
    3164:	73 0b       	sbc	r23, r19
    3166:	84 0b       	sbc	r24, r20
    3168:	ba f0       	brmi	.+46     	; 0x3198 <__addsf3x+0x98>
    316a:	91 50       	subi	r25, 0x01	; 1
    316c:	a1 f0       	breq	.+40     	; 0x3196 <__addsf3x+0x96>
    316e:	ff 0f       	add	r31, r31
    3170:	bb 1f       	adc	r27, r27
    3172:	66 1f       	adc	r22, r22
    3174:	77 1f       	adc	r23, r23
    3176:	88 1f       	adc	r24, r24
    3178:	c2 f7       	brpl	.-16     	; 0x316a <__addsf3x+0x6a>
    317a:	0e c0       	rjmp	.+28     	; 0x3198 <__addsf3x+0x98>
    317c:	ba 0f       	add	r27, r26
    317e:	62 1f       	adc	r22, r18
    3180:	73 1f       	adc	r23, r19
    3182:	84 1f       	adc	r24, r20
    3184:	48 f4       	brcc	.+18     	; 0x3198 <__addsf3x+0x98>
    3186:	87 95       	ror	r24
    3188:	77 95       	ror	r23
    318a:	67 95       	ror	r22
    318c:	b7 95       	ror	r27
    318e:	f7 95       	ror	r31
    3190:	9e 3f       	cpi	r25, 0xFE	; 254
    3192:	08 f0       	brcs	.+2      	; 0x3196 <__addsf3x+0x96>
    3194:	b3 cf       	rjmp	.-154    	; 0x30fc <__addsf3+0x1e>
    3196:	93 95       	inc	r25
    3198:	88 0f       	add	r24, r24
    319a:	08 f0       	brcs	.+2      	; 0x319e <__addsf3x+0x9e>
    319c:	99 27       	eor	r25, r25
    319e:	ee 0f       	add	r30, r30
    31a0:	97 95       	ror	r25
    31a2:	87 95       	ror	r24
    31a4:	08 95       	ret

000031a6 <__cmpsf2>:
    31a6:	6c d0       	rcall	.+216    	; 0x3280 <__fp_cmp>
    31a8:	08 f4       	brcc	.+2      	; 0x31ac <__cmpsf2+0x6>
    31aa:	81 e0       	ldi	r24, 0x01	; 1
    31ac:	08 95       	ret

000031ae <__fixunssfsi>:
    31ae:	bc d0       	rcall	.+376    	; 0x3328 <__fp_splitA>
    31b0:	88 f0       	brcs	.+34     	; 0x31d4 <__fixunssfsi+0x26>
    31b2:	9f 57       	subi	r25, 0x7F	; 127
    31b4:	90 f0       	brcs	.+36     	; 0x31da <__fixunssfsi+0x2c>
    31b6:	b9 2f       	mov	r27, r25
    31b8:	99 27       	eor	r25, r25
    31ba:	b7 51       	subi	r27, 0x17	; 23
    31bc:	a0 f0       	brcs	.+40     	; 0x31e6 <__fixunssfsi+0x38>
    31be:	d1 f0       	breq	.+52     	; 0x31f4 <__fixunssfsi+0x46>
    31c0:	66 0f       	add	r22, r22
    31c2:	77 1f       	adc	r23, r23
    31c4:	88 1f       	adc	r24, r24
    31c6:	99 1f       	adc	r25, r25
    31c8:	1a f0       	brmi	.+6      	; 0x31d0 <__fixunssfsi+0x22>
    31ca:	ba 95       	dec	r27
    31cc:	c9 f7       	brne	.-14     	; 0x31c0 <__fixunssfsi+0x12>
    31ce:	12 c0       	rjmp	.+36     	; 0x31f4 <__fixunssfsi+0x46>
    31d0:	b1 30       	cpi	r27, 0x01	; 1
    31d2:	81 f0       	breq	.+32     	; 0x31f4 <__fixunssfsi+0x46>
    31d4:	c3 d0       	rcall	.+390    	; 0x335c <__fp_zero>
    31d6:	b1 e0       	ldi	r27, 0x01	; 1
    31d8:	08 95       	ret
    31da:	c0 c0       	rjmp	.+384    	; 0x335c <__fp_zero>
    31dc:	67 2f       	mov	r22, r23
    31de:	78 2f       	mov	r23, r24
    31e0:	88 27       	eor	r24, r24
    31e2:	b8 5f       	subi	r27, 0xF8	; 248
    31e4:	39 f0       	breq	.+14     	; 0x31f4 <__fixunssfsi+0x46>
    31e6:	b9 3f       	cpi	r27, 0xF9	; 249
    31e8:	cc f3       	brlt	.-14     	; 0x31dc <__fixunssfsi+0x2e>
    31ea:	86 95       	lsr	r24
    31ec:	77 95       	ror	r23
    31ee:	67 95       	ror	r22
    31f0:	b3 95       	inc	r27
    31f2:	d9 f7       	brne	.-10     	; 0x31ea <__fixunssfsi+0x3c>
    31f4:	3e f4       	brtc	.+14     	; 0x3204 <__fixunssfsi+0x56>
    31f6:	90 95       	com	r25
    31f8:	80 95       	com	r24
    31fa:	70 95       	com	r23
    31fc:	61 95       	neg	r22
    31fe:	7f 4f       	sbci	r23, 0xFF	; 255
    3200:	8f 4f       	sbci	r24, 0xFF	; 255
    3202:	9f 4f       	sbci	r25, 0xFF	; 255
    3204:	08 95       	ret

00003206 <__floatunsisf>:
    3206:	e8 94       	clt
    3208:	09 c0       	rjmp	.+18     	; 0x321c <__floatsisf+0x12>

0000320a <__floatsisf>:
    320a:	97 fb       	bst	r25, 7
    320c:	3e f4       	brtc	.+14     	; 0x321c <__floatsisf+0x12>
    320e:	90 95       	com	r25
    3210:	80 95       	com	r24
    3212:	70 95       	com	r23
    3214:	61 95       	neg	r22
    3216:	7f 4f       	sbci	r23, 0xFF	; 255
    3218:	8f 4f       	sbci	r24, 0xFF	; 255
    321a:	9f 4f       	sbci	r25, 0xFF	; 255
    321c:	99 23       	and	r25, r25
    321e:	a9 f0       	breq	.+42     	; 0x324a <__floatsisf+0x40>
    3220:	f9 2f       	mov	r31, r25
    3222:	96 e9       	ldi	r25, 0x96	; 150
    3224:	bb 27       	eor	r27, r27
    3226:	93 95       	inc	r25
    3228:	f6 95       	lsr	r31
    322a:	87 95       	ror	r24
    322c:	77 95       	ror	r23
    322e:	67 95       	ror	r22
    3230:	b7 95       	ror	r27
    3232:	f1 11       	cpse	r31, r1
    3234:	f8 cf       	rjmp	.-16     	; 0x3226 <__floatsisf+0x1c>
    3236:	fa f4       	brpl	.+62     	; 0x3276 <__floatsisf+0x6c>
    3238:	bb 0f       	add	r27, r27
    323a:	11 f4       	brne	.+4      	; 0x3240 <__floatsisf+0x36>
    323c:	60 ff       	sbrs	r22, 0
    323e:	1b c0       	rjmp	.+54     	; 0x3276 <__floatsisf+0x6c>
    3240:	6f 5f       	subi	r22, 0xFF	; 255
    3242:	7f 4f       	sbci	r23, 0xFF	; 255
    3244:	8f 4f       	sbci	r24, 0xFF	; 255
    3246:	9f 4f       	sbci	r25, 0xFF	; 255
    3248:	16 c0       	rjmp	.+44     	; 0x3276 <__floatsisf+0x6c>
    324a:	88 23       	and	r24, r24
    324c:	11 f0       	breq	.+4      	; 0x3252 <__floatsisf+0x48>
    324e:	96 e9       	ldi	r25, 0x96	; 150
    3250:	11 c0       	rjmp	.+34     	; 0x3274 <__floatsisf+0x6a>
    3252:	77 23       	and	r23, r23
    3254:	21 f0       	breq	.+8      	; 0x325e <__floatsisf+0x54>
    3256:	9e e8       	ldi	r25, 0x8E	; 142
    3258:	87 2f       	mov	r24, r23
    325a:	76 2f       	mov	r23, r22
    325c:	05 c0       	rjmp	.+10     	; 0x3268 <__floatsisf+0x5e>
    325e:	66 23       	and	r22, r22
    3260:	71 f0       	breq	.+28     	; 0x327e <__floatsisf+0x74>
    3262:	96 e8       	ldi	r25, 0x86	; 134
    3264:	86 2f       	mov	r24, r22
    3266:	70 e0       	ldi	r23, 0x00	; 0
    3268:	60 e0       	ldi	r22, 0x00	; 0
    326a:	2a f0       	brmi	.+10     	; 0x3276 <__floatsisf+0x6c>
    326c:	9a 95       	dec	r25
    326e:	66 0f       	add	r22, r22
    3270:	77 1f       	adc	r23, r23
    3272:	88 1f       	adc	r24, r24
    3274:	da f7       	brpl	.-10     	; 0x326c <__floatsisf+0x62>
    3276:	88 0f       	add	r24, r24
    3278:	96 95       	lsr	r25
    327a:	87 95       	ror	r24
    327c:	97 f9       	bld	r25, 7
    327e:	08 95       	ret

00003280 <__fp_cmp>:
    3280:	99 0f       	add	r25, r25
    3282:	00 08       	sbc	r0, r0
    3284:	55 0f       	add	r21, r21
    3286:	aa 0b       	sbc	r26, r26
    3288:	e0 e8       	ldi	r30, 0x80	; 128
    328a:	fe ef       	ldi	r31, 0xFE	; 254
    328c:	16 16       	cp	r1, r22
    328e:	17 06       	cpc	r1, r23
    3290:	e8 07       	cpc	r30, r24
    3292:	f9 07       	cpc	r31, r25
    3294:	c0 f0       	brcs	.+48     	; 0x32c6 <__fp_cmp+0x46>
    3296:	12 16       	cp	r1, r18
    3298:	13 06       	cpc	r1, r19
    329a:	e4 07       	cpc	r30, r20
    329c:	f5 07       	cpc	r31, r21
    329e:	98 f0       	brcs	.+38     	; 0x32c6 <__fp_cmp+0x46>
    32a0:	62 1b       	sub	r22, r18
    32a2:	73 0b       	sbc	r23, r19
    32a4:	84 0b       	sbc	r24, r20
    32a6:	95 0b       	sbc	r25, r21
    32a8:	39 f4       	brne	.+14     	; 0x32b8 <__fp_cmp+0x38>
    32aa:	0a 26       	eor	r0, r26
    32ac:	61 f0       	breq	.+24     	; 0x32c6 <__fp_cmp+0x46>
    32ae:	23 2b       	or	r18, r19
    32b0:	24 2b       	or	r18, r20
    32b2:	25 2b       	or	r18, r21
    32b4:	21 f4       	brne	.+8      	; 0x32be <__fp_cmp+0x3e>
    32b6:	08 95       	ret
    32b8:	0a 26       	eor	r0, r26
    32ba:	09 f4       	brne	.+2      	; 0x32be <__fp_cmp+0x3e>
    32bc:	a1 40       	sbci	r26, 0x01	; 1
    32be:	a6 95       	lsr	r26
    32c0:	8f ef       	ldi	r24, 0xFF	; 255
    32c2:	81 1d       	adc	r24, r1
    32c4:	81 1d       	adc	r24, r1
    32c6:	08 95       	ret

000032c8 <__fp_inf>:
    32c8:	97 f9       	bld	r25, 7
    32ca:	9f 67       	ori	r25, 0x7F	; 127
    32cc:	80 e8       	ldi	r24, 0x80	; 128
    32ce:	70 e0       	ldi	r23, 0x00	; 0
    32d0:	60 e0       	ldi	r22, 0x00	; 0
    32d2:	08 95       	ret

000032d4 <__fp_nan>:
    32d4:	9f ef       	ldi	r25, 0xFF	; 255
    32d6:	80 ec       	ldi	r24, 0xC0	; 192
    32d8:	08 95       	ret

000032da <__fp_pscA>:
    32da:	00 24       	eor	r0, r0
    32dc:	0a 94       	dec	r0
    32de:	16 16       	cp	r1, r22
    32e0:	17 06       	cpc	r1, r23
    32e2:	18 06       	cpc	r1, r24
    32e4:	09 06       	cpc	r0, r25
    32e6:	08 95       	ret

000032e8 <__fp_pscB>:
    32e8:	00 24       	eor	r0, r0
    32ea:	0a 94       	dec	r0
    32ec:	12 16       	cp	r1, r18
    32ee:	13 06       	cpc	r1, r19
    32f0:	14 06       	cpc	r1, r20
    32f2:	05 06       	cpc	r0, r21
    32f4:	08 95       	ret

000032f6 <__fp_round>:
    32f6:	09 2e       	mov	r0, r25
    32f8:	03 94       	inc	r0
    32fa:	00 0c       	add	r0, r0
    32fc:	11 f4       	brne	.+4      	; 0x3302 <__fp_round+0xc>
    32fe:	88 23       	and	r24, r24
    3300:	52 f0       	brmi	.+20     	; 0x3316 <__fp_round+0x20>
    3302:	bb 0f       	add	r27, r27
    3304:	40 f4       	brcc	.+16     	; 0x3316 <__fp_round+0x20>
    3306:	bf 2b       	or	r27, r31
    3308:	11 f4       	brne	.+4      	; 0x330e <__fp_round+0x18>
    330a:	60 ff       	sbrs	r22, 0
    330c:	04 c0       	rjmp	.+8      	; 0x3316 <__fp_round+0x20>
    330e:	6f 5f       	subi	r22, 0xFF	; 255
    3310:	7f 4f       	sbci	r23, 0xFF	; 255
    3312:	8f 4f       	sbci	r24, 0xFF	; 255
    3314:	9f 4f       	sbci	r25, 0xFF	; 255
    3316:	08 95       	ret

00003318 <__fp_split3>:
    3318:	57 fd       	sbrc	r21, 7
    331a:	90 58       	subi	r25, 0x80	; 128
    331c:	44 0f       	add	r20, r20
    331e:	55 1f       	adc	r21, r21
    3320:	59 f0       	breq	.+22     	; 0x3338 <__fp_splitA+0x10>
    3322:	5f 3f       	cpi	r21, 0xFF	; 255
    3324:	71 f0       	breq	.+28     	; 0x3342 <__fp_splitA+0x1a>
    3326:	47 95       	ror	r20

00003328 <__fp_splitA>:
    3328:	88 0f       	add	r24, r24
    332a:	97 fb       	bst	r25, 7
    332c:	99 1f       	adc	r25, r25
    332e:	61 f0       	breq	.+24     	; 0x3348 <__fp_splitA+0x20>
    3330:	9f 3f       	cpi	r25, 0xFF	; 255
    3332:	79 f0       	breq	.+30     	; 0x3352 <__fp_splitA+0x2a>
    3334:	87 95       	ror	r24
    3336:	08 95       	ret
    3338:	12 16       	cp	r1, r18
    333a:	13 06       	cpc	r1, r19
    333c:	14 06       	cpc	r1, r20
    333e:	55 1f       	adc	r21, r21
    3340:	f2 cf       	rjmp	.-28     	; 0x3326 <__fp_split3+0xe>
    3342:	46 95       	lsr	r20
    3344:	f1 df       	rcall	.-30     	; 0x3328 <__fp_splitA>
    3346:	08 c0       	rjmp	.+16     	; 0x3358 <__fp_splitA+0x30>
    3348:	16 16       	cp	r1, r22
    334a:	17 06       	cpc	r1, r23
    334c:	18 06       	cpc	r1, r24
    334e:	99 1f       	adc	r25, r25
    3350:	f1 cf       	rjmp	.-30     	; 0x3334 <__fp_splitA+0xc>
    3352:	86 95       	lsr	r24
    3354:	71 05       	cpc	r23, r1
    3356:	61 05       	cpc	r22, r1
    3358:	08 94       	sec
    335a:	08 95       	ret

0000335c <__fp_zero>:
    335c:	e8 94       	clt

0000335e <__fp_szero>:
    335e:	bb 27       	eor	r27, r27
    3360:	66 27       	eor	r22, r22
    3362:	77 27       	eor	r23, r23
    3364:	cb 01       	movw	r24, r22
    3366:	97 f9       	bld	r25, 7
    3368:	08 95       	ret

0000336a <__gesf2>:
    336a:	8a df       	rcall	.-236    	; 0x3280 <__fp_cmp>
    336c:	08 f4       	brcc	.+2      	; 0x3370 <__gesf2+0x6>
    336e:	8f ef       	ldi	r24, 0xFF	; 255
    3370:	08 95       	ret

00003372 <__mulsf3>:
    3372:	0b d0       	rcall	.+22     	; 0x338a <__mulsf3x>
    3374:	c0 cf       	rjmp	.-128    	; 0x32f6 <__fp_round>
    3376:	b1 df       	rcall	.-158    	; 0x32da <__fp_pscA>
    3378:	28 f0       	brcs	.+10     	; 0x3384 <__mulsf3+0x12>
    337a:	b6 df       	rcall	.-148    	; 0x32e8 <__fp_pscB>
    337c:	18 f0       	brcs	.+6      	; 0x3384 <__mulsf3+0x12>
    337e:	95 23       	and	r25, r21
    3380:	09 f0       	breq	.+2      	; 0x3384 <__mulsf3+0x12>
    3382:	a2 cf       	rjmp	.-188    	; 0x32c8 <__fp_inf>
    3384:	a7 cf       	rjmp	.-178    	; 0x32d4 <__fp_nan>
    3386:	11 24       	eor	r1, r1
    3388:	ea cf       	rjmp	.-44     	; 0x335e <__fp_szero>

0000338a <__mulsf3x>:
    338a:	c6 df       	rcall	.-116    	; 0x3318 <__fp_split3>
    338c:	a0 f3       	brcs	.-24     	; 0x3376 <__mulsf3+0x4>

0000338e <__mulsf3_pse>:
    338e:	95 9f       	mul	r25, r21
    3390:	d1 f3       	breq	.-12     	; 0x3386 <__mulsf3+0x14>
    3392:	95 0f       	add	r25, r21
    3394:	50 e0       	ldi	r21, 0x00	; 0
    3396:	55 1f       	adc	r21, r21
    3398:	62 9f       	mul	r22, r18
    339a:	f0 01       	movw	r30, r0
    339c:	72 9f       	mul	r23, r18
    339e:	bb 27       	eor	r27, r27
    33a0:	f0 0d       	add	r31, r0
    33a2:	b1 1d       	adc	r27, r1
    33a4:	63 9f       	mul	r22, r19
    33a6:	aa 27       	eor	r26, r26
    33a8:	f0 0d       	add	r31, r0
    33aa:	b1 1d       	adc	r27, r1
    33ac:	aa 1f       	adc	r26, r26
    33ae:	64 9f       	mul	r22, r20
    33b0:	66 27       	eor	r22, r22
    33b2:	b0 0d       	add	r27, r0
    33b4:	a1 1d       	adc	r26, r1
    33b6:	66 1f       	adc	r22, r22
    33b8:	82 9f       	mul	r24, r18
    33ba:	22 27       	eor	r18, r18
    33bc:	b0 0d       	add	r27, r0
    33be:	a1 1d       	adc	r26, r1
    33c0:	62 1f       	adc	r22, r18
    33c2:	73 9f       	mul	r23, r19
    33c4:	b0 0d       	add	r27, r0
    33c6:	a1 1d       	adc	r26, r1
    33c8:	62 1f       	adc	r22, r18
    33ca:	83 9f       	mul	r24, r19
    33cc:	a0 0d       	add	r26, r0
    33ce:	61 1d       	adc	r22, r1
    33d0:	22 1f       	adc	r18, r18
    33d2:	74 9f       	mul	r23, r20
    33d4:	33 27       	eor	r19, r19
    33d6:	a0 0d       	add	r26, r0
    33d8:	61 1d       	adc	r22, r1
    33da:	23 1f       	adc	r18, r19
    33dc:	84 9f       	mul	r24, r20
    33de:	60 0d       	add	r22, r0
    33e0:	21 1d       	adc	r18, r1
    33e2:	82 2f       	mov	r24, r18
    33e4:	76 2f       	mov	r23, r22
    33e6:	6a 2f       	mov	r22, r26
    33e8:	11 24       	eor	r1, r1
    33ea:	9f 57       	subi	r25, 0x7F	; 127
    33ec:	50 40       	sbci	r21, 0x00	; 0
    33ee:	8a f0       	brmi	.+34     	; 0x3412 <__mulsf3_pse+0x84>
    33f0:	e1 f0       	breq	.+56     	; 0x342a <__mulsf3_pse+0x9c>
    33f2:	88 23       	and	r24, r24
    33f4:	4a f0       	brmi	.+18     	; 0x3408 <__mulsf3_pse+0x7a>
    33f6:	ee 0f       	add	r30, r30
    33f8:	ff 1f       	adc	r31, r31
    33fa:	bb 1f       	adc	r27, r27
    33fc:	66 1f       	adc	r22, r22
    33fe:	77 1f       	adc	r23, r23
    3400:	88 1f       	adc	r24, r24
    3402:	91 50       	subi	r25, 0x01	; 1
    3404:	50 40       	sbci	r21, 0x00	; 0
    3406:	a9 f7       	brne	.-22     	; 0x33f2 <__mulsf3_pse+0x64>
    3408:	9e 3f       	cpi	r25, 0xFE	; 254
    340a:	51 05       	cpc	r21, r1
    340c:	70 f0       	brcs	.+28     	; 0x342a <__mulsf3_pse+0x9c>
    340e:	5c cf       	rjmp	.-328    	; 0x32c8 <__fp_inf>
    3410:	a6 cf       	rjmp	.-180    	; 0x335e <__fp_szero>
    3412:	5f 3f       	cpi	r21, 0xFF	; 255
    3414:	ec f3       	brlt	.-6      	; 0x3410 <__mulsf3_pse+0x82>
    3416:	98 3e       	cpi	r25, 0xE8	; 232
    3418:	dc f3       	brlt	.-10     	; 0x3410 <__mulsf3_pse+0x82>
    341a:	86 95       	lsr	r24
    341c:	77 95       	ror	r23
    341e:	67 95       	ror	r22
    3420:	b7 95       	ror	r27
    3422:	f7 95       	ror	r31
    3424:	e7 95       	ror	r30
    3426:	9f 5f       	subi	r25, 0xFF	; 255
    3428:	c1 f7       	brne	.-16     	; 0x341a <__mulsf3_pse+0x8c>
    342a:	fe 2b       	or	r31, r30
    342c:	88 0f       	add	r24, r24
    342e:	91 1d       	adc	r25, r1
    3430:	96 95       	lsr	r25
    3432:	87 95       	ror	r24
    3434:	97 f9       	bld	r25, 7
    3436:	08 95       	ret

00003438 <__udivmodsi4>:
    3438:	a1 e2       	ldi	r26, 0x21	; 33
    343a:	1a 2e       	mov	r1, r26
    343c:	aa 1b       	sub	r26, r26
    343e:	bb 1b       	sub	r27, r27
    3440:	fd 01       	movw	r30, r26
    3442:	0d c0       	rjmp	.+26     	; 0x345e <__udivmodsi4_ep>

00003444 <__udivmodsi4_loop>:
    3444:	aa 1f       	adc	r26, r26
    3446:	bb 1f       	adc	r27, r27
    3448:	ee 1f       	adc	r30, r30
    344a:	ff 1f       	adc	r31, r31
    344c:	a2 17       	cp	r26, r18
    344e:	b3 07       	cpc	r27, r19
    3450:	e4 07       	cpc	r30, r20
    3452:	f5 07       	cpc	r31, r21
    3454:	20 f0       	brcs	.+8      	; 0x345e <__udivmodsi4_ep>
    3456:	a2 1b       	sub	r26, r18
    3458:	b3 0b       	sbc	r27, r19
    345a:	e4 0b       	sbc	r30, r20
    345c:	f5 0b       	sbc	r31, r21

0000345e <__udivmodsi4_ep>:
    345e:	66 1f       	adc	r22, r22
    3460:	77 1f       	adc	r23, r23
    3462:	88 1f       	adc	r24, r24
    3464:	99 1f       	adc	r25, r25
    3466:	1a 94       	dec	r1
    3468:	69 f7       	brne	.-38     	; 0x3444 <__udivmodsi4_loop>
    346a:	60 95       	com	r22
    346c:	70 95       	com	r23
    346e:	80 95       	com	r24
    3470:	90 95       	com	r25
    3472:	9b 01       	movw	r18, r22
    3474:	ac 01       	movw	r20, r24
    3476:	bd 01       	movw	r22, r26
    3478:	cf 01       	movw	r24, r30
    347a:	08 95       	ret

0000347c <memcpy>:
    347c:	fb 01       	movw	r30, r22
    347e:	dc 01       	movw	r26, r24
    3480:	02 c0       	rjmp	.+4      	; 0x3486 <memcpy+0xa>
    3482:	01 90       	ld	r0, Z+
    3484:	0d 92       	st	X+, r0
    3486:	41 50       	subi	r20, 0x01	; 1
    3488:	50 40       	sbci	r21, 0x00	; 0
    348a:	d8 f7       	brcc	.-10     	; 0x3482 <memcpy+0x6>
    348c:	08 95       	ret

0000348e <memset>:
    348e:	dc 01       	movw	r26, r24
    3490:	01 c0       	rjmp	.+2      	; 0x3494 <memset+0x6>
    3492:	6d 93       	st	X+, r22
    3494:	41 50       	subi	r20, 0x01	; 1
    3496:	50 40       	sbci	r21, 0x00	; 0
    3498:	e0 f7       	brcc	.-8      	; 0x3492 <memset+0x4>
    349a:	08 95       	ret

0000349c <_exit>:
    349c:	f8 94       	cli

0000349e <__stop_program>:
    349e:	ff cf       	rjmp	.-2      	; 0x349e <__stop_program>
